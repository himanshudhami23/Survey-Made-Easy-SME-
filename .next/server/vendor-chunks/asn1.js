/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/asn1";
exports.ids = ["vendor-chunks/asn1"];
exports.modules = {

/***/ "(rsc)/./node_modules/asn1/lib/ber/errors.js":
/*!*********************************************!*\
  !*** ./node_modules/asn1/lib/ber/errors.js ***!
  \*********************************************/
/***/ ((module) => {

eval("// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\n\nmodule.exports = {\n\n  newInvalidAsn1Error: function (msg) {\n    var e = new Error();\n    e.name = 'InvalidAsn1Error';\n    e.message = msg || '';\n    return e;\n  }\n\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYXNuMS9saWIvYmVyL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGFnZS1mb3JtLy4vbm9kZV9tb2R1bGVzL2FzbjEvbGliL2Jlci9lcnJvcnMuanM/YTkyZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxMSBNYXJrIENhdmFnZSA8bWNhdmFnZUBnbWFpbC5jb20+IEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgbmV3SW52YWxpZEFzbjFFcnJvcjogZnVuY3Rpb24gKG1zZykge1xuICAgIHZhciBlID0gbmV3IEVycm9yKCk7XG4gICAgZS5uYW1lID0gJ0ludmFsaWRBc24xRXJyb3InO1xuICAgIGUubWVzc2FnZSA9IG1zZyB8fCAnJztcbiAgICByZXR1cm4gZTtcbiAgfVxuXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/asn1/lib/ber/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/asn1/lib/ber/index.js":
/*!********************************************!*\
  !*** ./node_modules/asn1/lib/ber/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\nvar errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/asn1/lib/ber/errors.js\");\nvar types = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/asn1/lib/ber/types.js\");\n\nvar Reader = __webpack_require__(/*! ./reader */ \"(rsc)/./node_modules/asn1/lib/ber/reader.js\");\nvar Writer = __webpack_require__(/*! ./writer */ \"(rsc)/./node_modules/asn1/lib/ber/writer.js\");\n\n\n// --- Exports\n\nmodule.exports = {\n\n  Reader: Reader,\n\n  Writer: Writer\n\n};\n\nfor (var t in types) {\n  if (types.hasOwnProperty(t))\n    module.exports[t] = types[t];\n}\nfor (var e in errors) {\n  if (errors.hasOwnProperty(e))\n    module.exports[e] = errors[e];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYXNuMS9saWIvYmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyw2REFBVTtBQUMvQixZQUFZLG1CQUFPLENBQUMsMkRBQVM7O0FBRTdCLGFBQWEsbUJBQU8sQ0FBQyw2REFBVTtBQUMvQixhQUFhLG1CQUFPLENBQUMsNkRBQVU7OztBQUcvQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGFnZS1mb3JtLy4vbm9kZV9tb2R1bGVzL2FzbjEvbGliL2Jlci9pbmRleC5qcz9iMzNiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDExIE1hcmsgQ2F2YWdlIDxtY2F2YWdlQGdtYWlsLmNvbT4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG52YXIgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5cbnZhciBSZWFkZXIgPSByZXF1aXJlKCcuL3JlYWRlcicpO1xudmFyIFdyaXRlciA9IHJlcXVpcmUoJy4vd3JpdGVyJyk7XG5cblxuLy8gLS0tIEV4cG9ydHNcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgUmVhZGVyOiBSZWFkZXIsXG5cbiAgV3JpdGVyOiBXcml0ZXJcblxufTtcblxuZm9yICh2YXIgdCBpbiB0eXBlcykge1xuICBpZiAodHlwZXMuaGFzT3duUHJvcGVydHkodCkpXG4gICAgbW9kdWxlLmV4cG9ydHNbdF0gPSB0eXBlc1t0XTtcbn1cbmZvciAodmFyIGUgaW4gZXJyb3JzKSB7XG4gIGlmIChlcnJvcnMuaGFzT3duUHJvcGVydHkoZSkpXG4gICAgbW9kdWxlLmV4cG9ydHNbZV0gPSBlcnJvcnNbZV07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/asn1/lib/ber/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/asn1/lib/ber/reader.js":
/*!*********************************************!*\
  !*** ./node_modules/asn1/lib/ber/reader.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\nvar assert = __webpack_require__(/*! assert */ \"assert\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/./node_modules/safer-buffer/safer.js\").Buffer);\n\nvar ASN1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/asn1/lib/ber/types.js\");\nvar errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/asn1/lib/ber/errors.js\");\n\n\n// --- Globals\n\nvar newInvalidAsn1Error = errors.newInvalidAsn1Error;\n\n\n\n// --- API\n\nfunction Reader(data) {\n  if (!data || !Buffer.isBuffer(data))\n    throw new TypeError('data must be a node Buffer');\n\n  this._buf = data;\n  this._size = data.length;\n\n  // These hold the \"current\" state\n  this._len = 0;\n  this._offset = 0;\n}\n\nObject.defineProperty(Reader.prototype, 'length', {\n  enumerable: true,\n  get: function () { return (this._len); }\n});\n\nObject.defineProperty(Reader.prototype, 'offset', {\n  enumerable: true,\n  get: function () { return (this._offset); }\n});\n\nObject.defineProperty(Reader.prototype, 'remain', {\n  get: function () { return (this._size - this._offset); }\n});\n\nObject.defineProperty(Reader.prototype, 'buffer', {\n  get: function () { return (this._buf.slice(this._offset)); }\n});\n\n\n/**\n * Reads a single byte and advances offset; you can pass in `true` to make this\n * a \"peek\" operation (i.e., get the byte, but don't advance the offset).\n *\n * @param {Boolean} peek true means don't move offset.\n * @return {Number} the next byte, null if not enough data.\n */\nReader.prototype.readByte = function (peek) {\n  if (this._size - this._offset < 1)\n    return null;\n\n  var b = this._buf[this._offset] & 0xff;\n\n  if (!peek)\n    this._offset += 1;\n\n  return b;\n};\n\n\nReader.prototype.peek = function () {\n  return this.readByte(true);\n};\n\n\n/**\n * Reads a (potentially) variable length off the BER buffer.  This call is\n * not really meant to be called directly, as callers have to manipulate\n * the internal buffer afterwards.\n *\n * As a result of this call, you can call `Reader.length`, until the\n * next thing called that does a readLength.\n *\n * @return {Number} the amount of offset to advance the buffer.\n * @throws {InvalidAsn1Error} on bad ASN.1\n */\nReader.prototype.readLength = function (offset) {\n  if (offset === undefined)\n    offset = this._offset;\n\n  if (offset >= this._size)\n    return null;\n\n  var lenB = this._buf[offset++] & 0xff;\n  if (lenB === null)\n    return null;\n\n  if ((lenB & 0x80) === 0x80) {\n    lenB &= 0x7f;\n\n    if (lenB === 0)\n      throw newInvalidAsn1Error('Indefinite length not supported');\n\n    if (lenB > 4)\n      throw newInvalidAsn1Error('encoding too long');\n\n    if (this._size - offset < lenB)\n      return null;\n\n    this._len = 0;\n    for (var i = 0; i < lenB; i++)\n      this._len = (this._len << 8) + (this._buf[offset++] & 0xff);\n\n  } else {\n    // Wasn't a variable length\n    this._len = lenB;\n  }\n\n  return offset;\n};\n\n\n/**\n * Parses the next sequence in this BER buffer.\n *\n * To get the length of the sequence, call `Reader.length`.\n *\n * @return {Number} the sequence's tag.\n */\nReader.prototype.readSequence = function (tag) {\n  var seq = this.peek();\n  if (seq === null)\n    return null;\n  if (tag !== undefined && tag !== seq)\n    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +\n                              ': got 0x' + seq.toString(16));\n\n  var o = this.readLength(this._offset + 1); // stored in `length`\n  if (o === null)\n    return null;\n\n  this._offset = o;\n  return seq;\n};\n\n\nReader.prototype.readInt = function () {\n  return this._readTag(ASN1.Integer);\n};\n\n\nReader.prototype.readBoolean = function () {\n  return (this._readTag(ASN1.Boolean) === 0 ? false : true);\n};\n\n\nReader.prototype.readEnumeration = function () {\n  return this._readTag(ASN1.Enumeration);\n};\n\n\nReader.prototype.readString = function (tag, retbuf) {\n  if (!tag)\n    tag = ASN1.OctetString;\n\n  var b = this.peek();\n  if (b === null)\n    return null;\n\n  if (b !== tag)\n    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +\n                              ': got 0x' + b.toString(16));\n\n  var o = this.readLength(this._offset + 1); // stored in `length`\n\n  if (o === null)\n    return null;\n\n  if (this.length > this._size - o)\n    return null;\n\n  this._offset = o;\n\n  if (this.length === 0)\n    return retbuf ? Buffer.alloc(0) : '';\n\n  var str = this._buf.slice(this._offset, this._offset + this.length);\n  this._offset += this.length;\n\n  return retbuf ? str : str.toString('utf8');\n};\n\nReader.prototype.readOID = function (tag) {\n  if (!tag)\n    tag = ASN1.OID;\n\n  var b = this.readString(tag, true);\n  if (b === null)\n    return null;\n\n  var values = [];\n  var value = 0;\n\n  for (var i = 0; i < b.length; i++) {\n    var byte = b[i] & 0xff;\n\n    value <<= 7;\n    value += byte & 0x7f;\n    if ((byte & 0x80) === 0) {\n      values.push(value);\n      value = 0;\n    }\n  }\n\n  value = values.shift();\n  values.unshift(value % 40);\n  values.unshift((value / 40) >> 0);\n\n  return values.join('.');\n};\n\n\nReader.prototype._readTag = function (tag) {\n  assert.ok(tag !== undefined);\n\n  var b = this.peek();\n\n  if (b === null)\n    return null;\n\n  if (b !== tag)\n    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +\n                              ': got 0x' + b.toString(16));\n\n  var o = this.readLength(this._offset + 1); // stored in `length`\n  if (o === null)\n    return null;\n\n  if (this.length > 4)\n    throw newInvalidAsn1Error('Integer too long: ' + this.length);\n\n  if (this.length > this._size - o)\n    return null;\n  this._offset = o;\n\n  var fb = this._buf[this._offset];\n  var value = 0;\n\n  for (var i = 0; i < this.length; i++) {\n    value <<= 8;\n    value |= (this._buf[this._offset++] & 0xff);\n  }\n\n  if ((fb & 0x80) === 0x80 && i !== 4)\n    value -= (1 << (i * 8));\n\n  return value >> 0;\n};\n\n\n\n// --- Exported API\n\nmodule.exports = Reader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYXNuMS9saWIvYmVyL3JlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsYUFBYSw4RkFBOEI7O0FBRTNDLFdBQVcsbUJBQU8sQ0FBQywyREFBUztBQUM1QixhQUFhLG1CQUFPLENBQUMsNkRBQVU7OztBQUcvQjs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLENBQUM7O0FBRUQ7QUFDQSxxQkFBcUI7QUFDckIsQ0FBQzs7QUFFRDtBQUNBLHFCQUFxQjtBQUNyQixDQUFDOzs7QUFHRDtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLGNBQWM7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BhZ2UtZm9ybS8uL25vZGVfbW9kdWxlcy9hc24xL2xpYi9iZXIvcmVhZGVyLmpzPzFiMmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTEgTWFyayBDYXZhZ2UgPG1jYXZhZ2VAZ21haWwuY29tPiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZXItYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgQVNOMSA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5cbi8vIC0tLSBHbG9iYWxzXG5cbnZhciBuZXdJbnZhbGlkQXNuMUVycm9yID0gZXJyb3JzLm5ld0ludmFsaWRBc24xRXJyb3I7XG5cblxuXG4vLyAtLS0gQVBJXG5cbmZ1bmN0aW9uIFJlYWRlcihkYXRhKSB7XG4gIGlmICghZGF0YSB8fCAhQnVmZmVyLmlzQnVmZmVyKGRhdGEpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RhdGEgbXVzdCBiZSBhIG5vZGUgQnVmZmVyJyk7XG5cbiAgdGhpcy5fYnVmID0gZGF0YTtcbiAgdGhpcy5fc2l6ZSA9IGRhdGEubGVuZ3RoO1xuXG4gIC8vIFRoZXNlIGhvbGQgdGhlIFwiY3VycmVudFwiIHN0YXRlXG4gIHRoaXMuX2xlbiA9IDA7XG4gIHRoaXMuX29mZnNldCA9IDA7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkZXIucHJvdG90eXBlLCAnbGVuZ3RoJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLl9sZW4pOyB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuX29mZnNldCk7IH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGVyLnByb3RvdHlwZSwgJ3JlbWFpbicsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5fc2l6ZSAtIHRoaXMuX29mZnNldCk7IH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGVyLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5fYnVmLnNsaWNlKHRoaXMuX29mZnNldCkpOyB9XG59KTtcblxuXG4vKipcbiAqIFJlYWRzIGEgc2luZ2xlIGJ5dGUgYW5kIGFkdmFuY2VzIG9mZnNldDsgeW91IGNhbiBwYXNzIGluIGB0cnVlYCB0byBtYWtlIHRoaXNcbiAqIGEgXCJwZWVrXCIgb3BlcmF0aW9uIChpLmUuLCBnZXQgdGhlIGJ5dGUsIGJ1dCBkb24ndCBhZHZhbmNlIHRoZSBvZmZzZXQpLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGVlayB0cnVlIG1lYW5zIGRvbid0IG1vdmUgb2Zmc2V0LlxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgbmV4dCBieXRlLCBudWxsIGlmIG5vdCBlbm91Z2ggZGF0YS5cbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5yZWFkQnl0ZSA9IGZ1bmN0aW9uIChwZWVrKSB7XG4gIGlmICh0aGlzLl9zaXplIC0gdGhpcy5fb2Zmc2V0IDwgMSlcbiAgICByZXR1cm4gbnVsbDtcblxuICB2YXIgYiA9IHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXRdICYgMHhmZjtcblxuICBpZiAoIXBlZWspXG4gICAgdGhpcy5fb2Zmc2V0ICs9IDE7XG5cbiAgcmV0dXJuIGI7XG59O1xuXG5cblJlYWRlci5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVhZEJ5dGUodHJ1ZSk7XG59O1xuXG5cbi8qKlxuICogUmVhZHMgYSAocG90ZW50aWFsbHkpIHZhcmlhYmxlIGxlbmd0aCBvZmYgdGhlIEJFUiBidWZmZXIuICBUaGlzIGNhbGwgaXNcbiAqIG5vdCByZWFsbHkgbWVhbnQgdG8gYmUgY2FsbGVkIGRpcmVjdGx5LCBhcyBjYWxsZXJzIGhhdmUgdG8gbWFuaXB1bGF0ZVxuICogdGhlIGludGVybmFsIGJ1ZmZlciBhZnRlcndhcmRzLlxuICpcbiAqIEFzIGEgcmVzdWx0IG9mIHRoaXMgY2FsbCwgeW91IGNhbiBjYWxsIGBSZWFkZXIubGVuZ3RoYCwgdW50aWwgdGhlXG4gKiBuZXh0IHRoaW5nIGNhbGxlZCB0aGF0IGRvZXMgYSByZWFkTGVuZ3RoLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gdGhlIGFtb3VudCBvZiBvZmZzZXQgdG8gYWR2YW5jZSB0aGUgYnVmZmVyLlxuICogQHRocm93cyB7SW52YWxpZEFzbjFFcnJvcn0gb24gYmFkIEFTTi4xXG4gKi9cblJlYWRlci5wcm90b3R5cGUucmVhZExlbmd0aCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKVxuICAgIG9mZnNldCA9IHRoaXMuX29mZnNldDtcblxuICBpZiAob2Zmc2V0ID49IHRoaXMuX3NpemUpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdmFyIGxlbkIgPSB0aGlzLl9idWZbb2Zmc2V0KytdICYgMHhmZjtcbiAgaWYgKGxlbkIgPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKChsZW5CICYgMHg4MCkgPT09IDB4ODApIHtcbiAgICBsZW5CICY9IDB4N2Y7XG5cbiAgICBpZiAobGVuQiA9PT0gMClcbiAgICAgIHRocm93IG5ld0ludmFsaWRBc24xRXJyb3IoJ0luZGVmaW5pdGUgbGVuZ3RoIG5vdCBzdXBwb3J0ZWQnKTtcblxuICAgIGlmIChsZW5CID4gNClcbiAgICAgIHRocm93IG5ld0ludmFsaWRBc24xRXJyb3IoJ2VuY29kaW5nIHRvbyBsb25nJyk7XG5cbiAgICBpZiAodGhpcy5fc2l6ZSAtIG9mZnNldCA8IGxlbkIpXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIHRoaXMuX2xlbiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5COyBpKyspXG4gICAgICB0aGlzLl9sZW4gPSAodGhpcy5fbGVuIDw8IDgpICsgKHRoaXMuX2J1ZltvZmZzZXQrK10gJiAweGZmKTtcblxuICB9IGVsc2Uge1xuICAgIC8vIFdhc24ndCBhIHZhcmlhYmxlIGxlbmd0aFxuICAgIHRoaXMuX2xlbiA9IGxlbkI7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0O1xufTtcblxuXG4vKipcbiAqIFBhcnNlcyB0aGUgbmV4dCBzZXF1ZW5jZSBpbiB0aGlzIEJFUiBidWZmZXIuXG4gKlxuICogVG8gZ2V0IHRoZSBsZW5ndGggb2YgdGhlIHNlcXVlbmNlLCBjYWxsIGBSZWFkZXIubGVuZ3RoYC5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBzZXF1ZW5jZSdzIHRhZy5cbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5yZWFkU2VxdWVuY2UgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHZhciBzZXEgPSB0aGlzLnBlZWsoKTtcbiAgaWYgKHNlcSA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKHRhZyAhPT0gdW5kZWZpbmVkICYmIHRhZyAhPT0gc2VxKVxuICAgIHRocm93IG5ld0ludmFsaWRBc24xRXJyb3IoJ0V4cGVjdGVkIDB4JyArIHRhZy50b1N0cmluZygxNikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzogZ290IDB4JyArIHNlcS50b1N0cmluZygxNikpO1xuXG4gIHZhciBvID0gdGhpcy5yZWFkTGVuZ3RoKHRoaXMuX29mZnNldCArIDEpOyAvLyBzdG9yZWQgaW4gYGxlbmd0aGBcbiAgaWYgKG8gPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdGhpcy5fb2Zmc2V0ID0gbztcbiAgcmV0dXJuIHNlcTtcbn07XG5cblxuUmVhZGVyLnByb3RvdHlwZS5yZWFkSW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZFRhZyhBU04xLkludGVnZXIpO1xufTtcblxuXG5SZWFkZXIucHJvdG90eXBlLnJlYWRCb29sZWFuID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMuX3JlYWRUYWcoQVNOMS5Cb29sZWFuKSA9PT0gMCA/IGZhbHNlIDogdHJ1ZSk7XG59O1xuXG5cblJlYWRlci5wcm90b3R5cGUucmVhZEVudW1lcmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZFRhZyhBU04xLkVudW1lcmF0aW9uKTtcbn07XG5cblxuUmVhZGVyLnByb3RvdHlwZS5yZWFkU3RyaW5nID0gZnVuY3Rpb24gKHRhZywgcmV0YnVmKSB7XG4gIGlmICghdGFnKVxuICAgIHRhZyA9IEFTTjEuT2N0ZXRTdHJpbmc7XG5cbiAgdmFyIGIgPSB0aGlzLnBlZWsoKTtcbiAgaWYgKGIgPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKGIgIT09IHRhZylcbiAgICB0aHJvdyBuZXdJbnZhbGlkQXNuMUVycm9yKCdFeHBlY3RlZCAweCcgKyB0YWcudG9TdHJpbmcoMTYpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc6IGdvdCAweCcgKyBiLnRvU3RyaW5nKDE2KSk7XG5cbiAgdmFyIG8gPSB0aGlzLnJlYWRMZW5ndGgodGhpcy5fb2Zmc2V0ICsgMSk7IC8vIHN0b3JlZCBpbiBgbGVuZ3RoYFxuXG4gIGlmIChvID09PSBudWxsKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmICh0aGlzLmxlbmd0aCA+IHRoaXMuX3NpemUgLSBvKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHRoaXMuX29mZnNldCA9IG87XG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiByZXRidWYgPyBCdWZmZXIuYWxsb2MoMCkgOiAnJztcblxuICB2YXIgc3RyID0gdGhpcy5fYnVmLnNsaWNlKHRoaXMuX29mZnNldCwgdGhpcy5fb2Zmc2V0ICsgdGhpcy5sZW5ndGgpO1xuICB0aGlzLl9vZmZzZXQgKz0gdGhpcy5sZW5ndGg7XG5cbiAgcmV0dXJuIHJldGJ1ZiA/IHN0ciA6IHN0ci50b1N0cmluZygndXRmOCcpO1xufTtcblxuUmVhZGVyLnByb3RvdHlwZS5yZWFkT0lEID0gZnVuY3Rpb24gKHRhZykge1xuICBpZiAoIXRhZylcbiAgICB0YWcgPSBBU04xLk9JRDtcblxuICB2YXIgYiA9IHRoaXMucmVhZFN0cmluZyh0YWcsIHRydWUpO1xuICBpZiAoYiA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcblxuICB2YXIgdmFsdWVzID0gW107XG4gIHZhciB2YWx1ZSA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ5dGUgPSBiW2ldICYgMHhmZjtcblxuICAgIHZhbHVlIDw8PSA3O1xuICAgIHZhbHVlICs9IGJ5dGUgJiAweDdmO1xuICAgIGlmICgoYnl0ZSAmIDB4ODApID09PSAwKSB7XG4gICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICB2YWx1ZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgdmFsdWUgPSB2YWx1ZXMuc2hpZnQoKTtcbiAgdmFsdWVzLnVuc2hpZnQodmFsdWUgJSA0MCk7XG4gIHZhbHVlcy51bnNoaWZ0KCh2YWx1ZSAvIDQwKSA+PiAwKTtcblxuICByZXR1cm4gdmFsdWVzLmpvaW4oJy4nKTtcbn07XG5cblxuUmVhZGVyLnByb3RvdHlwZS5fcmVhZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgYXNzZXJ0Lm9rKHRhZyAhPT0gdW5kZWZpbmVkKTtcblxuICB2YXIgYiA9IHRoaXMucGVlaygpO1xuXG4gIGlmIChiID09PSBudWxsKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmIChiICE9PSB0YWcpXG4gICAgdGhyb3cgbmV3SW52YWxpZEFzbjFFcnJvcignRXhwZWN0ZWQgMHgnICsgdGFnLnRvU3RyaW5nKDE2KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnOiBnb3QgMHgnICsgYi50b1N0cmluZygxNikpO1xuXG4gIHZhciBvID0gdGhpcy5yZWFkTGVuZ3RoKHRoaXMuX29mZnNldCArIDEpOyAvLyBzdG9yZWQgaW4gYGxlbmd0aGBcbiAgaWYgKG8gPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKHRoaXMubGVuZ3RoID4gNClcbiAgICB0aHJvdyBuZXdJbnZhbGlkQXNuMUVycm9yKCdJbnRlZ2VyIHRvbyBsb25nOiAnICsgdGhpcy5sZW5ndGgpO1xuXG4gIGlmICh0aGlzLmxlbmd0aCA+IHRoaXMuX3NpemUgLSBvKVxuICAgIHJldHVybiBudWxsO1xuICB0aGlzLl9vZmZzZXQgPSBvO1xuXG4gIHZhciBmYiA9IHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXRdO1xuICB2YXIgdmFsdWUgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhbHVlIDw8PSA4O1xuICAgIHZhbHVlIHw9ICh0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdICYgMHhmZik7XG4gIH1cblxuICBpZiAoKGZiICYgMHg4MCkgPT09IDB4ODAgJiYgaSAhPT0gNClcbiAgICB2YWx1ZSAtPSAoMSA8PCAoaSAqIDgpKTtcblxuICByZXR1cm4gdmFsdWUgPj4gMDtcbn07XG5cblxuXG4vLyAtLS0gRXhwb3J0ZWQgQVBJXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/asn1/lib/ber/reader.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/asn1/lib/ber/types.js":
/*!********************************************!*\
  !*** ./node_modules/asn1/lib/ber/types.js ***!
  \********************************************/
/***/ ((module) => {

eval("// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\n\nmodule.exports = {\n  EOC: 0,\n  Boolean: 1,\n  Integer: 2,\n  BitString: 3,\n  OctetString: 4,\n  Null: 5,\n  OID: 6,\n  ObjectDescriptor: 7,\n  External: 8,\n  Real: 9, // float\n  Enumeration: 10,\n  PDV: 11,\n  Utf8String: 12,\n  RelativeOID: 13,\n  Sequence: 16,\n  Set: 17,\n  NumericString: 18,\n  PrintableString: 19,\n  T61String: 20,\n  VideotexString: 21,\n  IA5String: 22,\n  UTCTime: 23,\n  GeneralizedTime: 24,\n  GraphicString: 25,\n  VisibleString: 26,\n  GeneralString: 28,\n  UniversalString: 29,\n  CharacterString: 30,\n  BMPString: 31,\n  Constructor: 32,\n  Context: 128\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYXNuMS9saWIvYmVyL3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYWdlLWZvcm0vLi9ub2RlX21vZHVsZXMvYXNuMS9saWIvYmVyL3R5cGVzLmpzP2QyOWQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTEgTWFyayBDYXZhZ2UgPG1jYXZhZ2VAZ21haWwuY29tPiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBFT0M6IDAsXG4gIEJvb2xlYW46IDEsXG4gIEludGVnZXI6IDIsXG4gIEJpdFN0cmluZzogMyxcbiAgT2N0ZXRTdHJpbmc6IDQsXG4gIE51bGw6IDUsXG4gIE9JRDogNixcbiAgT2JqZWN0RGVzY3JpcHRvcjogNyxcbiAgRXh0ZXJuYWw6IDgsXG4gIFJlYWw6IDksIC8vIGZsb2F0XG4gIEVudW1lcmF0aW9uOiAxMCxcbiAgUERWOiAxMSxcbiAgVXRmOFN0cmluZzogMTIsXG4gIFJlbGF0aXZlT0lEOiAxMyxcbiAgU2VxdWVuY2U6IDE2LFxuICBTZXQ6IDE3LFxuICBOdW1lcmljU3RyaW5nOiAxOCxcbiAgUHJpbnRhYmxlU3RyaW5nOiAxOSxcbiAgVDYxU3RyaW5nOiAyMCxcbiAgVmlkZW90ZXhTdHJpbmc6IDIxLFxuICBJQTVTdHJpbmc6IDIyLFxuICBVVENUaW1lOiAyMyxcbiAgR2VuZXJhbGl6ZWRUaW1lOiAyNCxcbiAgR3JhcGhpY1N0cmluZzogMjUsXG4gIFZpc2libGVTdHJpbmc6IDI2LFxuICBHZW5lcmFsU3RyaW5nOiAyOCxcbiAgVW5pdmVyc2FsU3RyaW5nOiAyOSxcbiAgQ2hhcmFjdGVyU3RyaW5nOiAzMCxcbiAgQk1QU3RyaW5nOiAzMSxcbiAgQ29uc3RydWN0b3I6IDMyLFxuICBDb250ZXh0OiAxMjhcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/asn1/lib/ber/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/asn1/lib/ber/writer.js":
/*!*********************************************!*\
  !*** ./node_modules/asn1/lib/ber/writer.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\nvar assert = __webpack_require__(/*! assert */ \"assert\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar ASN1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/asn1/lib/ber/types.js\");\nvar errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/asn1/lib/ber/errors.js\");\n\n\n// --- Globals\n\nvar newInvalidAsn1Error = errors.newInvalidAsn1Error;\n\nvar DEFAULT_OPTS = {\n  size: 1024,\n  growthFactor: 8\n};\n\n\n// --- Helpers\n\nfunction merge(from, to) {\n  assert.ok(from);\n  assert.equal(typeof (from), 'object');\n  assert.ok(to);\n  assert.equal(typeof (to), 'object');\n\n  var keys = Object.getOwnPropertyNames(from);\n  keys.forEach(function (key) {\n    if (to[key])\n      return;\n\n    var value = Object.getOwnPropertyDescriptor(from, key);\n    Object.defineProperty(to, key, value);\n  });\n\n  return to;\n}\n\n\n\n// --- API\n\nfunction Writer(options) {\n  options = merge(DEFAULT_OPTS, options || {});\n\n  this._buf = Buffer.alloc(options.size || 1024);\n  this._size = this._buf.length;\n  this._offset = 0;\n  this._options = options;\n\n  // A list of offsets in the buffer where we need to insert\n  // sequence tag/len pairs.\n  this._seq = [];\n}\n\nObject.defineProperty(Writer.prototype, 'buffer', {\n  get: function () {\n    if (this._seq.length)\n      throw newInvalidAsn1Error(this._seq.length + ' unended sequence(s)');\n\n    return (this._buf.slice(0, this._offset));\n  }\n});\n\nWriter.prototype.writeByte = function (b) {\n  if (typeof (b) !== 'number')\n    throw new TypeError('argument must be a Number');\n\n  this._ensure(1);\n  this._buf[this._offset++] = b;\n};\n\n\nWriter.prototype.writeInt = function (i, tag) {\n  if (typeof (i) !== 'number')\n    throw new TypeError('argument must be a Number');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.Integer;\n\n  var sz = 4;\n\n  while ((((i & 0xff800000) === 0) || ((i & 0xff800000) === 0xff800000 >> 0)) &&\n        (sz > 1)) {\n    sz--;\n    i <<= 8;\n  }\n\n  if (sz > 4)\n    throw newInvalidAsn1Error('BER ints cannot be > 0xffffffff');\n\n  this._ensure(2 + sz);\n  this._buf[this._offset++] = tag;\n  this._buf[this._offset++] = sz;\n\n  while (sz-- > 0) {\n    this._buf[this._offset++] = ((i & 0xff000000) >>> 24);\n    i <<= 8;\n  }\n\n};\n\n\nWriter.prototype.writeNull = function () {\n  this.writeByte(ASN1.Null);\n  this.writeByte(0x00);\n};\n\n\nWriter.prototype.writeEnumeration = function (i, tag) {\n  if (typeof (i) !== 'number')\n    throw new TypeError('argument must be a Number');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.Enumeration;\n\n  return this.writeInt(i, tag);\n};\n\n\nWriter.prototype.writeBoolean = function (b, tag) {\n  if (typeof (b) !== 'boolean')\n    throw new TypeError('argument must be a Boolean');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.Boolean;\n\n  this._ensure(3);\n  this._buf[this._offset++] = tag;\n  this._buf[this._offset++] = 0x01;\n  this._buf[this._offset++] = b ? 0xff : 0x00;\n};\n\n\nWriter.prototype.writeString = function (s, tag) {\n  if (typeof (s) !== 'string')\n    throw new TypeError('argument must be a string (was: ' + typeof (s) + ')');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.OctetString;\n\n  var len = Buffer.byteLength(s);\n  this.writeByte(tag);\n  this.writeLength(len);\n  if (len) {\n    this._ensure(len);\n    this._buf.write(s, this._offset);\n    this._offset += len;\n  }\n};\n\n\nWriter.prototype.writeBuffer = function (buf, tag) {\n  if (typeof (tag) !== 'number')\n    throw new TypeError('tag must be a number');\n  if (!Buffer.isBuffer(buf))\n    throw new TypeError('argument must be a buffer');\n\n  this.writeByte(tag);\n  this.writeLength(buf.length);\n  this._ensure(buf.length);\n  buf.copy(this._buf, this._offset, 0, buf.length);\n  this._offset += buf.length;\n};\n\n\nWriter.prototype.writeStringArray = function (strings) {\n  if ((!strings instanceof Array))\n    throw new TypeError('argument must be an Array[String]');\n\n  var self = this;\n  strings.forEach(function (s) {\n    self.writeString(s);\n  });\n};\n\n// This is really to solve DER cases, but whatever for now\nWriter.prototype.writeOID = function (s, tag) {\n  if (typeof (s) !== 'string')\n    throw new TypeError('argument must be a string');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.OID;\n\n  if (!/^([0-9]+\\.){3,}[0-9]+$/.test(s))\n    throw new Error('argument is not a valid OID string');\n\n  function encodeOctet(bytes, octet) {\n    if (octet < 128) {\n        bytes.push(octet);\n    } else if (octet < 16384) {\n        bytes.push((octet >>> 7) | 0x80);\n        bytes.push(octet & 0x7F);\n    } else if (octet < 2097152) {\n      bytes.push((octet >>> 14) | 0x80);\n      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    } else if (octet < 268435456) {\n      bytes.push((octet >>> 21) | 0x80);\n      bytes.push(((octet >>> 14) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    } else {\n      bytes.push(((octet >>> 28) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 21) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 14) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    }\n  }\n\n  var tmp = s.split('.');\n  var bytes = [];\n  bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));\n  tmp.slice(2).forEach(function (b) {\n    encodeOctet(bytes, parseInt(b, 10));\n  });\n\n  var self = this;\n  this._ensure(2 + bytes.length);\n  this.writeByte(tag);\n  this.writeLength(bytes.length);\n  bytes.forEach(function (b) {\n    self.writeByte(b);\n  });\n};\n\n\nWriter.prototype.writeLength = function (len) {\n  if (typeof (len) !== 'number')\n    throw new TypeError('argument must be a Number');\n\n  this._ensure(4);\n\n  if (len <= 0x7f) {\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xff) {\n    this._buf[this._offset++] = 0x81;\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xffff) {\n    this._buf[this._offset++] = 0x82;\n    this._buf[this._offset++] = len >> 8;\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xffffff) {\n    this._buf[this._offset++] = 0x83;\n    this._buf[this._offset++] = len >> 16;\n    this._buf[this._offset++] = len >> 8;\n    this._buf[this._offset++] = len;\n  } else {\n    throw newInvalidAsn1Error('Length too long (> 4 bytes)');\n  }\n};\n\nWriter.prototype.startSequence = function (tag) {\n  if (typeof (tag) !== 'number')\n    tag = ASN1.Sequence | ASN1.Constructor;\n\n  this.writeByte(tag);\n  this._seq.push(this._offset);\n  this._ensure(3);\n  this._offset += 3;\n};\n\n\nWriter.prototype.endSequence = function () {\n  var seq = this._seq.pop();\n  var start = seq + 3;\n  var len = this._offset - start;\n\n  if (len <= 0x7f) {\n    this._shift(start, len, -2);\n    this._buf[seq] = len;\n  } else if (len <= 0xff) {\n    this._shift(start, len, -1);\n    this._buf[seq] = 0x81;\n    this._buf[seq + 1] = len;\n  } else if (len <= 0xffff) {\n    this._buf[seq] = 0x82;\n    this._buf[seq + 1] = len >> 8;\n    this._buf[seq + 2] = len;\n  } else if (len <= 0xffffff) {\n    this._shift(start, len, 1);\n    this._buf[seq] = 0x83;\n    this._buf[seq + 1] = len >> 16;\n    this._buf[seq + 2] = len >> 8;\n    this._buf[seq + 3] = len;\n  } else {\n    throw newInvalidAsn1Error('Sequence too long');\n  }\n};\n\n\nWriter.prototype._shift = function (start, len, shift) {\n  assert.ok(start !== undefined);\n  assert.ok(len !== undefined);\n  assert.ok(shift);\n\n  this._buf.copy(this._buf, start + shift, start, start + len);\n  this._offset += shift;\n};\n\nWriter.prototype._ensure = function (len) {\n  assert.ok(len);\n\n  if (this._size - this._offset < len) {\n    var sz = this._size * this._options.growthFactor;\n    if (sz - this._offset < len)\n      sz += len;\n\n    var buf = Buffer.alloc(sz);\n\n    this._buf.copy(buf, 0, 0, this._offset);\n    this._buf = buf;\n    this._size = sz;\n  }\n};\n\n\n\n// --- Exported API\n\nmodule.exports = Writer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYXNuMS9saWIvYmVyL3dyaXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsYUFBYSw4RkFBOEI7QUFDM0MsV0FBVyxtQkFBTyxDQUFDLDJEQUFTO0FBQzVCLGFBQWEsbUJBQU8sQ0FBQyw2REFBVTs7O0FBRy9COztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7Ozs7QUFJQTs7QUFFQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLEdBQUc7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGFnZS1mb3JtLy4vbm9kZV9tb2R1bGVzL2FzbjEvbGliL2Jlci93cml0ZXIuanM/MGZjNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxMSBNYXJrIENhdmFnZSA8bWNhdmFnZUBnbWFpbC5jb20+IEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG52YXIgQVNOMSA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5cbi8vIC0tLSBHbG9iYWxzXG5cbnZhciBuZXdJbnZhbGlkQXNuMUVycm9yID0gZXJyb3JzLm5ld0ludmFsaWRBc24xRXJyb3I7XG5cbnZhciBERUZBVUxUX09QVFMgPSB7XG4gIHNpemU6IDEwMjQsXG4gIGdyb3d0aEZhY3RvcjogOFxufTtcblxuXG4vLyAtLS0gSGVscGVyc1xuXG5mdW5jdGlvbiBtZXJnZShmcm9tLCB0bykge1xuICBhc3NlcnQub2soZnJvbSk7XG4gIGFzc2VydC5lcXVhbCh0eXBlb2YgKGZyb20pLCAnb2JqZWN0Jyk7XG4gIGFzc2VydC5vayh0byk7XG4gIGFzc2VydC5lcXVhbCh0eXBlb2YgKHRvKSwgJ29iamVjdCcpO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZnJvbSk7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKHRvW2tleV0pXG4gICAgICByZXR1cm47XG5cbiAgICB2YXIgdmFsdWUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGZyb20sIGtleSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCBrZXksIHZhbHVlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRvO1xufVxuXG5cblxuLy8gLS0tIEFQSVxuXG5mdW5jdGlvbiBXcml0ZXIob3B0aW9ucykge1xuICBvcHRpb25zID0gbWVyZ2UoREVGQVVMVF9PUFRTLCBvcHRpb25zIHx8IHt9KTtcblxuICB0aGlzLl9idWYgPSBCdWZmZXIuYWxsb2Mob3B0aW9ucy5zaXplIHx8IDEwMjQpO1xuICB0aGlzLl9zaXplID0gdGhpcy5fYnVmLmxlbmd0aDtcbiAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgLy8gQSBsaXN0IG9mIG9mZnNldHMgaW4gdGhlIGJ1ZmZlciB3aGVyZSB3ZSBuZWVkIHRvIGluc2VydFxuICAvLyBzZXF1ZW5jZSB0YWcvbGVuIHBhaXJzLlxuICB0aGlzLl9zZXEgPSBbXTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRlci5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9zZXEubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3SW52YWxpZEFzbjFFcnJvcih0aGlzLl9zZXEubGVuZ3RoICsgJyB1bmVuZGVkIHNlcXVlbmNlKHMpJyk7XG5cbiAgICByZXR1cm4gKHRoaXMuX2J1Zi5zbGljZSgwLCB0aGlzLl9vZmZzZXQpKTtcbiAgfVxufSk7XG5cbldyaXRlci5wcm90b3R5cGUud3JpdGVCeXRlID0gZnVuY3Rpb24gKGIpIHtcbiAgaWYgKHR5cGVvZiAoYikgIT09ICdudW1iZXInKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IG11c3QgYmUgYSBOdW1iZXInKTtcblxuICB0aGlzLl9lbnN1cmUoMSk7XG4gIHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK10gPSBiO1xufTtcblxuXG5Xcml0ZXIucHJvdG90eXBlLndyaXRlSW50ID0gZnVuY3Rpb24gKGksIHRhZykge1xuICBpZiAodHlwZW9mIChpKSAhPT0gJ251bWJlcicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgbXVzdCBiZSBhIE51bWJlcicpO1xuICBpZiAodHlwZW9mICh0YWcpICE9PSAnbnVtYmVyJylcbiAgICB0YWcgPSBBU04xLkludGVnZXI7XG5cbiAgdmFyIHN6ID0gNDtcblxuICB3aGlsZSAoKCgoaSAmIDB4ZmY4MDAwMDApID09PSAwKSB8fCAoKGkgJiAweGZmODAwMDAwKSA9PT0gMHhmZjgwMDAwMCA+PiAwKSkgJiZcbiAgICAgICAgKHN6ID4gMSkpIHtcbiAgICBzei0tO1xuICAgIGkgPDw9IDg7XG4gIH1cblxuICBpZiAoc3ogPiA0KVxuICAgIHRocm93IG5ld0ludmFsaWRBc24xRXJyb3IoJ0JFUiBpbnRzIGNhbm5vdCBiZSA+IDB4ZmZmZmZmZmYnKTtcblxuICB0aGlzLl9lbnN1cmUoMiArIHN6KTtcbiAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IHRhZztcbiAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IHN6O1xuXG4gIHdoaWxlIChzei0tID4gMCkge1xuICAgIHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK10gPSAoKGkgJiAweGZmMDAwMDAwKSA+Pj4gMjQpO1xuICAgIGkgPDw9IDg7XG4gIH1cblxufTtcblxuXG5Xcml0ZXIucHJvdG90eXBlLndyaXRlTnVsbCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy53cml0ZUJ5dGUoQVNOMS5OdWxsKTtcbiAgdGhpcy53cml0ZUJ5dGUoMHgwMCk7XG59O1xuXG5cbldyaXRlci5wcm90b3R5cGUud3JpdGVFbnVtZXJhdGlvbiA9IGZ1bmN0aW9uIChpLCB0YWcpIHtcbiAgaWYgKHR5cGVvZiAoaSkgIT09ICdudW1iZXInKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IG11c3QgYmUgYSBOdW1iZXInKTtcbiAgaWYgKHR5cGVvZiAodGFnKSAhPT0gJ251bWJlcicpXG4gICAgdGFnID0gQVNOMS5FbnVtZXJhdGlvbjtcblxuICByZXR1cm4gdGhpcy53cml0ZUludChpLCB0YWcpO1xufTtcblxuXG5Xcml0ZXIucHJvdG90eXBlLndyaXRlQm9vbGVhbiA9IGZ1bmN0aW9uIChiLCB0YWcpIHtcbiAgaWYgKHR5cGVvZiAoYikgIT09ICdib29sZWFuJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBtdXN0IGJlIGEgQm9vbGVhbicpO1xuICBpZiAodHlwZW9mICh0YWcpICE9PSAnbnVtYmVyJylcbiAgICB0YWcgPSBBU04xLkJvb2xlYW47XG5cbiAgdGhpcy5fZW5zdXJlKDMpO1xuICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gdGFnO1xuICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gMHgwMTtcbiAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IGIgPyAweGZmIDogMHgwMDtcbn07XG5cblxuV3JpdGVyLnByb3RvdHlwZS53cml0ZVN0cmluZyA9IGZ1bmN0aW9uIChzLCB0YWcpIHtcbiAgaWYgKHR5cGVvZiAocykgIT09ICdzdHJpbmcnKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcgKHdhczogJyArIHR5cGVvZiAocykgKyAnKScpO1xuICBpZiAodHlwZW9mICh0YWcpICE9PSAnbnVtYmVyJylcbiAgICB0YWcgPSBBU04xLk9jdGV0U3RyaW5nO1xuXG4gIHZhciBsZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChzKTtcbiAgdGhpcy53cml0ZUJ5dGUodGFnKTtcbiAgdGhpcy53cml0ZUxlbmd0aChsZW4pO1xuICBpZiAobGVuKSB7XG4gICAgdGhpcy5fZW5zdXJlKGxlbik7XG4gICAgdGhpcy5fYnVmLndyaXRlKHMsIHRoaXMuX29mZnNldCk7XG4gICAgdGhpcy5fb2Zmc2V0ICs9IGxlbjtcbiAgfVxufTtcblxuXG5Xcml0ZXIucHJvdG90eXBlLndyaXRlQnVmZmVyID0gZnVuY3Rpb24gKGJ1ZiwgdGFnKSB7XG4gIGlmICh0eXBlb2YgKHRhZykgIT09ICdudW1iZXInKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhZyBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgbXVzdCBiZSBhIGJ1ZmZlcicpO1xuXG4gIHRoaXMud3JpdGVCeXRlKHRhZyk7XG4gIHRoaXMud3JpdGVMZW5ndGgoYnVmLmxlbmd0aCk7XG4gIHRoaXMuX2Vuc3VyZShidWYubGVuZ3RoKTtcbiAgYnVmLmNvcHkodGhpcy5fYnVmLCB0aGlzLl9vZmZzZXQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLl9vZmZzZXQgKz0gYnVmLmxlbmd0aDtcbn07XG5cblxuV3JpdGVyLnByb3RvdHlwZS53cml0ZVN0cmluZ0FycmF5ID0gZnVuY3Rpb24gKHN0cmluZ3MpIHtcbiAgaWYgKCghc3RyaW5ncyBpbnN0YW5jZW9mIEFycmF5KSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5W1N0cmluZ10nKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHN0cmluZ3MuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgIHNlbGYud3JpdGVTdHJpbmcocyk7XG4gIH0pO1xufTtcblxuLy8gVGhpcyBpcyByZWFsbHkgdG8gc29sdmUgREVSIGNhc2VzLCBidXQgd2hhdGV2ZXIgZm9yIG5vd1xuV3JpdGVyLnByb3RvdHlwZS53cml0ZU9JRCA9IGZ1bmN0aW9uIChzLCB0YWcpIHtcbiAgaWYgKHR5cGVvZiAocykgIT09ICdzdHJpbmcnKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgaWYgKHR5cGVvZiAodGFnKSAhPT0gJ251bWJlcicpXG4gICAgdGFnID0gQVNOMS5PSUQ7XG5cbiAgaWYgKCEvXihbMC05XStcXC4pezMsfVswLTldKyQvLnRlc3QocykpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdhcmd1bWVudCBpcyBub3QgYSB2YWxpZCBPSUQgc3RyaW5nJyk7XG5cbiAgZnVuY3Rpb24gZW5jb2RlT2N0ZXQoYnl0ZXMsIG9jdGV0KSB7XG4gICAgaWYgKG9jdGV0IDwgMTI4KSB7XG4gICAgICAgIGJ5dGVzLnB1c2gob2N0ZXQpO1xuICAgIH0gZWxzZSBpZiAob2N0ZXQgPCAxNjM4NCkge1xuICAgICAgICBieXRlcy5wdXNoKChvY3RldCA+Pj4gNykgfCAweDgwKTtcbiAgICAgICAgYnl0ZXMucHVzaChvY3RldCAmIDB4N0YpO1xuICAgIH0gZWxzZSBpZiAob2N0ZXQgPCAyMDk3MTUyKSB7XG4gICAgICBieXRlcy5wdXNoKChvY3RldCA+Pj4gMTQpIHwgMHg4MCk7XG4gICAgICBieXRlcy5wdXNoKCgob2N0ZXQgPj4+IDcpIHwgMHg4MCkgJiAweEZGKTtcbiAgICAgIGJ5dGVzLnB1c2gob2N0ZXQgJiAweDdGKTtcbiAgICB9IGVsc2UgaWYgKG9jdGV0IDwgMjY4NDM1NDU2KSB7XG4gICAgICBieXRlcy5wdXNoKChvY3RldCA+Pj4gMjEpIHwgMHg4MCk7XG4gICAgICBieXRlcy5wdXNoKCgob2N0ZXQgPj4+IDE0KSB8IDB4ODApICYgMHhGRik7XG4gICAgICBieXRlcy5wdXNoKCgob2N0ZXQgPj4+IDcpIHwgMHg4MCkgJiAweEZGKTtcbiAgICAgIGJ5dGVzLnB1c2gob2N0ZXQgJiAweDdGKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnl0ZXMucHVzaCgoKG9jdGV0ID4+PiAyOCkgfCAweDgwKSAmIDB4RkYpO1xuICAgICAgYnl0ZXMucHVzaCgoKG9jdGV0ID4+PiAyMSkgfCAweDgwKSAmIDB4RkYpO1xuICAgICAgYnl0ZXMucHVzaCgoKG9jdGV0ID4+PiAxNCkgfCAweDgwKSAmIDB4RkYpO1xuICAgICAgYnl0ZXMucHVzaCgoKG9jdGV0ID4+PiA3KSB8IDB4ODApICYgMHhGRik7XG4gICAgICBieXRlcy5wdXNoKG9jdGV0ICYgMHg3Rik7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRtcCA9IHMuc3BsaXQoJy4nKTtcbiAgdmFyIGJ5dGVzID0gW107XG4gIGJ5dGVzLnB1c2gocGFyc2VJbnQodG1wWzBdLCAxMCkgKiA0MCArIHBhcnNlSW50KHRtcFsxXSwgMTApKTtcbiAgdG1wLnNsaWNlKDIpLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICBlbmNvZGVPY3RldChieXRlcywgcGFyc2VJbnQoYiwgMTApKTtcbiAgfSk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9lbnN1cmUoMiArIGJ5dGVzLmxlbmd0aCk7XG4gIHRoaXMud3JpdGVCeXRlKHRhZyk7XG4gIHRoaXMud3JpdGVMZW5ndGgoYnl0ZXMubGVuZ3RoKTtcbiAgYnl0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgIHNlbGYud3JpdGVCeXRlKGIpO1xuICB9KTtcbn07XG5cblxuV3JpdGVyLnByb3RvdHlwZS53cml0ZUxlbmd0aCA9IGZ1bmN0aW9uIChsZW4pIHtcbiAgaWYgKHR5cGVvZiAobGVuKSAhPT0gJ251bWJlcicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgbXVzdCBiZSBhIE51bWJlcicpO1xuXG4gIHRoaXMuX2Vuc3VyZSg0KTtcblxuICBpZiAobGVuIDw9IDB4N2YpIHtcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gbGVuO1xuICB9IGVsc2UgaWYgKGxlbiA8PSAweGZmKSB7XG4gICAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IDB4ODE7XG4gICAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IGxlbjtcbiAgfSBlbHNlIGlmIChsZW4gPD0gMHhmZmZmKSB7XG4gICAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IDB4ODI7XG4gICAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IGxlbiA+PiA4O1xuICAgIHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK10gPSBsZW47XG4gIH0gZWxzZSBpZiAobGVuIDw9IDB4ZmZmZmZmKSB7XG4gICAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IDB4ODM7XG4gICAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IGxlbiA+PiAxNjtcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gbGVuID4+IDg7XG4gICAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IGxlbjtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXdJbnZhbGlkQXNuMUVycm9yKCdMZW5ndGggdG9vIGxvbmcgKD4gNCBieXRlcyknKTtcbiAgfVxufTtcblxuV3JpdGVyLnByb3RvdHlwZS5zdGFydFNlcXVlbmNlID0gZnVuY3Rpb24gKHRhZykge1xuICBpZiAodHlwZW9mICh0YWcpICE9PSAnbnVtYmVyJylcbiAgICB0YWcgPSBBU04xLlNlcXVlbmNlIHwgQVNOMS5Db25zdHJ1Y3RvcjtcblxuICB0aGlzLndyaXRlQnl0ZSh0YWcpO1xuICB0aGlzLl9zZXEucHVzaCh0aGlzLl9vZmZzZXQpO1xuICB0aGlzLl9lbnN1cmUoMyk7XG4gIHRoaXMuX29mZnNldCArPSAzO1xufTtcblxuXG5Xcml0ZXIucHJvdG90eXBlLmVuZFNlcXVlbmNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VxID0gdGhpcy5fc2VxLnBvcCgpO1xuICB2YXIgc3RhcnQgPSBzZXEgKyAzO1xuICB2YXIgbGVuID0gdGhpcy5fb2Zmc2V0IC0gc3RhcnQ7XG5cbiAgaWYgKGxlbiA8PSAweDdmKSB7XG4gICAgdGhpcy5fc2hpZnQoc3RhcnQsIGxlbiwgLTIpO1xuICAgIHRoaXMuX2J1ZltzZXFdID0gbGVuO1xuICB9IGVsc2UgaWYgKGxlbiA8PSAweGZmKSB7XG4gICAgdGhpcy5fc2hpZnQoc3RhcnQsIGxlbiwgLTEpO1xuICAgIHRoaXMuX2J1ZltzZXFdID0gMHg4MTtcbiAgICB0aGlzLl9idWZbc2VxICsgMV0gPSBsZW47XG4gIH0gZWxzZSBpZiAobGVuIDw9IDB4ZmZmZikge1xuICAgIHRoaXMuX2J1ZltzZXFdID0gMHg4MjtcbiAgICB0aGlzLl9idWZbc2VxICsgMV0gPSBsZW4gPj4gODtcbiAgICB0aGlzLl9idWZbc2VxICsgMl0gPSBsZW47XG4gIH0gZWxzZSBpZiAobGVuIDw9IDB4ZmZmZmZmKSB7XG4gICAgdGhpcy5fc2hpZnQoc3RhcnQsIGxlbiwgMSk7XG4gICAgdGhpcy5fYnVmW3NlcV0gPSAweDgzO1xuICAgIHRoaXMuX2J1ZltzZXEgKyAxXSA9IGxlbiA+PiAxNjtcbiAgICB0aGlzLl9idWZbc2VxICsgMl0gPSBsZW4gPj4gODtcbiAgICB0aGlzLl9idWZbc2VxICsgM10gPSBsZW47XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3SW52YWxpZEFzbjFFcnJvcignU2VxdWVuY2UgdG9vIGxvbmcnKTtcbiAgfVxufTtcblxuXG5Xcml0ZXIucHJvdG90eXBlLl9zaGlmdCA9IGZ1bmN0aW9uIChzdGFydCwgbGVuLCBzaGlmdCkge1xuICBhc3NlcnQub2soc3RhcnQgIT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydC5vayhsZW4gIT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydC5vayhzaGlmdCk7XG5cbiAgdGhpcy5fYnVmLmNvcHkodGhpcy5fYnVmLCBzdGFydCArIHNoaWZ0LCBzdGFydCwgc3RhcnQgKyBsZW4pO1xuICB0aGlzLl9vZmZzZXQgKz0gc2hpZnQ7XG59O1xuXG5Xcml0ZXIucHJvdG90eXBlLl9lbnN1cmUgPSBmdW5jdGlvbiAobGVuKSB7XG4gIGFzc2VydC5vayhsZW4pO1xuXG4gIGlmICh0aGlzLl9zaXplIC0gdGhpcy5fb2Zmc2V0IDwgbGVuKSB7XG4gICAgdmFyIHN6ID0gdGhpcy5fc2l6ZSAqIHRoaXMuX29wdGlvbnMuZ3Jvd3RoRmFjdG9yO1xuICAgIGlmIChzeiAtIHRoaXMuX29mZnNldCA8IGxlbilcbiAgICAgIHN6ICs9IGxlbjtcblxuICAgIHZhciBidWYgPSBCdWZmZXIuYWxsb2Moc3opO1xuXG4gICAgdGhpcy5fYnVmLmNvcHkoYnVmLCAwLCAwLCB0aGlzLl9vZmZzZXQpO1xuICAgIHRoaXMuX2J1ZiA9IGJ1ZjtcbiAgICB0aGlzLl9zaXplID0gc3o7XG4gIH1cbn07XG5cblxuXG4vLyAtLS0gRXhwb3J0ZWQgQVBJXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/asn1/lib/ber/writer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/asn1/lib/index.js":
/*!****************************************!*\
  !*** ./node_modules/asn1/lib/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\n// If you have no idea what ASN.1 or BER is, see this:\n// ftp://ftp.rsa.com/pub/pkcs/ascii/layman.asc\n\nvar Ber = __webpack_require__(/*! ./ber/index */ \"(rsc)/./node_modules/asn1/lib/ber/index.js\");\n\n\n\n// --- Exported API\n\nmodule.exports = {\n\n  Ber: Ber,\n\n  BerReader: Ber.Reader,\n\n  BerWriter: Ber.Writer\n\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYXNuMS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTs7QUFFQSxVQUFVLG1CQUFPLENBQUMsK0RBQWE7Ozs7QUFJL0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYWdlLWZvcm0vLi9ub2RlX21vZHVsZXMvYXNuMS9saWIvaW5kZXguanM/OWJhMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxMSBNYXJrIENhdmFnZSA8bWNhdmFnZUBnbWFpbC5jb20+IEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbi8vIElmIHlvdSBoYXZlIG5vIGlkZWEgd2hhdCBBU04uMSBvciBCRVIgaXMsIHNlZSB0aGlzOlxuLy8gZnRwOi8vZnRwLnJzYS5jb20vcHViL3BrY3MvYXNjaWkvbGF5bWFuLmFzY1xuXG52YXIgQmVyID0gcmVxdWlyZSgnLi9iZXIvaW5kZXgnKTtcblxuXG5cbi8vIC0tLSBFeHBvcnRlZCBBUElcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgQmVyOiBCZXIsXG5cbiAgQmVyUmVhZGVyOiBCZXIuUmVhZGVyLFxuXG4gIEJlcldyaXRlcjogQmVyLldyaXRlclxuXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/asn1/lib/index.js\n");

/***/ })

};
;