/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/forever-agent";
exports.ids = ["vendor-chunks/forever-agent"];
exports.modules = {

/***/ "(rsc)/./node_modules/forever-agent/index.js":
/*!*********************************************!*\
  !*** ./node_modules/forever-agent/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = ForeverAgent\nForeverAgent.SSL = ForeverAgentSSL\n\nvar util = __webpack_require__(/*! util */ \"util\")\n  , Agent = (__webpack_require__(/*! http */ \"http\").Agent)\n  , net = __webpack_require__(/*! net */ \"net\")\n  , tls = __webpack_require__(/*! tls */ \"tls\")\n  , AgentSSL = (__webpack_require__(/*! https */ \"https\").Agent)\n  \nfunction getConnectionName(host, port) {  \n  var name = ''\n  if (typeof host === 'string') {\n    name = host + ':' + port\n  } else {\n    // For node.js v012.0 and iojs-v1.5.1, host is an object. And any existing localAddress is part of the connection name.\n    name = host.host + ':' + host.port + ':' + (host.localAddress ? (host.localAddress + ':') : ':')\n  }\n  return name\n}    \n\nfunction ForeverAgent(options) {\n  var self = this\n  self.options = options || {}\n  self.requests = {}\n  self.sockets = {}\n  self.freeSockets = {}\n  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets\n  self.minSockets = self.options.minSockets || ForeverAgent.defaultMinSockets\n  self.on('free', function(socket, host, port) {\n    var name = getConnectionName(host, port)\n\n    if (self.requests[name] && self.requests[name].length) {\n      self.requests[name].shift().onSocket(socket)\n    } else if (self.sockets[name].length < self.minSockets) {\n      if (!self.freeSockets[name]) self.freeSockets[name] = []\n      self.freeSockets[name].push(socket)\n      \n      // if an error happens while we don't use the socket anyway, meh, throw the socket away\n      var onIdleError = function() {\n        socket.destroy()\n      }\n      socket._onIdleError = onIdleError\n      socket.on('error', onIdleError)\n    } else {\n      // If there are no pending requests just destroy the\n      // socket and it will get removed from the pool. This\n      // gets us out of timeout issues and allows us to\n      // default to Connection:keep-alive.\n      socket.destroy()\n    }\n  })\n\n}\nutil.inherits(ForeverAgent, Agent)\n\nForeverAgent.defaultMinSockets = 5\n\n\nForeverAgent.prototype.createConnection = net.createConnection\nForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest\nForeverAgent.prototype.addRequest = function(req, host, port) {\n  var name = getConnectionName(host, port)\n  \n  if (typeof host !== 'string') {\n    var options = host\n    port = options.port\n    host = options.host\n  }\n\n  if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {\n    var idleSocket = this.freeSockets[name].pop()\n    idleSocket.removeListener('error', idleSocket._onIdleError)\n    delete idleSocket._onIdleError\n    req._reusedSocket = true\n    req.onSocket(idleSocket)\n  } else {\n    this.addRequestNoreuse(req, host, port)\n  }\n}\n\nForeverAgent.prototype.removeSocket = function(s, name, host, port) {\n  if (this.sockets[name]) {\n    var index = this.sockets[name].indexOf(s)\n    if (index !== -1) {\n      this.sockets[name].splice(index, 1)\n    }\n  } else if (this.sockets[name] && this.sockets[name].length === 0) {\n    // don't leak\n    delete this.sockets[name]\n    delete this.requests[name]\n  }\n  \n  if (this.freeSockets[name]) {\n    var index = this.freeSockets[name].indexOf(s)\n    if (index !== -1) {\n      this.freeSockets[name].splice(index, 1)\n      if (this.freeSockets[name].length === 0) {\n        delete this.freeSockets[name]\n      }\n    }\n  }\n\n  if (this.requests[name] && this.requests[name].length) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(name, host, port).emit('free')\n  }\n}\n\nfunction ForeverAgentSSL (options) {\n  ForeverAgent.call(this, options)\n}\nutil.inherits(ForeverAgentSSL, ForeverAgent)\n\nForeverAgentSSL.prototype.createConnection = createConnectionSSL\nForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest\n\nfunction createConnectionSSL (port, host, options) {\n  if (typeof port === 'object') {\n    options = port;\n  } else if (typeof host === 'object') {\n    options = host;\n  } else if (typeof options === 'object') {\n    options = options;\n  } else {\n    options = {};\n  }\n\n  if (typeof port === 'number') {\n    options.port = port;\n  }\n\n  if (typeof host === 'string') {\n    options.host = host;\n  }\n\n  return tls.connect(options);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZm9yZXZlci1hZ2VudC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixZQUFZLCtDQUFxQjtBQUNqQyxVQUFVLG1CQUFPLENBQUMsZ0JBQUs7QUFDdkIsVUFBVSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3ZCLGVBQWUsaURBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGFnZS1mb3JtLy4vbm9kZV9tb2R1bGVzL2ZvcmV2ZXItYWdlbnQvaW5kZXguanM/NTQxZSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IEZvcmV2ZXJBZ2VudFxuRm9yZXZlckFnZW50LlNTTCA9IEZvcmV2ZXJBZ2VudFNTTFxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuICAsIEFnZW50ID0gcmVxdWlyZSgnaHR0cCcpLkFnZW50XG4gICwgbmV0ID0gcmVxdWlyZSgnbmV0JylcbiAgLCB0bHMgPSByZXF1aXJlKCd0bHMnKVxuICAsIEFnZW50U1NMID0gcmVxdWlyZSgnaHR0cHMnKS5BZ2VudFxuICBcbmZ1bmN0aW9uIGdldENvbm5lY3Rpb25OYW1lKGhvc3QsIHBvcnQpIHsgIFxuICB2YXIgbmFtZSA9ICcnXG4gIGlmICh0eXBlb2YgaG9zdCA9PT0gJ3N0cmluZycpIHtcbiAgICBuYW1lID0gaG9zdCArICc6JyArIHBvcnRcbiAgfSBlbHNlIHtcbiAgICAvLyBGb3Igbm9kZS5qcyB2MDEyLjAgYW5kIGlvanMtdjEuNS4xLCBob3N0IGlzIGFuIG9iamVjdC4gQW5kIGFueSBleGlzdGluZyBsb2NhbEFkZHJlc3MgaXMgcGFydCBvZiB0aGUgY29ubmVjdGlvbiBuYW1lLlxuICAgIG5hbWUgPSBob3N0Lmhvc3QgKyAnOicgKyBob3N0LnBvcnQgKyAnOicgKyAoaG9zdC5sb2NhbEFkZHJlc3MgPyAoaG9zdC5sb2NhbEFkZHJlc3MgKyAnOicpIDogJzonKVxuICB9XG4gIHJldHVybiBuYW1lXG59ICAgIFxuXG5mdW5jdGlvbiBGb3JldmVyQWdlbnQob3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5vcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICBzZWxmLnJlcXVlc3RzID0ge31cbiAgc2VsZi5zb2NrZXRzID0ge31cbiAgc2VsZi5mcmVlU29ja2V0cyA9IHt9XG4gIHNlbGYubWF4U29ja2V0cyA9IHNlbGYub3B0aW9ucy5tYXhTb2NrZXRzIHx8IEFnZW50LmRlZmF1bHRNYXhTb2NrZXRzXG4gIHNlbGYubWluU29ja2V0cyA9IHNlbGYub3B0aW9ucy5taW5Tb2NrZXRzIHx8IEZvcmV2ZXJBZ2VudC5kZWZhdWx0TWluU29ja2V0c1xuICBzZWxmLm9uKCdmcmVlJywgZnVuY3Rpb24oc29ja2V0LCBob3N0LCBwb3J0KSB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb25uZWN0aW9uTmFtZShob3N0LCBwb3J0KVxuXG4gICAgaWYgKHNlbGYucmVxdWVzdHNbbmFtZV0gJiYgc2VsZi5yZXF1ZXN0c1tuYW1lXS5sZW5ndGgpIHtcbiAgICAgIHNlbGYucmVxdWVzdHNbbmFtZV0uc2hpZnQoKS5vblNvY2tldChzb2NrZXQpXG4gICAgfSBlbHNlIGlmIChzZWxmLnNvY2tldHNbbmFtZV0ubGVuZ3RoIDwgc2VsZi5taW5Tb2NrZXRzKSB7XG4gICAgICBpZiAoIXNlbGYuZnJlZVNvY2tldHNbbmFtZV0pIHNlbGYuZnJlZVNvY2tldHNbbmFtZV0gPSBbXVxuICAgICAgc2VsZi5mcmVlU29ja2V0c1tuYW1lXS5wdXNoKHNvY2tldClcbiAgICAgIFxuICAgICAgLy8gaWYgYW4gZXJyb3IgaGFwcGVucyB3aGlsZSB3ZSBkb24ndCB1c2UgdGhlIHNvY2tldCBhbnl3YXksIG1laCwgdGhyb3cgdGhlIHNvY2tldCBhd2F5XG4gICAgICB2YXIgb25JZGxlRXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc29ja2V0LmRlc3Ryb3koKVxuICAgICAgfVxuICAgICAgc29ja2V0Ll9vbklkbGVFcnJvciA9IG9uSWRsZUVycm9yXG4gICAgICBzb2NrZXQub24oJ2Vycm9yJywgb25JZGxlRXJyb3IpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBwZW5kaW5nIHJlcXVlc3RzIGp1c3QgZGVzdHJveSB0aGVcbiAgICAgIC8vIHNvY2tldCBhbmQgaXQgd2lsbCBnZXQgcmVtb3ZlZCBmcm9tIHRoZSBwb29sLiBUaGlzXG4gICAgICAvLyBnZXRzIHVzIG91dCBvZiB0aW1lb3V0IGlzc3VlcyBhbmQgYWxsb3dzIHVzIHRvXG4gICAgICAvLyBkZWZhdWx0IHRvIENvbm5lY3Rpb246a2VlcC1hbGl2ZS5cbiAgICAgIHNvY2tldC5kZXN0cm95KClcbiAgICB9XG4gIH0pXG5cbn1cbnV0aWwuaW5oZXJpdHMoRm9yZXZlckFnZW50LCBBZ2VudClcblxuRm9yZXZlckFnZW50LmRlZmF1bHRNaW5Tb2NrZXRzID0gNVxuXG5cbkZvcmV2ZXJBZ2VudC5wcm90b3R5cGUuY3JlYXRlQ29ubmVjdGlvbiA9IG5ldC5jcmVhdGVDb25uZWN0aW9uXG5Gb3JldmVyQWdlbnQucHJvdG90eXBlLmFkZFJlcXVlc3ROb3JldXNlID0gQWdlbnQucHJvdG90eXBlLmFkZFJlcXVlc3RcbkZvcmV2ZXJBZ2VudC5wcm90b3R5cGUuYWRkUmVxdWVzdCA9IGZ1bmN0aW9uKHJlcSwgaG9zdCwgcG9ydCkge1xuICB2YXIgbmFtZSA9IGdldENvbm5lY3Rpb25OYW1lKGhvc3QsIHBvcnQpXG4gIFxuICBpZiAodHlwZW9mIGhvc3QgIT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBob3N0XG4gICAgcG9ydCA9IG9wdGlvbnMucG9ydFxuICAgIGhvc3QgPSBvcHRpb25zLmhvc3RcbiAgfVxuXG4gIGlmICh0aGlzLmZyZWVTb2NrZXRzW25hbWVdICYmIHRoaXMuZnJlZVNvY2tldHNbbmFtZV0ubGVuZ3RoID4gMCAmJiAhcmVxLnVzZUNodW5rZWRFbmNvZGluZ0J5RGVmYXVsdCkge1xuICAgIHZhciBpZGxlU29ja2V0ID0gdGhpcy5mcmVlU29ja2V0c1tuYW1lXS5wb3AoKVxuICAgIGlkbGVTb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgaWRsZVNvY2tldC5fb25JZGxlRXJyb3IpXG4gICAgZGVsZXRlIGlkbGVTb2NrZXQuX29uSWRsZUVycm9yXG4gICAgcmVxLl9yZXVzZWRTb2NrZXQgPSB0cnVlXG4gICAgcmVxLm9uU29ja2V0KGlkbGVTb2NrZXQpXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hZGRSZXF1ZXN0Tm9yZXVzZShyZXEsIGhvc3QsIHBvcnQpXG4gIH1cbn1cblxuRm9yZXZlckFnZW50LnByb3RvdHlwZS5yZW1vdmVTb2NrZXQgPSBmdW5jdGlvbihzLCBuYW1lLCBob3N0LCBwb3J0KSB7XG4gIGlmICh0aGlzLnNvY2tldHNbbmFtZV0pIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLnNvY2tldHNbbmFtZV0uaW5kZXhPZihzKVxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuc29ja2V0c1tuYW1lXS5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuc29ja2V0c1tuYW1lXSAmJiB0aGlzLnNvY2tldHNbbmFtZV0ubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gZG9uJ3QgbGVha1xuICAgIGRlbGV0ZSB0aGlzLnNvY2tldHNbbmFtZV1cbiAgICBkZWxldGUgdGhpcy5yZXF1ZXN0c1tuYW1lXVxuICB9XG4gIFxuICBpZiAodGhpcy5mcmVlU29ja2V0c1tuYW1lXSkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuZnJlZVNvY2tldHNbbmFtZV0uaW5kZXhPZihzKVxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuZnJlZVNvY2tldHNbbmFtZV0uc3BsaWNlKGluZGV4LCAxKVxuICAgICAgaWYgKHRoaXMuZnJlZVNvY2tldHNbbmFtZV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmZyZWVTb2NrZXRzW25hbWVdXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucmVxdWVzdHNbbmFtZV0gJiYgdGhpcy5yZXF1ZXN0c1tuYW1lXS5sZW5ndGgpIHtcbiAgICAvLyBJZiB3ZSBoYXZlIHBlbmRpbmcgcmVxdWVzdHMgYW5kIGEgc29ja2V0IGdldHMgY2xvc2VkIGEgbmV3IG9uZVxuICAgIC8vIG5lZWRzIHRvIGJlIGNyZWF0ZWQgdG8gdGFrZSBvdmVyIGluIHRoZSBwb29sIGZvciB0aGUgb25lIHRoYXQgY2xvc2VkLlxuICAgIHRoaXMuY3JlYXRlU29ja2V0KG5hbWUsIGhvc3QsIHBvcnQpLmVtaXQoJ2ZyZWUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIEZvcmV2ZXJBZ2VudFNTTCAob3B0aW9ucykge1xuICBGb3JldmVyQWdlbnQuY2FsbCh0aGlzLCBvcHRpb25zKVxufVxudXRpbC5pbmhlcml0cyhGb3JldmVyQWdlbnRTU0wsIEZvcmV2ZXJBZ2VudClcblxuRm9yZXZlckFnZW50U1NMLnByb3RvdHlwZS5jcmVhdGVDb25uZWN0aW9uID0gY3JlYXRlQ29ubmVjdGlvblNTTFxuRm9yZXZlckFnZW50U1NMLnByb3RvdHlwZS5hZGRSZXF1ZXN0Tm9yZXVzZSA9IEFnZW50U1NMLnByb3RvdHlwZS5hZGRSZXF1ZXN0XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3Rpb25TU0wgKHBvcnQsIGhvc3QsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBwb3J0ID09PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMgPSBwb3J0O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBob3N0ID09PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMgPSBob3N0O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcG9ydCA9PT0gJ251bWJlcicpIHtcbiAgICBvcHRpb25zLnBvcnQgPSBwb3J0O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBob3N0ID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMuaG9zdCA9IGhvc3Q7XG4gIH1cblxuICByZXR1cm4gdGxzLmNvbm5lY3Qob3B0aW9ucyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/forever-agent/index.js\n");

/***/ })

};
;