/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/verror";
exports.ids = ["vendor-chunks/verror"];
exports.modules = {

/***/ "(rsc)/./node_modules/verror/lib/verror.js":
/*!*******************************************!*\
  !*** ./node_modules/verror/lib/verror.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n * verror.js: richer JavaScript errors\n */\n\nvar mod_assertplus = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar mod_util = __webpack_require__(/*! util */ \"util\");\n\nvar mod_extsprintf = __webpack_require__(/*! extsprintf */ \"(rsc)/./node_modules/extsprintf/lib/extsprintf.js\");\nvar mod_isError = (__webpack_require__(/*! core-util-is */ \"(rsc)/./node_modules/verror/node_modules/core-util-is/lib/util.js\").isError);\nvar sprintf = mod_extsprintf.sprintf;\n\n/*\n * Public interface\n */\n\n/* So you can 'var VError = require('verror')' */\nmodule.exports = VError;\n/* For compatibility */\nVError.VError = VError;\n/* Other exported classes */\nVError.SError = SError;\nVError.WError = WError;\nVError.MultiError = MultiError;\n\n/*\n * Common function used to parse constructor arguments for VError, WError, and\n * SError.  Named arguments to this function:\n *\n *     strict\t\tforce strict interpretation of sprintf arguments, even\n *     \t\t\tif the options in \"argv\" don't say so\n *\n *     argv\t\terror's constructor arguments, which are to be\n *     \t\t\tinterpreted as described in README.md.  For quick\n *     \t\t\treference, \"argv\" has one of the following forms:\n *\n *          [ sprintf_args... ]           (argv[0] is a string)\n *          [ cause, sprintf_args... ]    (argv[0] is an Error)\n *          [ options, sprintf_args... ]  (argv[0] is an object)\n *\n * This function normalizes these forms, producing an object with the following\n * properties:\n *\n *    options           equivalent to \"options\" in third form.  This will never\n *    \t\t\tbe a direct reference to what the caller passed in\n *    \t\t\t(i.e., it may be a shallow copy), so it can be freely\n *    \t\t\tmodified.\n *\n *    shortmessage      result of sprintf(sprintf_args), taking options.strict\n *    \t\t\tinto account as described in README.md.\n */\nfunction parseConstructorArguments(args)\n{\n\tvar argv, options, sprintf_args, shortmessage, k;\n\n\tmod_assertplus.object(args, 'args');\n\tmod_assertplus.bool(args.strict, 'args.strict');\n\tmod_assertplus.array(args.argv, 'args.argv');\n\targv = args.argv;\n\n\t/*\n\t * First, figure out which form of invocation we've been given.\n\t */\n\tif (argv.length === 0) {\n\t\toptions = {};\n\t\tsprintf_args = [];\n\t} else if (mod_isError(argv[0])) {\n\t\toptions = { 'cause': argv[0] };\n\t\tsprintf_args = argv.slice(1);\n\t} else if (typeof (argv[0]) === 'object') {\n\t\toptions = {};\n\t\tfor (k in argv[0]) {\n\t\t\toptions[k] = argv[0][k];\n\t\t}\n\t\tsprintf_args = argv.slice(1);\n\t} else {\n\t\tmod_assertplus.string(argv[0],\n\t\t    'first argument to VError, SError, or WError ' +\n\t\t    'constructor must be a string, object, or Error');\n\t\toptions = {};\n\t\tsprintf_args = argv;\n\t}\n\n\t/*\n\t * Now construct the error's message.\n\t *\n\t * extsprintf (which we invoke here with our caller's arguments in order\n\t * to construct this Error's message) is strict in its interpretation of\n\t * values to be processed by the \"%s\" specifier.  The value passed to\n\t * extsprintf must actually be a string or something convertible to a\n\t * String using .toString().  Passing other values (notably \"null\" and\n\t * \"undefined\") is considered a programmer error.  The assumption is\n\t * that if you actually want to print the string \"null\" or \"undefined\",\n\t * then that's easy to do that when you're calling extsprintf; on the\n\t * other hand, if you did NOT want that (i.e., there's actually a bug\n\t * where the program assumes some variable is non-null and tries to\n\t * print it, which might happen when constructing a packet or file in\n\t * some specific format), then it's better to stop immediately than\n\t * produce bogus output.\n\t *\n\t * However, sometimes the bug is only in the code calling VError, and a\n\t * programmer might prefer to have the error message contain \"null\" or\n\t * \"undefined\" rather than have the bug in the error path crash the\n\t * program (making the first bug harder to identify).  For that reason,\n\t * by default VError converts \"null\" or \"undefined\" arguments to their\n\t * string representations and passes those to extsprintf.  Programmers\n\t * desiring the strict behavior can use the SError class or pass the\n\t * \"strict\" option to the VError constructor.\n\t */\n\tmod_assertplus.object(options);\n\tif (!options.strict && !args.strict) {\n\t\tsprintf_args = sprintf_args.map(function (a) {\n\t\t\treturn (a === null ? 'null' :\n\t\t\t    a === undefined ? 'undefined' : a);\n\t\t});\n\t}\n\n\tif (sprintf_args.length === 0) {\n\t\tshortmessage = '';\n\t} else {\n\t\tshortmessage = sprintf.apply(null, sprintf_args);\n\t}\n\n\treturn ({\n\t    'options': options,\n\t    'shortmessage': shortmessage\n\t});\n}\n\n/*\n * See README.md for reference documentation.\n */\nfunction VError()\n{\n\tvar args, obj, parsed, cause, ctor, message, k;\n\n\targs = Array.prototype.slice.call(arguments, 0);\n\n\t/*\n\t * This is a regrettable pattern, but JavaScript's built-in Error class\n\t * is defined to work this way, so we allow the constructor to be called\n\t * without \"new\".\n\t */\n\tif (!(this instanceof VError)) {\n\t\tobj = Object.create(VError.prototype);\n\t\tVError.apply(obj, arguments);\n\t\treturn (obj);\n\t}\n\n\t/*\n\t * For convenience and backwards compatibility, we support several\n\t * different calling forms.  Normalize them here.\n\t */\n\tparsed = parseConstructorArguments({\n\t    'argv': args,\n\t    'strict': false\n\t});\n\n\t/*\n\t * If we've been given a name, apply it now.\n\t */\n\tif (parsed.options.name) {\n\t\tmod_assertplus.string(parsed.options.name,\n\t\t    'error\\'s \"name\" must be a string');\n\t\tthis.name = parsed.options.name;\n\t}\n\n\t/*\n\t * For debugging, we keep track of the original short message (attached\n\t * this Error particularly) separately from the complete message (which\n\t * includes the messages of our cause chain).\n\t */\n\tthis.jse_shortmsg = parsed.shortmessage;\n\tmessage = parsed.shortmessage;\n\n\t/*\n\t * If we've been given a cause, record a reference to it and update our\n\t * message appropriately.\n\t */\n\tcause = parsed.options.cause;\n\tif (cause) {\n\t\tmod_assertplus.ok(mod_isError(cause), 'cause is not an Error');\n\t\tthis.jse_cause = cause;\n\n\t\tif (!parsed.options.skipCauseMessage) {\n\t\t\tmessage += ': ' + cause.message;\n\t\t}\n\t}\n\n\t/*\n\t * If we've been given an object with properties, shallow-copy that\n\t * here.  We don't want to use a deep copy in case there are non-plain\n\t * objects here, but we don't want to use the original object in case\n\t * the caller modifies it later.\n\t */\n\tthis.jse_info = {};\n\tif (parsed.options.info) {\n\t\tfor (k in parsed.options.info) {\n\t\t\tthis.jse_info[k] = parsed.options.info[k];\n\t\t}\n\t}\n\n\tthis.message = message;\n\tError.call(this, message);\n\n\tif (Error.captureStackTrace) {\n\t\tctor = parsed.options.constructorOpt || this.constructor;\n\t\tError.captureStackTrace(this, ctor);\n\t}\n\n\treturn (this);\n}\n\nmod_util.inherits(VError, Error);\nVError.prototype.name = 'VError';\n\nVError.prototype.toString = function ve_toString()\n{\n\tvar str = (this.hasOwnProperty('name') && this.name ||\n\t\tthis.constructor.name || this.constructor.prototype.name);\n\tif (this.message)\n\t\tstr += ': ' + this.message;\n\n\treturn (str);\n};\n\n/*\n * This method is provided for compatibility.  New callers should use\n * VError.cause() instead.  That method also uses the saner `null` return value\n * when there is no cause.\n */\nVError.prototype.cause = function ve_cause()\n{\n\tvar cause = VError.cause(this);\n\treturn (cause === null ? undefined : cause);\n};\n\n/*\n * Static methods\n *\n * These class-level methods are provided so that callers can use them on\n * instances of Errors that are not VErrors.  New interfaces should be provided\n * only using static methods to eliminate the class of programming mistake where\n * people fail to check whether the Error object has the corresponding methods.\n */\n\nVError.cause = function (err)\n{\n\tmod_assertplus.ok(mod_isError(err), 'err must be an Error');\n\treturn (mod_isError(err.jse_cause) ? err.jse_cause : null);\n};\n\nVError.info = function (err)\n{\n\tvar rv, cause, k;\n\n\tmod_assertplus.ok(mod_isError(err), 'err must be an Error');\n\tcause = VError.cause(err);\n\tif (cause !== null) {\n\t\trv = VError.info(cause);\n\t} else {\n\t\trv = {};\n\t}\n\n\tif (typeof (err.jse_info) == 'object' && err.jse_info !== null) {\n\t\tfor (k in err.jse_info) {\n\t\t\trv[k] = err.jse_info[k];\n\t\t}\n\t}\n\n\treturn (rv);\n};\n\nVError.findCauseByName = function (err, name)\n{\n\tvar cause;\n\n\tmod_assertplus.ok(mod_isError(err), 'err must be an Error');\n\tmod_assertplus.string(name, 'name');\n\tmod_assertplus.ok(name.length > 0, 'name cannot be empty');\n\n\tfor (cause = err; cause !== null; cause = VError.cause(cause)) {\n\t\tmod_assertplus.ok(mod_isError(cause));\n\t\tif (cause.name == name) {\n\t\t\treturn (cause);\n\t\t}\n\t}\n\n\treturn (null);\n};\n\nVError.hasCauseWithName = function (err, name)\n{\n\treturn (VError.findCauseByName(err, name) !== null);\n};\n\nVError.fullStack = function (err)\n{\n\tmod_assertplus.ok(mod_isError(err), 'err must be an Error');\n\n\tvar cause = VError.cause(err);\n\n\tif (cause) {\n\t\treturn (err.stack + '\\ncaused by: ' + VError.fullStack(cause));\n\t}\n\n\treturn (err.stack);\n};\n\nVError.errorFromList = function (errors)\n{\n\tmod_assertplus.arrayOfObject(errors, 'errors');\n\n\tif (errors.length === 0) {\n\t\treturn (null);\n\t}\n\n\terrors.forEach(function (e) {\n\t\tmod_assertplus.ok(mod_isError(e));\n\t});\n\n\tif (errors.length == 1) {\n\t\treturn (errors[0]);\n\t}\n\n\treturn (new MultiError(errors));\n};\n\nVError.errorForEach = function (err, func)\n{\n\tmod_assertplus.ok(mod_isError(err), 'err must be an Error');\n\tmod_assertplus.func(func, 'func');\n\n\tif (err instanceof MultiError) {\n\t\terr.errors().forEach(function iterError(e) { func(e); });\n\t} else {\n\t\tfunc(err);\n\t}\n};\n\n\n/*\n * SError is like VError, but stricter about types.  You cannot pass \"null\" or\n * \"undefined\" as string arguments to the formatter.\n */\nfunction SError()\n{\n\tvar args, obj, parsed, options;\n\n\targs = Array.prototype.slice.call(arguments, 0);\n\tif (!(this instanceof SError)) {\n\t\tobj = Object.create(SError.prototype);\n\t\tSError.apply(obj, arguments);\n\t\treturn (obj);\n\t}\n\n\tparsed = parseConstructorArguments({\n\t    'argv': args,\n\t    'strict': true\n\t});\n\n\toptions = parsed.options;\n\tVError.call(this, options, '%s', parsed.shortmessage);\n\n\treturn (this);\n}\n\n/*\n * We don't bother setting SError.prototype.name because once constructed,\n * SErrors are just like VErrors.\n */\nmod_util.inherits(SError, VError);\n\n\n/*\n * Represents a collection of errors for the purpose of consumers that generally\n * only deal with one error.  Callers can extract the individual errors\n * contained in this object, but may also just treat it as a normal single\n * error, in which case a summary message will be printed.\n */\nfunction MultiError(errors)\n{\n\tmod_assertplus.array(errors, 'list of errors');\n\tmod_assertplus.ok(errors.length > 0, 'must be at least one error');\n\tthis.ase_errors = errors;\n\n\tVError.call(this, {\n\t    'cause': errors[0]\n\t}, 'first of %d error%s', errors.length, errors.length == 1 ? '' : 's');\n}\n\nmod_util.inherits(MultiError, VError);\nMultiError.prototype.name = 'MultiError';\n\nMultiError.prototype.errors = function me_errors()\n{\n\treturn (this.ase_errors.slice(0));\n};\n\n\n/*\n * See README.md for reference details.\n */\nfunction WError()\n{\n\tvar args, obj, parsed, options;\n\n\targs = Array.prototype.slice.call(arguments, 0);\n\tif (!(this instanceof WError)) {\n\t\tobj = Object.create(WError.prototype);\n\t\tWError.apply(obj, args);\n\t\treturn (obj);\n\t}\n\n\tparsed = parseConstructorArguments({\n\t    'argv': args,\n\t    'strict': false\n\t});\n\n\toptions = parsed.options;\n\toptions['skipCauseMessage'] = true;\n\tVError.call(this, options, '%s', parsed.shortmessage);\n\n\treturn (this);\n}\n\nmod_util.inherits(WError, VError);\nWError.prototype.name = 'WError';\n\nWError.prototype.toString = function we_toString()\n{\n\tvar str = (this.hasOwnProperty('name') && this.name ||\n\t\tthis.constructor.name || this.constructor.prototype.name);\n\tif (this.message)\n\t\tstr += ': ' + this.message;\n\tif (this.jse_cause && this.jse_cause.message)\n\t\tstr += '; caused by ' + this.jse_cause.toString();\n\n\treturn (str);\n};\n\n/*\n * For purely historical reasons, WError's cause() function allows you to set\n * the cause.\n */\nWError.prototype.cause = function we_cause(c)\n{\n\tif (mod_isError(c))\n\t\tthis.jse_cause = c;\n\n\treturn (this.jse_cause);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdmVycm9yL2xpYi92ZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixtQkFBTyxDQUFDLCtEQUFhO0FBQzFDLGVBQWUsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFN0IscUJBQXFCLG1CQUFPLENBQUMscUVBQVk7QUFDekMsa0JBQWtCLHNIQUErQjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxjQUFjO0FBQ2Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RCxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BhZ2UtZm9ybS8uL25vZGVfbW9kdWxlcy92ZXJyb3IvbGliL3ZlcnJvci5qcz9lOTBmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiB2ZXJyb3IuanM6IHJpY2hlciBKYXZhU2NyaXB0IGVycm9yc1xuICovXG5cbnZhciBtb2RfYXNzZXJ0cGx1cyA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgbW9kX3V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbnZhciBtb2RfZXh0c3ByaW50ZiA9IHJlcXVpcmUoJ2V4dHNwcmludGYnKTtcbnZhciBtb2RfaXNFcnJvciA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpLmlzRXJyb3I7XG52YXIgc3ByaW50ZiA9IG1vZF9leHRzcHJpbnRmLnNwcmludGY7XG5cbi8qXG4gKiBQdWJsaWMgaW50ZXJmYWNlXG4gKi9cblxuLyogU28geW91IGNhbiAndmFyIFZFcnJvciA9IHJlcXVpcmUoJ3ZlcnJvcicpJyAqL1xubW9kdWxlLmV4cG9ydHMgPSBWRXJyb3I7XG4vKiBGb3IgY29tcGF0aWJpbGl0eSAqL1xuVkVycm9yLlZFcnJvciA9IFZFcnJvcjtcbi8qIE90aGVyIGV4cG9ydGVkIGNsYXNzZXMgKi9cblZFcnJvci5TRXJyb3IgPSBTRXJyb3I7XG5WRXJyb3IuV0Vycm9yID0gV0Vycm9yO1xuVkVycm9yLk11bHRpRXJyb3IgPSBNdWx0aUVycm9yO1xuXG4vKlxuICogQ29tbW9uIGZ1bmN0aW9uIHVzZWQgdG8gcGFyc2UgY29uc3RydWN0b3IgYXJndW1lbnRzIGZvciBWRXJyb3IsIFdFcnJvciwgYW5kXG4gKiBTRXJyb3IuICBOYW1lZCBhcmd1bWVudHMgdG8gdGhpcyBmdW5jdGlvbjpcbiAqXG4gKiAgICAgc3RyaWN0XHRcdGZvcmNlIHN0cmljdCBpbnRlcnByZXRhdGlvbiBvZiBzcHJpbnRmIGFyZ3VtZW50cywgZXZlblxuICogICAgIFx0XHRcdGlmIHRoZSBvcHRpb25zIGluIFwiYXJndlwiIGRvbid0IHNheSBzb1xuICpcbiAqICAgICBhcmd2XHRcdGVycm9yJ3MgY29uc3RydWN0b3IgYXJndW1lbnRzLCB3aGljaCBhcmUgdG8gYmVcbiAqICAgICBcdFx0XHRpbnRlcnByZXRlZCBhcyBkZXNjcmliZWQgaW4gUkVBRE1FLm1kLiAgRm9yIHF1aWNrXG4gKiAgICAgXHRcdFx0cmVmZXJlbmNlLCBcImFyZ3ZcIiBoYXMgb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybXM6XG4gKlxuICogICAgICAgICAgWyBzcHJpbnRmX2FyZ3MuLi4gXSAgICAgICAgICAgKGFyZ3ZbMF0gaXMgYSBzdHJpbmcpXG4gKiAgICAgICAgICBbIGNhdXNlLCBzcHJpbnRmX2FyZ3MuLi4gXSAgICAoYXJndlswXSBpcyBhbiBFcnJvcilcbiAqICAgICAgICAgIFsgb3B0aW9ucywgc3ByaW50Zl9hcmdzLi4uIF0gIChhcmd2WzBdIGlzIGFuIG9iamVjdClcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIG5vcm1hbGl6ZXMgdGhlc2UgZm9ybXMsIHByb2R1Y2luZyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gKiBwcm9wZXJ0aWVzOlxuICpcbiAqICAgIG9wdGlvbnMgICAgICAgICAgIGVxdWl2YWxlbnQgdG8gXCJvcHRpb25zXCIgaW4gdGhpcmQgZm9ybS4gIFRoaXMgd2lsbCBuZXZlclxuICogICAgXHRcdFx0YmUgYSBkaXJlY3QgcmVmZXJlbmNlIHRvIHdoYXQgdGhlIGNhbGxlciBwYXNzZWQgaW5cbiAqICAgIFx0XHRcdChpLmUuLCBpdCBtYXkgYmUgYSBzaGFsbG93IGNvcHkpLCBzbyBpdCBjYW4gYmUgZnJlZWx5XG4gKiAgICBcdFx0XHRtb2RpZmllZC5cbiAqXG4gKiAgICBzaG9ydG1lc3NhZ2UgICAgICByZXN1bHQgb2Ygc3ByaW50ZihzcHJpbnRmX2FyZ3MpLCB0YWtpbmcgb3B0aW9ucy5zdHJpY3RcbiAqICAgIFx0XHRcdGludG8gYWNjb3VudCBhcyBkZXNjcmliZWQgaW4gUkVBRE1FLm1kLlxuICovXG5mdW5jdGlvbiBwYXJzZUNvbnN0cnVjdG9yQXJndW1lbnRzKGFyZ3MpXG57XG5cdHZhciBhcmd2LCBvcHRpb25zLCBzcHJpbnRmX2FyZ3MsIHNob3J0bWVzc2FnZSwgaztcblxuXHRtb2RfYXNzZXJ0cGx1cy5vYmplY3QoYXJncywgJ2FyZ3MnKTtcblx0bW9kX2Fzc2VydHBsdXMuYm9vbChhcmdzLnN0cmljdCwgJ2FyZ3Muc3RyaWN0Jyk7XG5cdG1vZF9hc3NlcnRwbHVzLmFycmF5KGFyZ3MuYXJndiwgJ2FyZ3MuYXJndicpO1xuXHRhcmd2ID0gYXJncy5hcmd2O1xuXG5cdC8qXG5cdCAqIEZpcnN0LCBmaWd1cmUgb3V0IHdoaWNoIGZvcm0gb2YgaW52b2NhdGlvbiB3ZSd2ZSBiZWVuIGdpdmVuLlxuXHQgKi9cblx0aWYgKGFyZ3YubGVuZ3RoID09PSAwKSB7XG5cdFx0b3B0aW9ucyA9IHt9O1xuXHRcdHNwcmludGZfYXJncyA9IFtdO1xuXHR9IGVsc2UgaWYgKG1vZF9pc0Vycm9yKGFyZ3ZbMF0pKSB7XG5cdFx0b3B0aW9ucyA9IHsgJ2NhdXNlJzogYXJndlswXSB9O1xuXHRcdHNwcmludGZfYXJncyA9IGFyZ3Yuc2xpY2UoMSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIChhcmd2WzBdKSA9PT0gJ29iamVjdCcpIHtcblx0XHRvcHRpb25zID0ge307XG5cdFx0Zm9yIChrIGluIGFyZ3ZbMF0pIHtcblx0XHRcdG9wdGlvbnNba10gPSBhcmd2WzBdW2tdO1xuXHRcdH1cblx0XHRzcHJpbnRmX2FyZ3MgPSBhcmd2LnNsaWNlKDEpO1xuXHR9IGVsc2Uge1xuXHRcdG1vZF9hc3NlcnRwbHVzLnN0cmluZyhhcmd2WzBdLFxuXHRcdCAgICAnZmlyc3QgYXJndW1lbnQgdG8gVkVycm9yLCBTRXJyb3IsIG9yIFdFcnJvciAnICtcblx0XHQgICAgJ2NvbnN0cnVjdG9yIG11c3QgYmUgYSBzdHJpbmcsIG9iamVjdCwgb3IgRXJyb3InKTtcblx0XHRvcHRpb25zID0ge307XG5cdFx0c3ByaW50Zl9hcmdzID0gYXJndjtcblx0fVxuXG5cdC8qXG5cdCAqIE5vdyBjb25zdHJ1Y3QgdGhlIGVycm9yJ3MgbWVzc2FnZS5cblx0ICpcblx0ICogZXh0c3ByaW50ZiAod2hpY2ggd2UgaW52b2tlIGhlcmUgd2l0aCBvdXIgY2FsbGVyJ3MgYXJndW1lbnRzIGluIG9yZGVyXG5cdCAqIHRvIGNvbnN0cnVjdCB0aGlzIEVycm9yJ3MgbWVzc2FnZSkgaXMgc3RyaWN0IGluIGl0cyBpbnRlcnByZXRhdGlvbiBvZlxuXHQgKiB2YWx1ZXMgdG8gYmUgcHJvY2Vzc2VkIGJ5IHRoZSBcIiVzXCIgc3BlY2lmaWVyLiAgVGhlIHZhbHVlIHBhc3NlZCB0b1xuXHQgKiBleHRzcHJpbnRmIG11c3QgYWN0dWFsbHkgYmUgYSBzdHJpbmcgb3Igc29tZXRoaW5nIGNvbnZlcnRpYmxlIHRvIGFcblx0ICogU3RyaW5nIHVzaW5nIC50b1N0cmluZygpLiAgUGFzc2luZyBvdGhlciB2YWx1ZXMgKG5vdGFibHkgXCJudWxsXCIgYW5kXG5cdCAqIFwidW5kZWZpbmVkXCIpIGlzIGNvbnNpZGVyZWQgYSBwcm9ncmFtbWVyIGVycm9yLiAgVGhlIGFzc3VtcHRpb24gaXNcblx0ICogdGhhdCBpZiB5b3UgYWN0dWFsbHkgd2FudCB0byBwcmludCB0aGUgc3RyaW5nIFwibnVsbFwiIG9yIFwidW5kZWZpbmVkXCIsXG5cdCAqIHRoZW4gdGhhdCdzIGVhc3kgdG8gZG8gdGhhdCB3aGVuIHlvdSdyZSBjYWxsaW5nIGV4dHNwcmludGY7IG9uIHRoZVxuXHQgKiBvdGhlciBoYW5kLCBpZiB5b3UgZGlkIE5PVCB3YW50IHRoYXQgKGkuZS4sIHRoZXJlJ3MgYWN0dWFsbHkgYSBidWdcblx0ICogd2hlcmUgdGhlIHByb2dyYW0gYXNzdW1lcyBzb21lIHZhcmlhYmxlIGlzIG5vbi1udWxsIGFuZCB0cmllcyB0b1xuXHQgKiBwcmludCBpdCwgd2hpY2ggbWlnaHQgaGFwcGVuIHdoZW4gY29uc3RydWN0aW5nIGEgcGFja2V0IG9yIGZpbGUgaW5cblx0ICogc29tZSBzcGVjaWZpYyBmb3JtYXQpLCB0aGVuIGl0J3MgYmV0dGVyIHRvIHN0b3AgaW1tZWRpYXRlbHkgdGhhblxuXHQgKiBwcm9kdWNlIGJvZ3VzIG91dHB1dC5cblx0ICpcblx0ICogSG93ZXZlciwgc29tZXRpbWVzIHRoZSBidWcgaXMgb25seSBpbiB0aGUgY29kZSBjYWxsaW5nIFZFcnJvciwgYW5kIGFcblx0ICogcHJvZ3JhbW1lciBtaWdodCBwcmVmZXIgdG8gaGF2ZSB0aGUgZXJyb3IgbWVzc2FnZSBjb250YWluIFwibnVsbFwiIG9yXG5cdCAqIFwidW5kZWZpbmVkXCIgcmF0aGVyIHRoYW4gaGF2ZSB0aGUgYnVnIGluIHRoZSBlcnJvciBwYXRoIGNyYXNoIHRoZVxuXHQgKiBwcm9ncmFtIChtYWtpbmcgdGhlIGZpcnN0IGJ1ZyBoYXJkZXIgdG8gaWRlbnRpZnkpLiAgRm9yIHRoYXQgcmVhc29uLFxuXHQgKiBieSBkZWZhdWx0IFZFcnJvciBjb252ZXJ0cyBcIm51bGxcIiBvciBcInVuZGVmaW5lZFwiIGFyZ3VtZW50cyB0byB0aGVpclxuXHQgKiBzdHJpbmcgcmVwcmVzZW50YXRpb25zIGFuZCBwYXNzZXMgdGhvc2UgdG8gZXh0c3ByaW50Zi4gIFByb2dyYW1tZXJzXG5cdCAqIGRlc2lyaW5nIHRoZSBzdHJpY3QgYmVoYXZpb3IgY2FuIHVzZSB0aGUgU0Vycm9yIGNsYXNzIG9yIHBhc3MgdGhlXG5cdCAqIFwic3RyaWN0XCIgb3B0aW9uIHRvIHRoZSBWRXJyb3IgY29uc3RydWN0b3IuXG5cdCAqL1xuXHRtb2RfYXNzZXJ0cGx1cy5vYmplY3Qob3B0aW9ucyk7XG5cdGlmICghb3B0aW9ucy5zdHJpY3QgJiYgIWFyZ3Muc3RyaWN0KSB7XG5cdFx0c3ByaW50Zl9hcmdzID0gc3ByaW50Zl9hcmdzLm1hcChmdW5jdGlvbiAoYSkge1xuXHRcdFx0cmV0dXJuIChhID09PSBudWxsID8gJ251bGwnIDpcblx0XHRcdCAgICBhID09PSB1bmRlZmluZWQgPyAndW5kZWZpbmVkJyA6IGEpO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKHNwcmludGZfYXJncy5sZW5ndGggPT09IDApIHtcblx0XHRzaG9ydG1lc3NhZ2UgPSAnJztcblx0fSBlbHNlIHtcblx0XHRzaG9ydG1lc3NhZ2UgPSBzcHJpbnRmLmFwcGx5KG51bGwsIHNwcmludGZfYXJncyk7XG5cdH1cblxuXHRyZXR1cm4gKHtcblx0ICAgICdvcHRpb25zJzogb3B0aW9ucyxcblx0ICAgICdzaG9ydG1lc3NhZ2UnOiBzaG9ydG1lc3NhZ2Vcblx0fSk7XG59XG5cbi8qXG4gKiBTZWUgUkVBRE1FLm1kIGZvciByZWZlcmVuY2UgZG9jdW1lbnRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gVkVycm9yKClcbntcblx0dmFyIGFyZ3MsIG9iaiwgcGFyc2VkLCBjYXVzZSwgY3RvciwgbWVzc2FnZSwgaztcblxuXHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuXHQvKlxuXHQgKiBUaGlzIGlzIGEgcmVncmV0dGFibGUgcGF0dGVybiwgYnV0IEphdmFTY3JpcHQncyBidWlsdC1pbiBFcnJvciBjbGFzc1xuXHQgKiBpcyBkZWZpbmVkIHRvIHdvcmsgdGhpcyB3YXksIHNvIHdlIGFsbG93IHRoZSBjb25zdHJ1Y3RvciB0byBiZSBjYWxsZWRcblx0ICogd2l0aG91dCBcIm5ld1wiLlxuXHQgKi9cblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFZFcnJvcikpIHtcblx0XHRvYmogPSBPYmplY3QuY3JlYXRlKFZFcnJvci5wcm90b3R5cGUpO1xuXHRcdFZFcnJvci5hcHBseShvYmosIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIChvYmopO1xuXHR9XG5cblx0Lypcblx0ICogRm9yIGNvbnZlbmllbmNlIGFuZCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgd2Ugc3VwcG9ydCBzZXZlcmFsXG5cdCAqIGRpZmZlcmVudCBjYWxsaW5nIGZvcm1zLiAgTm9ybWFsaXplIHRoZW0gaGVyZS5cblx0ICovXG5cdHBhcnNlZCA9IHBhcnNlQ29uc3RydWN0b3JBcmd1bWVudHMoe1xuXHQgICAgJ2FyZ3YnOiBhcmdzLFxuXHQgICAgJ3N0cmljdCc6IGZhbHNlXG5cdH0pO1xuXG5cdC8qXG5cdCAqIElmIHdlJ3ZlIGJlZW4gZ2l2ZW4gYSBuYW1lLCBhcHBseSBpdCBub3cuXG5cdCAqL1xuXHRpZiAocGFyc2VkLm9wdGlvbnMubmFtZSkge1xuXHRcdG1vZF9hc3NlcnRwbHVzLnN0cmluZyhwYXJzZWQub3B0aW9ucy5uYW1lLFxuXHRcdCAgICAnZXJyb3JcXCdzIFwibmFtZVwiIG11c3QgYmUgYSBzdHJpbmcnKTtcblx0XHR0aGlzLm5hbWUgPSBwYXJzZWQub3B0aW9ucy5uYW1lO1xuXHR9XG5cblx0Lypcblx0ICogRm9yIGRlYnVnZ2luZywgd2Uga2VlcCB0cmFjayBvZiB0aGUgb3JpZ2luYWwgc2hvcnQgbWVzc2FnZSAoYXR0YWNoZWRcblx0ICogdGhpcyBFcnJvciBwYXJ0aWN1bGFybHkpIHNlcGFyYXRlbHkgZnJvbSB0aGUgY29tcGxldGUgbWVzc2FnZSAod2hpY2hcblx0ICogaW5jbHVkZXMgdGhlIG1lc3NhZ2VzIG9mIG91ciBjYXVzZSBjaGFpbikuXG5cdCAqL1xuXHR0aGlzLmpzZV9zaG9ydG1zZyA9IHBhcnNlZC5zaG9ydG1lc3NhZ2U7XG5cdG1lc3NhZ2UgPSBwYXJzZWQuc2hvcnRtZXNzYWdlO1xuXG5cdC8qXG5cdCAqIElmIHdlJ3ZlIGJlZW4gZ2l2ZW4gYSBjYXVzZSwgcmVjb3JkIGEgcmVmZXJlbmNlIHRvIGl0IGFuZCB1cGRhdGUgb3VyXG5cdCAqIG1lc3NhZ2UgYXBwcm9wcmlhdGVseS5cblx0ICovXG5cdGNhdXNlID0gcGFyc2VkLm9wdGlvbnMuY2F1c2U7XG5cdGlmIChjYXVzZSkge1xuXHRcdG1vZF9hc3NlcnRwbHVzLm9rKG1vZF9pc0Vycm9yKGNhdXNlKSwgJ2NhdXNlIGlzIG5vdCBhbiBFcnJvcicpO1xuXHRcdHRoaXMuanNlX2NhdXNlID0gY2F1c2U7XG5cblx0XHRpZiAoIXBhcnNlZC5vcHRpb25zLnNraXBDYXVzZU1lc3NhZ2UpIHtcblx0XHRcdG1lc3NhZ2UgKz0gJzogJyArIGNhdXNlLm1lc3NhZ2U7XG5cdFx0fVxuXHR9XG5cblx0Lypcblx0ICogSWYgd2UndmUgYmVlbiBnaXZlbiBhbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzLCBzaGFsbG93LWNvcHkgdGhhdFxuXHQgKiBoZXJlLiAgV2UgZG9uJ3Qgd2FudCB0byB1c2UgYSBkZWVwIGNvcHkgaW4gY2FzZSB0aGVyZSBhcmUgbm9uLXBsYWluXG5cdCAqIG9iamVjdHMgaGVyZSwgYnV0IHdlIGRvbid0IHdhbnQgdG8gdXNlIHRoZSBvcmlnaW5hbCBvYmplY3QgaW4gY2FzZVxuXHQgKiB0aGUgY2FsbGVyIG1vZGlmaWVzIGl0IGxhdGVyLlxuXHQgKi9cblx0dGhpcy5qc2VfaW5mbyA9IHt9O1xuXHRpZiAocGFyc2VkLm9wdGlvbnMuaW5mbykge1xuXHRcdGZvciAoayBpbiBwYXJzZWQub3B0aW9ucy5pbmZvKSB7XG5cdFx0XHR0aGlzLmpzZV9pbmZvW2tdID0gcGFyc2VkLm9wdGlvbnMuaW5mb1trXTtcblx0XHR9XG5cdH1cblxuXHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXHRFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuXG5cdGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuXHRcdGN0b3IgPSBwYXJzZWQub3B0aW9ucy5jb25zdHJ1Y3Rvck9wdCB8fCB0aGlzLmNvbnN0cnVjdG9yO1xuXHRcdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIGN0b3IpO1xuXHR9XG5cblx0cmV0dXJuICh0aGlzKTtcbn1cblxubW9kX3V0aWwuaW5oZXJpdHMoVkVycm9yLCBFcnJvcik7XG5WRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnVkVycm9yJztcblxuVkVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHZlX3RvU3RyaW5nKClcbntcblx0dmFyIHN0ciA9ICh0aGlzLmhhc093blByb3BlcnR5KCduYW1lJykgJiYgdGhpcy5uYW1lIHx8XG5cdFx0dGhpcy5jb25zdHJ1Y3Rvci5uYW1lIHx8IHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLm5hbWUpO1xuXHRpZiAodGhpcy5tZXNzYWdlKVxuXHRcdHN0ciArPSAnOiAnICsgdGhpcy5tZXNzYWdlO1xuXG5cdHJldHVybiAoc3RyKTtcbn07XG5cbi8qXG4gKiBUaGlzIG1ldGhvZCBpcyBwcm92aWRlZCBmb3IgY29tcGF0aWJpbGl0eS4gIE5ldyBjYWxsZXJzIHNob3VsZCB1c2VcbiAqIFZFcnJvci5jYXVzZSgpIGluc3RlYWQuICBUaGF0IG1ldGhvZCBhbHNvIHVzZXMgdGhlIHNhbmVyIGBudWxsYCByZXR1cm4gdmFsdWVcbiAqIHdoZW4gdGhlcmUgaXMgbm8gY2F1c2UuXG4gKi9cblZFcnJvci5wcm90b3R5cGUuY2F1c2UgPSBmdW5jdGlvbiB2ZV9jYXVzZSgpXG57XG5cdHZhciBjYXVzZSA9IFZFcnJvci5jYXVzZSh0aGlzKTtcblx0cmV0dXJuIChjYXVzZSA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IGNhdXNlKTtcbn07XG5cbi8qXG4gKiBTdGF0aWMgbWV0aG9kc1xuICpcbiAqIFRoZXNlIGNsYXNzLWxldmVsIG1ldGhvZHMgYXJlIHByb3ZpZGVkIHNvIHRoYXQgY2FsbGVycyBjYW4gdXNlIHRoZW0gb25cbiAqIGluc3RhbmNlcyBvZiBFcnJvcnMgdGhhdCBhcmUgbm90IFZFcnJvcnMuICBOZXcgaW50ZXJmYWNlcyBzaG91bGQgYmUgcHJvdmlkZWRcbiAqIG9ubHkgdXNpbmcgc3RhdGljIG1ldGhvZHMgdG8gZWxpbWluYXRlIHRoZSBjbGFzcyBvZiBwcm9ncmFtbWluZyBtaXN0YWtlIHdoZXJlXG4gKiBwZW9wbGUgZmFpbCB0byBjaGVjayB3aGV0aGVyIHRoZSBFcnJvciBvYmplY3QgaGFzIHRoZSBjb3JyZXNwb25kaW5nIG1ldGhvZHMuXG4gKi9cblxuVkVycm9yLmNhdXNlID0gZnVuY3Rpb24gKGVycilcbntcblx0bW9kX2Fzc2VydHBsdXMub2sobW9kX2lzRXJyb3IoZXJyKSwgJ2VyciBtdXN0IGJlIGFuIEVycm9yJyk7XG5cdHJldHVybiAobW9kX2lzRXJyb3IoZXJyLmpzZV9jYXVzZSkgPyBlcnIuanNlX2NhdXNlIDogbnVsbCk7XG59O1xuXG5WRXJyb3IuaW5mbyA9IGZ1bmN0aW9uIChlcnIpXG57XG5cdHZhciBydiwgY2F1c2UsIGs7XG5cblx0bW9kX2Fzc2VydHBsdXMub2sobW9kX2lzRXJyb3IoZXJyKSwgJ2VyciBtdXN0IGJlIGFuIEVycm9yJyk7XG5cdGNhdXNlID0gVkVycm9yLmNhdXNlKGVycik7XG5cdGlmIChjYXVzZSAhPT0gbnVsbCkge1xuXHRcdHJ2ID0gVkVycm9yLmluZm8oY2F1c2UpO1xuXHR9IGVsc2Uge1xuXHRcdHJ2ID0ge307XG5cdH1cblxuXHRpZiAodHlwZW9mIChlcnIuanNlX2luZm8pID09ICdvYmplY3QnICYmIGVyci5qc2VfaW5mbyAhPT0gbnVsbCkge1xuXHRcdGZvciAoayBpbiBlcnIuanNlX2luZm8pIHtcblx0XHRcdHJ2W2tdID0gZXJyLmpzZV9pbmZvW2tdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiAocnYpO1xufTtcblxuVkVycm9yLmZpbmRDYXVzZUJ5TmFtZSA9IGZ1bmN0aW9uIChlcnIsIG5hbWUpXG57XG5cdHZhciBjYXVzZTtcblxuXHRtb2RfYXNzZXJ0cGx1cy5vayhtb2RfaXNFcnJvcihlcnIpLCAnZXJyIG11c3QgYmUgYW4gRXJyb3InKTtcblx0bW9kX2Fzc2VydHBsdXMuc3RyaW5nKG5hbWUsICduYW1lJyk7XG5cdG1vZF9hc3NlcnRwbHVzLm9rKG5hbWUubGVuZ3RoID4gMCwgJ25hbWUgY2Fubm90IGJlIGVtcHR5Jyk7XG5cblx0Zm9yIChjYXVzZSA9IGVycjsgY2F1c2UgIT09IG51bGw7IGNhdXNlID0gVkVycm9yLmNhdXNlKGNhdXNlKSkge1xuXHRcdG1vZF9hc3NlcnRwbHVzLm9rKG1vZF9pc0Vycm9yKGNhdXNlKSk7XG5cdFx0aWYgKGNhdXNlLm5hbWUgPT0gbmFtZSkge1xuXHRcdFx0cmV0dXJuIChjYXVzZSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIChudWxsKTtcbn07XG5cblZFcnJvci5oYXNDYXVzZVdpdGhOYW1lID0gZnVuY3Rpb24gKGVyciwgbmFtZSlcbntcblx0cmV0dXJuIChWRXJyb3IuZmluZENhdXNlQnlOYW1lKGVyciwgbmFtZSkgIT09IG51bGwpO1xufTtcblxuVkVycm9yLmZ1bGxTdGFjayA9IGZ1bmN0aW9uIChlcnIpXG57XG5cdG1vZF9hc3NlcnRwbHVzLm9rKG1vZF9pc0Vycm9yKGVyciksICdlcnIgbXVzdCBiZSBhbiBFcnJvcicpO1xuXG5cdHZhciBjYXVzZSA9IFZFcnJvci5jYXVzZShlcnIpO1xuXG5cdGlmIChjYXVzZSkge1xuXHRcdHJldHVybiAoZXJyLnN0YWNrICsgJ1xcbmNhdXNlZCBieTogJyArIFZFcnJvci5mdWxsU3RhY2soY2F1c2UpKTtcblx0fVxuXG5cdHJldHVybiAoZXJyLnN0YWNrKTtcbn07XG5cblZFcnJvci5lcnJvckZyb21MaXN0ID0gZnVuY3Rpb24gKGVycm9ycylcbntcblx0bW9kX2Fzc2VydHBsdXMuYXJyYXlPZk9iamVjdChlcnJvcnMsICdlcnJvcnMnKTtcblxuXHRpZiAoZXJyb3JzLmxlbmd0aCA9PT0gMCkge1xuXHRcdHJldHVybiAobnVsbCk7XG5cdH1cblxuXHRlcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuXHRcdG1vZF9hc3NlcnRwbHVzLm9rKG1vZF9pc0Vycm9yKGUpKTtcblx0fSk7XG5cblx0aWYgKGVycm9ycy5sZW5ndGggPT0gMSkge1xuXHRcdHJldHVybiAoZXJyb3JzWzBdKTtcblx0fVxuXG5cdHJldHVybiAobmV3IE11bHRpRXJyb3IoZXJyb3JzKSk7XG59O1xuXG5WRXJyb3IuZXJyb3JGb3JFYWNoID0gZnVuY3Rpb24gKGVyciwgZnVuYylcbntcblx0bW9kX2Fzc2VydHBsdXMub2sobW9kX2lzRXJyb3IoZXJyKSwgJ2VyciBtdXN0IGJlIGFuIEVycm9yJyk7XG5cdG1vZF9hc3NlcnRwbHVzLmZ1bmMoZnVuYywgJ2Z1bmMnKTtcblxuXHRpZiAoZXJyIGluc3RhbmNlb2YgTXVsdGlFcnJvcikge1xuXHRcdGVyci5lcnJvcnMoKS5mb3JFYWNoKGZ1bmN0aW9uIGl0ZXJFcnJvcihlKSB7IGZ1bmMoZSk7IH0pO1xuXHR9IGVsc2Uge1xuXHRcdGZ1bmMoZXJyKTtcblx0fVxufTtcblxuXG4vKlxuICogU0Vycm9yIGlzIGxpa2UgVkVycm9yLCBidXQgc3RyaWN0ZXIgYWJvdXQgdHlwZXMuICBZb3UgY2Fubm90IHBhc3MgXCJudWxsXCIgb3JcbiAqIFwidW5kZWZpbmVkXCIgYXMgc3RyaW5nIGFyZ3VtZW50cyB0byB0aGUgZm9ybWF0dGVyLlxuICovXG5mdW5jdGlvbiBTRXJyb3IoKVxue1xuXHR2YXIgYXJncywgb2JqLCBwYXJzZWQsIG9wdGlvbnM7XG5cblx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBTRXJyb3IpKSB7XG5cdFx0b2JqID0gT2JqZWN0LmNyZWF0ZShTRXJyb3IucHJvdG90eXBlKTtcblx0XHRTRXJyb3IuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiAob2JqKTtcblx0fVxuXG5cdHBhcnNlZCA9IHBhcnNlQ29uc3RydWN0b3JBcmd1bWVudHMoe1xuXHQgICAgJ2FyZ3YnOiBhcmdzLFxuXHQgICAgJ3N0cmljdCc6IHRydWVcblx0fSk7XG5cblx0b3B0aW9ucyA9IHBhcnNlZC5vcHRpb25zO1xuXHRWRXJyb3IuY2FsbCh0aGlzLCBvcHRpb25zLCAnJXMnLCBwYXJzZWQuc2hvcnRtZXNzYWdlKTtcblxuXHRyZXR1cm4gKHRoaXMpO1xufVxuXG4vKlxuICogV2UgZG9uJ3QgYm90aGVyIHNldHRpbmcgU0Vycm9yLnByb3RvdHlwZS5uYW1lIGJlY2F1c2Ugb25jZSBjb25zdHJ1Y3RlZCxcbiAqIFNFcnJvcnMgYXJlIGp1c3QgbGlrZSBWRXJyb3JzLlxuICovXG5tb2RfdXRpbC5pbmhlcml0cyhTRXJyb3IsIFZFcnJvcik7XG5cblxuLypcbiAqIFJlcHJlc2VudHMgYSBjb2xsZWN0aW9uIG9mIGVycm9ycyBmb3IgdGhlIHB1cnBvc2Ugb2YgY29uc3VtZXJzIHRoYXQgZ2VuZXJhbGx5XG4gKiBvbmx5IGRlYWwgd2l0aCBvbmUgZXJyb3IuICBDYWxsZXJzIGNhbiBleHRyYWN0IHRoZSBpbmRpdmlkdWFsIGVycm9yc1xuICogY29udGFpbmVkIGluIHRoaXMgb2JqZWN0LCBidXQgbWF5IGFsc28ganVzdCB0cmVhdCBpdCBhcyBhIG5vcm1hbCBzaW5nbGVcbiAqIGVycm9yLCBpbiB3aGljaCBjYXNlIGEgc3VtbWFyeSBtZXNzYWdlIHdpbGwgYmUgcHJpbnRlZC5cbiAqL1xuZnVuY3Rpb24gTXVsdGlFcnJvcihlcnJvcnMpXG57XG5cdG1vZF9hc3NlcnRwbHVzLmFycmF5KGVycm9ycywgJ2xpc3Qgb2YgZXJyb3JzJyk7XG5cdG1vZF9hc3NlcnRwbHVzLm9rKGVycm9ycy5sZW5ndGggPiAwLCAnbXVzdCBiZSBhdCBsZWFzdCBvbmUgZXJyb3InKTtcblx0dGhpcy5hc2VfZXJyb3JzID0gZXJyb3JzO1xuXG5cdFZFcnJvci5jYWxsKHRoaXMsIHtcblx0ICAgICdjYXVzZSc6IGVycm9yc1swXVxuXHR9LCAnZmlyc3Qgb2YgJWQgZXJyb3IlcycsIGVycm9ycy5sZW5ndGgsIGVycm9ycy5sZW5ndGggPT0gMSA/ICcnIDogJ3MnKTtcbn1cblxubW9kX3V0aWwuaW5oZXJpdHMoTXVsdGlFcnJvciwgVkVycm9yKTtcbk11bHRpRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnTXVsdGlFcnJvcic7XG5cbk11bHRpRXJyb3IucHJvdG90eXBlLmVycm9ycyA9IGZ1bmN0aW9uIG1lX2Vycm9ycygpXG57XG5cdHJldHVybiAodGhpcy5hc2VfZXJyb3JzLnNsaWNlKDApKTtcbn07XG5cblxuLypcbiAqIFNlZSBSRUFETUUubWQgZm9yIHJlZmVyZW5jZSBkZXRhaWxzLlxuICovXG5mdW5jdGlvbiBXRXJyb3IoKVxue1xuXHR2YXIgYXJncywgb2JqLCBwYXJzZWQsIG9wdGlvbnM7XG5cblx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBXRXJyb3IpKSB7XG5cdFx0b2JqID0gT2JqZWN0LmNyZWF0ZShXRXJyb3IucHJvdG90eXBlKTtcblx0XHRXRXJyb3IuYXBwbHkob2JqLCBhcmdzKTtcblx0XHRyZXR1cm4gKG9iaik7XG5cdH1cblxuXHRwYXJzZWQgPSBwYXJzZUNvbnN0cnVjdG9yQXJndW1lbnRzKHtcblx0ICAgICdhcmd2JzogYXJncyxcblx0ICAgICdzdHJpY3QnOiBmYWxzZVxuXHR9KTtcblxuXHRvcHRpb25zID0gcGFyc2VkLm9wdGlvbnM7XG5cdG9wdGlvbnNbJ3NraXBDYXVzZU1lc3NhZ2UnXSA9IHRydWU7XG5cdFZFcnJvci5jYWxsKHRoaXMsIG9wdGlvbnMsICclcycsIHBhcnNlZC5zaG9ydG1lc3NhZ2UpO1xuXG5cdHJldHVybiAodGhpcyk7XG59XG5cbm1vZF91dGlsLmluaGVyaXRzKFdFcnJvciwgVkVycm9yKTtcbldFcnJvci5wcm90b3R5cGUubmFtZSA9ICdXRXJyb3InO1xuXG5XRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gd2VfdG9TdHJpbmcoKVxue1xuXHR2YXIgc3RyID0gKHRoaXMuaGFzT3duUHJvcGVydHkoJ25hbWUnKSAmJiB0aGlzLm5hbWUgfHxcblx0XHR0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUubmFtZSk7XG5cdGlmICh0aGlzLm1lc3NhZ2UpXG5cdFx0c3RyICs9ICc6ICcgKyB0aGlzLm1lc3NhZ2U7XG5cdGlmICh0aGlzLmpzZV9jYXVzZSAmJiB0aGlzLmpzZV9jYXVzZS5tZXNzYWdlKVxuXHRcdHN0ciArPSAnOyBjYXVzZWQgYnkgJyArIHRoaXMuanNlX2NhdXNlLnRvU3RyaW5nKCk7XG5cblx0cmV0dXJuIChzdHIpO1xufTtcblxuLypcbiAqIEZvciBwdXJlbHkgaGlzdG9yaWNhbCByZWFzb25zLCBXRXJyb3IncyBjYXVzZSgpIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0XG4gKiB0aGUgY2F1c2UuXG4gKi9cbldFcnJvci5wcm90b3R5cGUuY2F1c2UgPSBmdW5jdGlvbiB3ZV9jYXVzZShjKVxue1xuXHRpZiAobW9kX2lzRXJyb3IoYykpXG5cdFx0dGhpcy5qc2VfY2F1c2UgPSBjO1xuXG5cdHJldHVybiAodGhpcy5qc2VfY2F1c2UpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/verror/lib/verror.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/verror/node_modules/core-util-is/lib/util.js":
/*!*******************************************************************!*\
  !*** ./node_modules/verror/node_modules/core-util-is/lib/util.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdmVycm9yL25vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkIsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYWdlLWZvcm0vLi9ub2RlX21vZHVsZXMvdmVycm9yL25vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanM/NGNjZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/verror/node_modules/core-util-is/lib/util.js\n");

/***/ })

};
;