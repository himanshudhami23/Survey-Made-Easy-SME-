/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/request";
exports.ids = ["vendor-chunks/request"];
exports.modules = {

/***/ "(rsc)/./node_modules/request/index.js":
/*!***************************************!*\
  !*** ./node_modules/request/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright 2010-2012 Mikeal Rogers\n//\n//    Licensed under the Apache License, Version 2.0 (the \"License\");\n//    you may not use this file except in compliance with the License.\n//    You may obtain a copy of the License at\n//\n//        http://www.apache.org/licenses/LICENSE-2.0\n//\n//    Unless required by applicable law or agreed to in writing, software\n//    distributed under the License is distributed on an \"AS IS\" BASIS,\n//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//    See the License for the specific language governing permissions and\n//    limitations under the License.\n\n\n\nvar extend = __webpack_require__(/*! extend */ \"(rsc)/./node_modules/extend/index.js\")\nvar cookies = __webpack_require__(/*! ./lib/cookies */ \"(rsc)/./node_modules/request/lib/cookies.js\")\nvar helpers = __webpack_require__(/*! ./lib/helpers */ \"(rsc)/./node_modules/request/lib/helpers.js\")\n\nvar paramsHaveRequestBody = helpers.paramsHaveRequestBody\n\n// organize params for patch, post, put, head, del\nfunction initParams (uri, options, callback) {\n  if (typeof options === 'function') {\n    callback = options\n  }\n\n  var params = {}\n  if (options !== null && typeof options === 'object') {\n    extend(params, options, {uri: uri})\n  } else if (typeof uri === 'string') {\n    extend(params, {uri: uri})\n  } else {\n    extend(params, uri)\n  }\n\n  params.callback = callback || params.callback\n  return params\n}\n\nfunction request (uri, options, callback) {\n  if (typeof uri === 'undefined') {\n    throw new Error('undefined is not a valid uri or options object.')\n  }\n\n  var params = initParams(uri, options, callback)\n\n  if (params.method === 'HEAD' && paramsHaveRequestBody(params)) {\n    throw new Error('HTTP HEAD requests MUST NOT include a request body.')\n  }\n\n  return new request.Request(params)\n}\n\nfunction verbFunc (verb) {\n  var method = verb.toUpperCase()\n  return function (uri, options, callback) {\n    var params = initParams(uri, options, callback)\n    params.method = method\n    return request(params, params.callback)\n  }\n}\n\n// define like this to please codeintel/intellisense IDEs\nrequest.get = verbFunc('get')\nrequest.head = verbFunc('head')\nrequest.options = verbFunc('options')\nrequest.post = verbFunc('post')\nrequest.put = verbFunc('put')\nrequest.patch = verbFunc('patch')\nrequest.del = verbFunc('delete')\nrequest['delete'] = verbFunc('delete')\n\nrequest.jar = function (store) {\n  return cookies.jar(store)\n}\n\nrequest.cookie = function (str) {\n  return cookies.parse(str)\n}\n\nfunction wrapRequestMethod (method, options, requester, verb) {\n  return function (uri, opts, callback) {\n    var params = initParams(uri, opts, callback)\n\n    var target = {}\n    extend(true, target, options, params)\n\n    target.pool = params.pool || options.pool\n\n    if (verb) {\n      target.method = verb.toUpperCase()\n    }\n\n    if (typeof requester === 'function') {\n      method = requester\n    }\n\n    return method(target, target.callback)\n  }\n}\n\nrequest.defaults = function (options, requester) {\n  var self = this\n\n  options = options || {}\n\n  if (typeof options === 'function') {\n    requester = options\n    options = {}\n  }\n\n  var defaults = wrapRequestMethod(self, options, requester)\n\n  var verbs = ['get', 'head', 'post', 'put', 'patch', 'del', 'delete']\n  verbs.forEach(function (verb) {\n    defaults[verb] = wrapRequestMethod(self[verb], options, requester, verb)\n  })\n\n  defaults.cookie = wrapRequestMethod(self.cookie, options, requester)\n  defaults.jar = self.jar\n  defaults.defaults = self.defaults\n  return defaults\n}\n\nrequest.forever = function (agentOptions, optionsArg) {\n  var options = {}\n  if (optionsArg) {\n    extend(options, optionsArg)\n  }\n  if (agentOptions) {\n    options.agentOptions = agentOptions\n  }\n\n  options.forever = true\n  return request.defaults(options)\n}\n\n// Exports\n\nmodule.exports = request\nrequest.Request = __webpack_require__(/*! ./request */ \"(rsc)/./node_modules/request/request.js\")\nrequest.initParams = initParams\n\n// Backwards compatibility for request.debug\nObject.defineProperty(request, 'debug', {\n  enumerable: true,\n  get: function () {\n    return request.Request.debug\n  },\n  set: function (debug) {\n    request.Request.debug = debug\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFWTs7QUFFWixhQUFhLG1CQUFPLENBQUMsb0RBQVE7QUFDN0IsY0FBYyxtQkFBTyxDQUFDLGtFQUFlO0FBQ3JDLGNBQWMsbUJBQU8sQ0FBQyxrRUFBZTs7QUFFckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEMsSUFBSTtBQUNKLG9CQUFvQixTQUFTO0FBQzdCLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsMERBQVc7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGFnZS1mb3JtLy4vbm9kZV9tb2R1bGVzL3JlcXVlc3QvaW5kZXguanM/OTcwMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxMC0yMDEyIE1pa2VhbCBSb2dlcnNcbi8vXG4vLyAgICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8gICAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gICAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vICAgIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vICAgIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vICAgIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gICAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gICAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kJylcbnZhciBjb29raWVzID0gcmVxdWlyZSgnLi9saWIvY29va2llcycpXG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vbGliL2hlbHBlcnMnKVxuXG52YXIgcGFyYW1zSGF2ZVJlcXVlc3RCb2R5ID0gaGVscGVycy5wYXJhbXNIYXZlUmVxdWVzdEJvZHlcblxuLy8gb3JnYW5pemUgcGFyYW1zIGZvciBwYXRjaCwgcG9zdCwgcHV0LCBoZWFkLCBkZWxcbmZ1bmN0aW9uIGluaXRQYXJhbXMgKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gIH1cblxuICB2YXIgcGFyYW1zID0ge31cbiAgaWYgKG9wdGlvbnMgIT09IG51bGwgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgZXh0ZW5kKHBhcmFtcywgb3B0aW9ucywge3VyaTogdXJpfSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgdXJpID09PSAnc3RyaW5nJykge1xuICAgIGV4dGVuZChwYXJhbXMsIHt1cmk6IHVyaX0pXG4gIH0gZWxzZSB7XG4gICAgZXh0ZW5kKHBhcmFtcywgdXJpKVxuICB9XG5cbiAgcGFyYW1zLmNhbGxiYWNrID0gY2FsbGJhY2sgfHwgcGFyYW1zLmNhbGxiYWNrXG4gIHJldHVybiBwYXJhbXNcbn1cblxuZnVuY3Rpb24gcmVxdWVzdCAodXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHVyaSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZGVmaW5lZCBpcyBub3QgYSB2YWxpZCB1cmkgb3Igb3B0aW9ucyBvYmplY3QuJylcbiAgfVxuXG4gIHZhciBwYXJhbXMgPSBpbml0UGFyYW1zKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spXG5cbiAgaWYgKHBhcmFtcy5tZXRob2QgPT09ICdIRUFEJyAmJiBwYXJhbXNIYXZlUmVxdWVzdEJvZHkocGFyYW1zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSFRUUCBIRUFEIHJlcXVlc3RzIE1VU1QgTk9UIGluY2x1ZGUgYSByZXF1ZXN0IGJvZHkuJylcbiAgfVxuXG4gIHJldHVybiBuZXcgcmVxdWVzdC5SZXF1ZXN0KHBhcmFtcylcbn1cblxuZnVuY3Rpb24gdmVyYkZ1bmMgKHZlcmIpIHtcbiAgdmFyIG1ldGhvZCA9IHZlcmIudG9VcHBlckNhc2UoKVxuICByZXR1cm4gZnVuY3Rpb24gKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB2YXIgcGFyYW1zID0gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgIHBhcmFtcy5tZXRob2QgPSBtZXRob2RcbiAgICByZXR1cm4gcmVxdWVzdChwYXJhbXMsIHBhcmFtcy5jYWxsYmFjaylcbiAgfVxufVxuXG4vLyBkZWZpbmUgbGlrZSB0aGlzIHRvIHBsZWFzZSBjb2RlaW50ZWwvaW50ZWxsaXNlbnNlIElERXNcbnJlcXVlc3QuZ2V0ID0gdmVyYkZ1bmMoJ2dldCcpXG5yZXF1ZXN0LmhlYWQgPSB2ZXJiRnVuYygnaGVhZCcpXG5yZXF1ZXN0Lm9wdGlvbnMgPSB2ZXJiRnVuYygnb3B0aW9ucycpXG5yZXF1ZXN0LnBvc3QgPSB2ZXJiRnVuYygncG9zdCcpXG5yZXF1ZXN0LnB1dCA9IHZlcmJGdW5jKCdwdXQnKVxucmVxdWVzdC5wYXRjaCA9IHZlcmJGdW5jKCdwYXRjaCcpXG5yZXF1ZXN0LmRlbCA9IHZlcmJGdW5jKCdkZWxldGUnKVxucmVxdWVzdFsnZGVsZXRlJ10gPSB2ZXJiRnVuYygnZGVsZXRlJylcblxucmVxdWVzdC5qYXIgPSBmdW5jdGlvbiAoc3RvcmUpIHtcbiAgcmV0dXJuIGNvb2tpZXMuamFyKHN0b3JlKVxufVxuXG5yZXF1ZXN0LmNvb2tpZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIGNvb2tpZXMucGFyc2Uoc3RyKVxufVxuXG5mdW5jdGlvbiB3cmFwUmVxdWVzdE1ldGhvZCAobWV0aG9kLCBvcHRpb25zLCByZXF1ZXN0ZXIsIHZlcmIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh1cmksIG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHBhcmFtcyA9IGluaXRQYXJhbXModXJpLCBvcHRzLCBjYWxsYmFjaylcblxuICAgIHZhciB0YXJnZXQgPSB7fVxuICAgIGV4dGVuZCh0cnVlLCB0YXJnZXQsIG9wdGlvbnMsIHBhcmFtcylcblxuICAgIHRhcmdldC5wb29sID0gcGFyYW1zLnBvb2wgfHwgb3B0aW9ucy5wb29sXG5cbiAgICBpZiAodmVyYikge1xuICAgICAgdGFyZ2V0Lm1ldGhvZCA9IHZlcmIudG9VcHBlckNhc2UoKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmVxdWVzdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBtZXRob2QgPSByZXF1ZXN0ZXJcbiAgICB9XG5cbiAgICByZXR1cm4gbWV0aG9kKHRhcmdldCwgdGFyZ2V0LmNhbGxiYWNrKVxuICB9XG59XG5cbnJlcXVlc3QuZGVmYXVsdHMgPSBmdW5jdGlvbiAob3B0aW9ucywgcmVxdWVzdGVyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVxdWVzdGVyID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG5cbiAgdmFyIGRlZmF1bHRzID0gd3JhcFJlcXVlc3RNZXRob2Qoc2VsZiwgb3B0aW9ucywgcmVxdWVzdGVyKVxuXG4gIHZhciB2ZXJicyA9IFsnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnZGVsJywgJ2RlbGV0ZSddXG4gIHZlcmJzLmZvckVhY2goZnVuY3Rpb24gKHZlcmIpIHtcbiAgICBkZWZhdWx0c1t2ZXJiXSA9IHdyYXBSZXF1ZXN0TWV0aG9kKHNlbGZbdmVyYl0sIG9wdGlvbnMsIHJlcXVlc3RlciwgdmVyYilcbiAgfSlcblxuICBkZWZhdWx0cy5jb29raWUgPSB3cmFwUmVxdWVzdE1ldGhvZChzZWxmLmNvb2tpZSwgb3B0aW9ucywgcmVxdWVzdGVyKVxuICBkZWZhdWx0cy5qYXIgPSBzZWxmLmphclxuICBkZWZhdWx0cy5kZWZhdWx0cyA9IHNlbGYuZGVmYXVsdHNcbiAgcmV0dXJuIGRlZmF1bHRzXG59XG5cbnJlcXVlc3QuZm9yZXZlciA9IGZ1bmN0aW9uIChhZ2VudE9wdGlvbnMsIG9wdGlvbnNBcmcpIHtcbiAgdmFyIG9wdGlvbnMgPSB7fVxuICBpZiAob3B0aW9uc0FyZykge1xuICAgIGV4dGVuZChvcHRpb25zLCBvcHRpb25zQXJnKVxuICB9XG4gIGlmIChhZ2VudE9wdGlvbnMpIHtcbiAgICBvcHRpb25zLmFnZW50T3B0aW9ucyA9IGFnZW50T3B0aW9uc1xuICB9XG5cbiAgb3B0aW9ucy5mb3JldmVyID0gdHJ1ZVxuICByZXR1cm4gcmVxdWVzdC5kZWZhdWx0cyhvcHRpb25zKVxufVxuXG4vLyBFeHBvcnRzXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWVzdFxucmVxdWVzdC5SZXF1ZXN0ID0gcmVxdWlyZSgnLi9yZXF1ZXN0JylcbnJlcXVlc3QuaW5pdFBhcmFtcyA9IGluaXRQYXJhbXNcblxuLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIHJlcXVlc3QuZGVidWdcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1ZXN0LCAnZGVidWcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZXF1ZXN0LlJlcXVlc3QuZGVidWdcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAoZGVidWcpIHtcbiAgICByZXF1ZXN0LlJlcXVlc3QuZGVidWcgPSBkZWJ1Z1xuICB9XG59KVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/request/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/request/lib/auth.js":
/*!******************************************!*\
  !*** ./node_modules/request/lib/auth.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar caseless = __webpack_require__(/*! caseless */ \"(rsc)/./node_modules/caseless/index.js\")\nvar uuid = __webpack_require__(/*! uuid/v4 */ \"(rsc)/./node_modules/request/node_modules/uuid/v4.js\")\nvar helpers = __webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/request/lib/helpers.js\")\n\nvar md5 = helpers.md5\nvar toBase64 = helpers.toBase64\n\nfunction Auth (request) {\n  // define all public properties here\n  this.request = request\n  this.hasAuth = false\n  this.sentAuth = false\n  this.bearerToken = null\n  this.user = null\n  this.pass = null\n}\n\nAuth.prototype.basic = function (user, pass, sendImmediately) {\n  var self = this\n  if (typeof user !== 'string' || (pass !== undefined && typeof pass !== 'string')) {\n    self.request.emit('error', new Error('auth() received invalid user or password'))\n  }\n  self.user = user\n  self.pass = pass\n  self.hasAuth = true\n  var header = user + ':' + (pass || '')\n  if (sendImmediately || typeof sendImmediately === 'undefined') {\n    var authHeader = 'Basic ' + toBase64(header)\n    self.sentAuth = true\n    return authHeader\n  }\n}\n\nAuth.prototype.bearer = function (bearer, sendImmediately) {\n  var self = this\n  self.bearerToken = bearer\n  self.hasAuth = true\n  if (sendImmediately || typeof sendImmediately === 'undefined') {\n    if (typeof bearer === 'function') {\n      bearer = bearer()\n    }\n    var authHeader = 'Bearer ' + (bearer || '')\n    self.sentAuth = true\n    return authHeader\n  }\n}\n\nAuth.prototype.digest = function (method, path, authHeader) {\n  // TODO: More complete implementation of RFC 2617.\n  //   - handle challenge.domain\n  //   - support qop=\"auth-int\" only\n  //   - handle Authentication-Info (not necessarily?)\n  //   - check challenge.stale (not necessarily?)\n  //   - increase nc (not necessarily?)\n  // For reference:\n  // http://tools.ietf.org/html/rfc2617#section-3\n  // https://github.com/bagder/curl/blob/master/lib/http_digest.c\n\n  var self = this\n\n  var challenge = {}\n  var re = /([a-z0-9_-]+)=(?:\"([^\"]+)\"|([a-z0-9_-]+))/gi\n  while (true) {\n    var match = re.exec(authHeader)\n    if (!match) {\n      break\n    }\n    challenge[match[1]] = match[2] || match[3]\n  }\n\n  /**\n   * RFC 2617: handle both MD5 and MD5-sess algorithms.\n   *\n   * If the algorithm directive's value is \"MD5\" or unspecified, then HA1 is\n   *   HA1=MD5(username:realm:password)\n   * If the algorithm directive's value is \"MD5-sess\", then HA1 is\n   *   HA1=MD5(MD5(username:realm:password):nonce:cnonce)\n   */\n  var ha1Compute = function (algorithm, user, realm, pass, nonce, cnonce) {\n    var ha1 = md5(user + ':' + realm + ':' + pass)\n    if (algorithm && algorithm.toLowerCase() === 'md5-sess') {\n      return md5(ha1 + ':' + nonce + ':' + cnonce)\n    } else {\n      return ha1\n    }\n  }\n\n  var qop = /(^|,)\\s*auth\\s*($|,)/.test(challenge.qop) && 'auth'\n  var nc = qop && '00000001'\n  var cnonce = qop && uuid().replace(/-/g, '')\n  var ha1 = ha1Compute(challenge.algorithm, self.user, challenge.realm, self.pass, challenge.nonce, cnonce)\n  var ha2 = md5(method + ':' + path)\n  var digestResponse = qop\n    ? md5(ha1 + ':' + challenge.nonce + ':' + nc + ':' + cnonce + ':' + qop + ':' + ha2)\n    : md5(ha1 + ':' + challenge.nonce + ':' + ha2)\n  var authValues = {\n    username: self.user,\n    realm: challenge.realm,\n    nonce: challenge.nonce,\n    uri: path,\n    qop: qop,\n    response: digestResponse,\n    nc: nc,\n    cnonce: cnonce,\n    algorithm: challenge.algorithm,\n    opaque: challenge.opaque\n  }\n\n  authHeader = []\n  for (var k in authValues) {\n    if (authValues[k]) {\n      if (k === 'qop' || k === 'nc' || k === 'algorithm') {\n        authHeader.push(k + '=' + authValues[k])\n      } else {\n        authHeader.push(k + '=\"' + authValues[k] + '\"')\n      }\n    }\n  }\n  authHeader = 'Digest ' + authHeader.join(', ')\n  self.sentAuth = true\n  return authHeader\n}\n\nAuth.prototype.onRequest = function (user, pass, sendImmediately, bearer) {\n  var self = this\n  var request = self.request\n\n  var authHeader\n  if (bearer === undefined && user === undefined) {\n    self.request.emit('error', new Error('no auth mechanism defined'))\n  } else if (bearer !== undefined) {\n    authHeader = self.bearer(bearer, sendImmediately)\n  } else {\n    authHeader = self.basic(user, pass, sendImmediately)\n  }\n  if (authHeader) {\n    request.setHeader('authorization', authHeader)\n  }\n}\n\nAuth.prototype.onResponse = function (response) {\n  var self = this\n  var request = self.request\n\n  if (!self.hasAuth || self.sentAuth) { return null }\n\n  var c = caseless(response.headers)\n\n  var authHeader = c.get('www-authenticate')\n  var authVerb = authHeader && authHeader.split(' ')[0].toLowerCase()\n  request.debug('reauth', authVerb)\n\n  switch (authVerb) {\n    case 'basic':\n      return self.basic(self.user, self.pass, true)\n\n    case 'bearer':\n      return self.bearer(self.bearerToken, true)\n\n    case 'digest':\n      return self.digest(request.method, request.path, authHeader)\n  }\n}\n\nexports.Auth = Auth\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvYXV0aC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsd0RBQVU7QUFDakMsV0FBVyxtQkFBTyxDQUFDLHFFQUFTO0FBQzVCLGNBQWMsbUJBQU8sQ0FBQyw4REFBVzs7QUFFakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7O0FBRXhDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGFnZS1mb3JtLy4vbm9kZV9tb2R1bGVzL3JlcXVlc3QvbGliL2F1dGguanM/MjM5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxudmFyIGNhc2VsZXNzID0gcmVxdWlyZSgnY2FzZWxlc3MnKVxudmFyIHV1aWQgPSByZXF1aXJlKCd1dWlkL3Y0JylcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJylcblxudmFyIG1kNSA9IGhlbHBlcnMubWQ1XG52YXIgdG9CYXNlNjQgPSBoZWxwZXJzLnRvQmFzZTY0XG5cbmZ1bmN0aW9uIEF1dGggKHJlcXVlc3QpIHtcbiAgLy8gZGVmaW5lIGFsbCBwdWJsaWMgcHJvcGVydGllcyBoZXJlXG4gIHRoaXMucmVxdWVzdCA9IHJlcXVlc3RcbiAgdGhpcy5oYXNBdXRoID0gZmFsc2VcbiAgdGhpcy5zZW50QXV0aCA9IGZhbHNlXG4gIHRoaXMuYmVhcmVyVG9rZW4gPSBudWxsXG4gIHRoaXMudXNlciA9IG51bGxcbiAgdGhpcy5wYXNzID0gbnVsbFxufVxuXG5BdXRoLnByb3RvdHlwZS5iYXNpYyA9IGZ1bmN0aW9uICh1c2VyLCBwYXNzLCBzZW5kSW1tZWRpYXRlbHkpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICh0eXBlb2YgdXNlciAhPT0gJ3N0cmluZycgfHwgKHBhc3MgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcGFzcyAhPT0gJ3N0cmluZycpKSB7XG4gICAgc2VsZi5yZXF1ZXN0LmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdhdXRoKCkgcmVjZWl2ZWQgaW52YWxpZCB1c2VyIG9yIHBhc3N3b3JkJykpXG4gIH1cbiAgc2VsZi51c2VyID0gdXNlclxuICBzZWxmLnBhc3MgPSBwYXNzXG4gIHNlbGYuaGFzQXV0aCA9IHRydWVcbiAgdmFyIGhlYWRlciA9IHVzZXIgKyAnOicgKyAocGFzcyB8fCAnJylcbiAgaWYgKHNlbmRJbW1lZGlhdGVseSB8fCB0eXBlb2Ygc2VuZEltbWVkaWF0ZWx5ID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBhdXRoSGVhZGVyID0gJ0Jhc2ljICcgKyB0b0Jhc2U2NChoZWFkZXIpXG4gICAgc2VsZi5zZW50QXV0aCA9IHRydWVcbiAgICByZXR1cm4gYXV0aEhlYWRlclxuICB9XG59XG5cbkF1dGgucHJvdG90eXBlLmJlYXJlciA9IGZ1bmN0aW9uIChiZWFyZXIsIHNlbmRJbW1lZGlhdGVseSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5iZWFyZXJUb2tlbiA9IGJlYXJlclxuICBzZWxmLmhhc0F1dGggPSB0cnVlXG4gIGlmIChzZW5kSW1tZWRpYXRlbHkgfHwgdHlwZW9mIHNlbmRJbW1lZGlhdGVseSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIGJlYXJlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYmVhcmVyID0gYmVhcmVyKClcbiAgICB9XG4gICAgdmFyIGF1dGhIZWFkZXIgPSAnQmVhcmVyICcgKyAoYmVhcmVyIHx8ICcnKVxuICAgIHNlbGYuc2VudEF1dGggPSB0cnVlXG4gICAgcmV0dXJuIGF1dGhIZWFkZXJcbiAgfVxufVxuXG5BdXRoLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAobWV0aG9kLCBwYXRoLCBhdXRoSGVhZGVyKSB7XG4gIC8vIFRPRE86IE1vcmUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgUkZDIDI2MTcuXG4gIC8vICAgLSBoYW5kbGUgY2hhbGxlbmdlLmRvbWFpblxuICAvLyAgIC0gc3VwcG9ydCBxb3A9XCJhdXRoLWludFwiIG9ubHlcbiAgLy8gICAtIGhhbmRsZSBBdXRoZW50aWNhdGlvbi1JbmZvIChub3QgbmVjZXNzYXJpbHk/KVxuICAvLyAgIC0gY2hlY2sgY2hhbGxlbmdlLnN0YWxlIChub3QgbmVjZXNzYXJpbHk/KVxuICAvLyAgIC0gaW5jcmVhc2UgbmMgKG5vdCBuZWNlc3NhcmlseT8pXG4gIC8vIEZvciByZWZlcmVuY2U6XG4gIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI2MTcjc2VjdGlvbi0zXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iYWdkZXIvY3VybC9ibG9iL21hc3Rlci9saWIvaHR0cF9kaWdlc3QuY1xuXG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHZhciBjaGFsbGVuZ2UgPSB7fVxuICB2YXIgcmUgPSAvKFthLXowLTlfLV0rKT0oPzpcIihbXlwiXSspXCJ8KFthLXowLTlfLV0rKSkvZ2lcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbWF0Y2ggPSByZS5leGVjKGF1dGhIZWFkZXIpXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2hhbGxlbmdlW21hdGNoWzFdXSA9IG1hdGNoWzJdIHx8IG1hdGNoWzNdXG4gIH1cblxuICAvKipcbiAgICogUkZDIDI2MTc6IGhhbmRsZSBib3RoIE1ENSBhbmQgTUQ1LXNlc3MgYWxnb3JpdGhtcy5cbiAgICpcbiAgICogSWYgdGhlIGFsZ29yaXRobSBkaXJlY3RpdmUncyB2YWx1ZSBpcyBcIk1ENVwiIG9yIHVuc3BlY2lmaWVkLCB0aGVuIEhBMSBpc1xuICAgKiAgIEhBMT1NRDUodXNlcm5hbWU6cmVhbG06cGFzc3dvcmQpXG4gICAqIElmIHRoZSBhbGdvcml0aG0gZGlyZWN0aXZlJ3MgdmFsdWUgaXMgXCJNRDUtc2Vzc1wiLCB0aGVuIEhBMSBpc1xuICAgKiAgIEhBMT1NRDUoTUQ1KHVzZXJuYW1lOnJlYWxtOnBhc3N3b3JkKTpub25jZTpjbm9uY2UpXG4gICAqL1xuICB2YXIgaGExQ29tcHV0ZSA9IGZ1bmN0aW9uIChhbGdvcml0aG0sIHVzZXIsIHJlYWxtLCBwYXNzLCBub25jZSwgY25vbmNlKSB7XG4gICAgdmFyIGhhMSA9IG1kNSh1c2VyICsgJzonICsgcmVhbG0gKyAnOicgKyBwYXNzKVxuICAgIGlmIChhbGdvcml0aG0gJiYgYWxnb3JpdGhtLnRvTG93ZXJDYXNlKCkgPT09ICdtZDUtc2VzcycpIHtcbiAgICAgIHJldHVybiBtZDUoaGExICsgJzonICsgbm9uY2UgKyAnOicgKyBjbm9uY2UpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBoYTFcbiAgICB9XG4gIH1cblxuICB2YXIgcW9wID0gLyhefCwpXFxzKmF1dGhcXHMqKCR8LCkvLnRlc3QoY2hhbGxlbmdlLnFvcCkgJiYgJ2F1dGgnXG4gIHZhciBuYyA9IHFvcCAmJiAnMDAwMDAwMDEnXG4gIHZhciBjbm9uY2UgPSBxb3AgJiYgdXVpZCgpLnJlcGxhY2UoLy0vZywgJycpXG4gIHZhciBoYTEgPSBoYTFDb21wdXRlKGNoYWxsZW5nZS5hbGdvcml0aG0sIHNlbGYudXNlciwgY2hhbGxlbmdlLnJlYWxtLCBzZWxmLnBhc3MsIGNoYWxsZW5nZS5ub25jZSwgY25vbmNlKVxuICB2YXIgaGEyID0gbWQ1KG1ldGhvZCArICc6JyArIHBhdGgpXG4gIHZhciBkaWdlc3RSZXNwb25zZSA9IHFvcFxuICAgID8gbWQ1KGhhMSArICc6JyArIGNoYWxsZW5nZS5ub25jZSArICc6JyArIG5jICsgJzonICsgY25vbmNlICsgJzonICsgcW9wICsgJzonICsgaGEyKVxuICAgIDogbWQ1KGhhMSArICc6JyArIGNoYWxsZW5nZS5ub25jZSArICc6JyArIGhhMilcbiAgdmFyIGF1dGhWYWx1ZXMgPSB7XG4gICAgdXNlcm5hbWU6IHNlbGYudXNlcixcbiAgICByZWFsbTogY2hhbGxlbmdlLnJlYWxtLFxuICAgIG5vbmNlOiBjaGFsbGVuZ2Uubm9uY2UsXG4gICAgdXJpOiBwYXRoLFxuICAgIHFvcDogcW9wLFxuICAgIHJlc3BvbnNlOiBkaWdlc3RSZXNwb25zZSxcbiAgICBuYzogbmMsXG4gICAgY25vbmNlOiBjbm9uY2UsXG4gICAgYWxnb3JpdGhtOiBjaGFsbGVuZ2UuYWxnb3JpdGhtLFxuICAgIG9wYXF1ZTogY2hhbGxlbmdlLm9wYXF1ZVxuICB9XG5cbiAgYXV0aEhlYWRlciA9IFtdXG4gIGZvciAodmFyIGsgaW4gYXV0aFZhbHVlcykge1xuICAgIGlmIChhdXRoVmFsdWVzW2tdKSB7XG4gICAgICBpZiAoayA9PT0gJ3FvcCcgfHwgayA9PT0gJ25jJyB8fCBrID09PSAnYWxnb3JpdGhtJykge1xuICAgICAgICBhdXRoSGVhZGVyLnB1c2goayArICc9JyArIGF1dGhWYWx1ZXNba10pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdXRoSGVhZGVyLnB1c2goayArICc9XCInICsgYXV0aFZhbHVlc1trXSArICdcIicpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGF1dGhIZWFkZXIgPSAnRGlnZXN0ICcgKyBhdXRoSGVhZGVyLmpvaW4oJywgJylcbiAgc2VsZi5zZW50QXV0aCA9IHRydWVcbiAgcmV0dXJuIGF1dGhIZWFkZXJcbn1cblxuQXV0aC5wcm90b3R5cGUub25SZXF1ZXN0ID0gZnVuY3Rpb24gKHVzZXIsIHBhc3MsIHNlbmRJbW1lZGlhdGVseSwgYmVhcmVyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgcmVxdWVzdCA9IHNlbGYucmVxdWVzdFxuXG4gIHZhciBhdXRoSGVhZGVyXG4gIGlmIChiZWFyZXIgPT09IHVuZGVmaW5lZCAmJiB1c2VyID09PSB1bmRlZmluZWQpIHtcbiAgICBzZWxmLnJlcXVlc3QuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIGF1dGggbWVjaGFuaXNtIGRlZmluZWQnKSlcbiAgfSBlbHNlIGlmIChiZWFyZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIGF1dGhIZWFkZXIgPSBzZWxmLmJlYXJlcihiZWFyZXIsIHNlbmRJbW1lZGlhdGVseSlcbiAgfSBlbHNlIHtcbiAgICBhdXRoSGVhZGVyID0gc2VsZi5iYXNpYyh1c2VyLCBwYXNzLCBzZW5kSW1tZWRpYXRlbHkpXG4gIH1cbiAgaWYgKGF1dGhIZWFkZXIpIHtcbiAgICByZXF1ZXN0LnNldEhlYWRlcignYXV0aG9yaXphdGlvbicsIGF1dGhIZWFkZXIpXG4gIH1cbn1cblxuQXV0aC5wcm90b3R5cGUub25SZXNwb25zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHJlcXVlc3QgPSBzZWxmLnJlcXVlc3RcblxuICBpZiAoIXNlbGYuaGFzQXV0aCB8fCBzZWxmLnNlbnRBdXRoKSB7IHJldHVybiBudWxsIH1cblxuICB2YXIgYyA9IGNhc2VsZXNzKHJlc3BvbnNlLmhlYWRlcnMpXG5cbiAgdmFyIGF1dGhIZWFkZXIgPSBjLmdldCgnd3d3LWF1dGhlbnRpY2F0ZScpXG4gIHZhciBhdXRoVmVyYiA9IGF1dGhIZWFkZXIgJiYgYXV0aEhlYWRlci5zcGxpdCgnICcpWzBdLnRvTG93ZXJDYXNlKClcbiAgcmVxdWVzdC5kZWJ1ZygncmVhdXRoJywgYXV0aFZlcmIpXG5cbiAgc3dpdGNoIChhdXRoVmVyYikge1xuICAgIGNhc2UgJ2Jhc2ljJzpcbiAgICAgIHJldHVybiBzZWxmLmJhc2ljKHNlbGYudXNlciwgc2VsZi5wYXNzLCB0cnVlKVxuXG4gICAgY2FzZSAnYmVhcmVyJzpcbiAgICAgIHJldHVybiBzZWxmLmJlYXJlcihzZWxmLmJlYXJlclRva2VuLCB0cnVlKVxuXG4gICAgY2FzZSAnZGlnZXN0JzpcbiAgICAgIHJldHVybiBzZWxmLmRpZ2VzdChyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC5wYXRoLCBhdXRoSGVhZGVyKVxuICB9XG59XG5cbmV4cG9ydHMuQXV0aCA9IEF1dGhcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/request/lib/auth.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/request/lib/cookies.js":
/*!*********************************************!*\
  !*** ./node_modules/request/lib/cookies.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar tough = __webpack_require__(/*! tough-cookie */ \"(rsc)/./node_modules/request/node_modules/tough-cookie/lib/cookie.js\")\n\nvar Cookie = tough.Cookie\nvar CookieJar = tough.CookieJar\n\nexports.parse = function (str) {\n  if (str && str.uri) {\n    str = str.uri\n  }\n  if (typeof str !== 'string') {\n    throw new Error('The cookie function only accepts STRING as param')\n  }\n  return Cookie.parse(str, {loose: true})\n}\n\n// Adapt the sometimes-Async api of tough.CookieJar to our requirements\nfunction RequestJar (store) {\n  var self = this\n  self._jar = new CookieJar(store, {looseMode: true})\n}\nRequestJar.prototype.setCookie = function (cookieOrStr, uri, options) {\n  var self = this\n  return self._jar.setCookieSync(cookieOrStr, uri, options || {})\n}\nRequestJar.prototype.getCookieString = function (uri) {\n  var self = this\n  return self._jar.getCookieStringSync(uri)\n}\nRequestJar.prototype.getCookies = function (uri) {\n  var self = this\n  return self._jar.getCookiesSync(uri)\n}\n\nexports.jar = function (store) {\n  return new RequestJar(store)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvY29va2llcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixZQUFZLG1CQUFPLENBQUMsMEZBQWM7O0FBRWxDO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BhZ2UtZm9ybS8uL25vZGVfbW9kdWxlcy9yZXF1ZXN0L2xpYi9jb29raWVzLmpzP2YyYjMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbnZhciB0b3VnaCA9IHJlcXVpcmUoJ3RvdWdoLWNvb2tpZScpXG5cbnZhciBDb29raWUgPSB0b3VnaC5Db29raWVcbnZhciBDb29raWVKYXIgPSB0b3VnaC5Db29raWVKYXJcblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgaWYgKHN0ciAmJiBzdHIudXJpKSB7XG4gICAgc3RyID0gc3RyLnVyaVxuICB9XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNvb2tpZSBmdW5jdGlvbiBvbmx5IGFjY2VwdHMgU1RSSU5HIGFzIHBhcmFtJylcbiAgfVxuICByZXR1cm4gQ29va2llLnBhcnNlKHN0ciwge2xvb3NlOiB0cnVlfSlcbn1cblxuLy8gQWRhcHQgdGhlIHNvbWV0aW1lcy1Bc3luYyBhcGkgb2YgdG91Z2guQ29va2llSmFyIHRvIG91ciByZXF1aXJlbWVudHNcbmZ1bmN0aW9uIFJlcXVlc3RKYXIgKHN0b3JlKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLl9qYXIgPSBuZXcgQ29va2llSmFyKHN0b3JlLCB7bG9vc2VNb2RlOiB0cnVlfSlcbn1cblJlcXVlc3RKYXIucHJvdG90eXBlLnNldENvb2tpZSA9IGZ1bmN0aW9uIChjb29raWVPclN0ciwgdXJpLCBvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICByZXR1cm4gc2VsZi5famFyLnNldENvb2tpZVN5bmMoY29va2llT3JTdHIsIHVyaSwgb3B0aW9ucyB8fCB7fSlcbn1cblJlcXVlc3RKYXIucHJvdG90eXBlLmdldENvb2tpZVN0cmluZyA9IGZ1bmN0aW9uICh1cmkpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHJldHVybiBzZWxmLl9qYXIuZ2V0Q29va2llU3RyaW5nU3luYyh1cmkpXG59XG5SZXF1ZXN0SmFyLnByb3RvdHlwZS5nZXRDb29raWVzID0gZnVuY3Rpb24gKHVyaSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgcmV0dXJuIHNlbGYuX2phci5nZXRDb29raWVzU3luYyh1cmkpXG59XG5cbmV4cG9ydHMuamFyID0gZnVuY3Rpb24gKHN0b3JlKSB7XG4gIHJldHVybiBuZXcgUmVxdWVzdEphcihzdG9yZSlcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/request/lib/cookies.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/request/lib/getProxyFromURI.js":
/*!*****************************************************!*\
  !*** ./node_modules/request/lib/getProxyFromURI.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction formatHostname (hostname) {\n  // canonicalize the hostname, so that 'oogle.com' won't match 'google.com'\n  return hostname.replace(/^\\.*/, '.').toLowerCase()\n}\n\nfunction parseNoProxyZone (zone) {\n  zone = zone.trim().toLowerCase()\n\n  var zoneParts = zone.split(':', 2)\n  var zoneHost = formatHostname(zoneParts[0])\n  var zonePort = zoneParts[1]\n  var hasPort = zone.indexOf(':') > -1\n\n  return {hostname: zoneHost, port: zonePort, hasPort: hasPort}\n}\n\nfunction uriInNoProxy (uri, noProxy) {\n  var port = uri.port || (uri.protocol === 'https:' ? '443' : '80')\n  var hostname = formatHostname(uri.hostname)\n  var noProxyList = noProxy.split(',')\n\n  // iterate through the noProxyList until it finds a match.\n  return noProxyList.map(parseNoProxyZone).some(function (noProxyZone) {\n    var isMatchedAt = hostname.indexOf(noProxyZone.hostname)\n    var hostnameMatched = (\n      isMatchedAt > -1 &&\n        (isMatchedAt === hostname.length - noProxyZone.hostname.length)\n    )\n\n    if (noProxyZone.hasPort) {\n      return (port === noProxyZone.port) && hostnameMatched\n    }\n\n    return hostnameMatched\n  })\n}\n\nfunction getProxyFromURI (uri) {\n  // Decide the proper request proxy to use based on the request URI object and the\n  // environmental variables (NO_PROXY, HTTP_PROXY, etc.)\n  // respect NO_PROXY environment variables (see: https://lynx.invisible-island.net/lynx2.8.7/breakout/lynx_help/keystrokes/environments.html)\n\n  var noProxy = process.env.NO_PROXY || process.env.no_proxy || ''\n\n  // if the noProxy is a wildcard then return null\n\n  if (noProxy === '*') {\n    return null\n  }\n\n  // if the noProxy is not empty and the uri is found return null\n\n  if (noProxy !== '' && uriInNoProxy(uri, noProxy)) {\n    return null\n  }\n\n  // Check for HTTP or HTTPS Proxy in environment Else default to null\n\n  if (uri.protocol === 'http:') {\n    return process.env.HTTP_PROXY ||\n      process.env.http_proxy || null\n  }\n\n  if (uri.protocol === 'https:') {\n    return process.env.HTTPS_PROXY ||\n      process.env.https_proxy ||\n      process.env.HTTP_PROXY ||\n      process.env.http_proxy || null\n  }\n\n  // if none of that works, return null\n  // (What uri protocol are you using then?)\n\n  return null\n}\n\nmodule.exports = getProxyFromURI\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvZ2V0UHJveHlGcm9tVVJJLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYWdlLWZvcm0vLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvZ2V0UHJveHlGcm9tVVJJLmpzPzVlYmIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmZ1bmN0aW9uIGZvcm1hdEhvc3RuYW1lIChob3N0bmFtZSkge1xuICAvLyBjYW5vbmljYWxpemUgdGhlIGhvc3RuYW1lLCBzbyB0aGF0ICdvb2dsZS5jb20nIHdvbid0IG1hdGNoICdnb29nbGUuY29tJ1xuICByZXR1cm4gaG9zdG5hbWUucmVwbGFjZSgvXlxcLiovLCAnLicpLnRvTG93ZXJDYXNlKClcbn1cblxuZnVuY3Rpb24gcGFyc2VOb1Byb3h5Wm9uZSAoem9uZSkge1xuICB6b25lID0gem9uZS50cmltKCkudG9Mb3dlckNhc2UoKVxuXG4gIHZhciB6b25lUGFydHMgPSB6b25lLnNwbGl0KCc6JywgMilcbiAgdmFyIHpvbmVIb3N0ID0gZm9ybWF0SG9zdG5hbWUoem9uZVBhcnRzWzBdKVxuICB2YXIgem9uZVBvcnQgPSB6b25lUGFydHNbMV1cbiAgdmFyIGhhc1BvcnQgPSB6b25lLmluZGV4T2YoJzonKSA+IC0xXG5cbiAgcmV0dXJuIHtob3N0bmFtZTogem9uZUhvc3QsIHBvcnQ6IHpvbmVQb3J0LCBoYXNQb3J0OiBoYXNQb3J0fVxufVxuXG5mdW5jdGlvbiB1cmlJbk5vUHJveHkgKHVyaSwgbm9Qcm94eSkge1xuICB2YXIgcG9ydCA9IHVyaS5wb3J0IHx8ICh1cmkucHJvdG9jb2wgPT09ICdodHRwczonID8gJzQ0MycgOiAnODAnKVxuICB2YXIgaG9zdG5hbWUgPSBmb3JtYXRIb3N0bmFtZSh1cmkuaG9zdG5hbWUpXG4gIHZhciBub1Byb3h5TGlzdCA9IG5vUHJveHkuc3BsaXQoJywnKVxuXG4gIC8vIGl0ZXJhdGUgdGhyb3VnaCB0aGUgbm9Qcm94eUxpc3QgdW50aWwgaXQgZmluZHMgYSBtYXRjaC5cbiAgcmV0dXJuIG5vUHJveHlMaXN0Lm1hcChwYXJzZU5vUHJveHlab25lKS5zb21lKGZ1bmN0aW9uIChub1Byb3h5Wm9uZSkge1xuICAgIHZhciBpc01hdGNoZWRBdCA9IGhvc3RuYW1lLmluZGV4T2Yobm9Qcm94eVpvbmUuaG9zdG5hbWUpXG4gICAgdmFyIGhvc3RuYW1lTWF0Y2hlZCA9IChcbiAgICAgIGlzTWF0Y2hlZEF0ID4gLTEgJiZcbiAgICAgICAgKGlzTWF0Y2hlZEF0ID09PSBob3N0bmFtZS5sZW5ndGggLSBub1Byb3h5Wm9uZS5ob3N0bmFtZS5sZW5ndGgpXG4gICAgKVxuXG4gICAgaWYgKG5vUHJveHlab25lLmhhc1BvcnQpIHtcbiAgICAgIHJldHVybiAocG9ydCA9PT0gbm9Qcm94eVpvbmUucG9ydCkgJiYgaG9zdG5hbWVNYXRjaGVkXG4gICAgfVxuXG4gICAgcmV0dXJuIGhvc3RuYW1lTWF0Y2hlZFxuICB9KVxufVxuXG5mdW5jdGlvbiBnZXRQcm94eUZyb21VUkkgKHVyaSkge1xuICAvLyBEZWNpZGUgdGhlIHByb3BlciByZXF1ZXN0IHByb3h5IHRvIHVzZSBiYXNlZCBvbiB0aGUgcmVxdWVzdCBVUkkgb2JqZWN0IGFuZCB0aGVcbiAgLy8gZW52aXJvbm1lbnRhbCB2YXJpYWJsZXMgKE5PX1BST1hZLCBIVFRQX1BST1hZLCBldGMuKVxuICAvLyByZXNwZWN0IE5PX1BST1hZIGVudmlyb25tZW50IHZhcmlhYmxlcyAoc2VlOiBodHRwczovL2x5bnguaW52aXNpYmxlLWlzbGFuZC5uZXQvbHlueDIuOC43L2JyZWFrb3V0L2x5bnhfaGVscC9rZXlzdHJva2VzL2Vudmlyb25tZW50cy5odG1sKVxuXG4gIHZhciBub1Byb3h5ID0gcHJvY2Vzcy5lbnYuTk9fUFJPWFkgfHwgcHJvY2Vzcy5lbnYubm9fcHJveHkgfHwgJydcblxuICAvLyBpZiB0aGUgbm9Qcm94eSBpcyBhIHdpbGRjYXJkIHRoZW4gcmV0dXJuIG51bGxcblxuICBpZiAobm9Qcm94eSA9PT0gJyonKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIGlmIHRoZSBub1Byb3h5IGlzIG5vdCBlbXB0eSBhbmQgdGhlIHVyaSBpcyBmb3VuZCByZXR1cm4gbnVsbFxuXG4gIGlmIChub1Byb3h5ICE9PSAnJyAmJiB1cmlJbk5vUHJveHkodXJpLCBub1Byb3h5KSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyBDaGVjayBmb3IgSFRUUCBvciBIVFRQUyBQcm94eSBpbiBlbnZpcm9ubWVudCBFbHNlIGRlZmF1bHQgdG8gbnVsbFxuXG4gIGlmICh1cmkucHJvdG9jb2wgPT09ICdodHRwOicpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuSFRUUF9QUk9YWSB8fFxuICAgICAgcHJvY2Vzcy5lbnYuaHR0cF9wcm94eSB8fCBudWxsXG4gIH1cblxuICBpZiAodXJpLnByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5IVFRQU19QUk9YWSB8fFxuICAgICAgcHJvY2Vzcy5lbnYuaHR0cHNfcHJveHkgfHxcbiAgICAgIHByb2Nlc3MuZW52LkhUVFBfUFJPWFkgfHxcbiAgICAgIHByb2Nlc3MuZW52Lmh0dHBfcHJveHkgfHwgbnVsbFxuICB9XG5cbiAgLy8gaWYgbm9uZSBvZiB0aGF0IHdvcmtzLCByZXR1cm4gbnVsbFxuICAvLyAoV2hhdCB1cmkgcHJvdG9jb2wgYXJlIHlvdSB1c2luZyB0aGVuPylcblxuICByZXR1cm4gbnVsbFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3h5RnJvbVVSSVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/request/lib/getProxyFromURI.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/request/lib/har.js":
/*!*****************************************!*\
  !*** ./node_modules/request/lib/har.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar fs = __webpack_require__(/*! fs */ \"fs\")\nvar qs = __webpack_require__(/*! querystring */ \"querystring\")\nvar validate = __webpack_require__(/*! har-validator */ \"(rsc)/./node_modules/har-validator/lib/promise.js\")\nvar extend = __webpack_require__(/*! extend */ \"(rsc)/./node_modules/extend/index.js\")\n\nfunction Har (request) {\n  this.request = request\n}\n\nHar.prototype.reducer = function (obj, pair) {\n  // new property ?\n  if (obj[pair.name] === undefined) {\n    obj[pair.name] = pair.value\n    return obj\n  }\n\n  // existing? convert to array\n  var arr = [\n    obj[pair.name],\n    pair.value\n  ]\n\n  obj[pair.name] = arr\n\n  return obj\n}\n\nHar.prototype.prep = function (data) {\n  // construct utility properties\n  data.queryObj = {}\n  data.headersObj = {}\n  data.postData.jsonObj = false\n  data.postData.paramsObj = false\n\n  // construct query objects\n  if (data.queryString && data.queryString.length) {\n    data.queryObj = data.queryString.reduce(this.reducer, {})\n  }\n\n  // construct headers objects\n  if (data.headers && data.headers.length) {\n    // loweCase header keys\n    data.headersObj = data.headers.reduceRight(function (headers, header) {\n      headers[header.name] = header.value\n      return headers\n    }, {})\n  }\n\n  // construct Cookie header\n  if (data.cookies && data.cookies.length) {\n    var cookies = data.cookies.map(function (cookie) {\n      return cookie.name + '=' + cookie.value\n    })\n\n    if (cookies.length) {\n      data.headersObj.cookie = cookies.join('; ')\n    }\n  }\n\n  // prep body\n  function some (arr) {\n    return arr.some(function (type) {\n      return data.postData.mimeType.indexOf(type) === 0\n    })\n  }\n\n  if (some([\n    'multipart/mixed',\n    'multipart/related',\n    'multipart/form-data',\n    'multipart/alternative'])) {\n    // reset values\n    data.postData.mimeType = 'multipart/form-data'\n  } else if (some([\n    'application/x-www-form-urlencoded'])) {\n    if (!data.postData.params) {\n      data.postData.text = ''\n    } else {\n      data.postData.paramsObj = data.postData.params.reduce(this.reducer, {})\n\n      // always overwrite\n      data.postData.text = qs.stringify(data.postData.paramsObj)\n    }\n  } else if (some([\n    'text/json',\n    'text/x-json',\n    'application/json',\n    'application/x-json'])) {\n    data.postData.mimeType = 'application/json'\n\n    if (data.postData.text) {\n      try {\n        data.postData.jsonObj = JSON.parse(data.postData.text)\n      } catch (e) {\n        this.request.debug(e)\n\n        // force back to text/plain\n        data.postData.mimeType = 'text/plain'\n      }\n    }\n  }\n\n  return data\n}\n\nHar.prototype.options = function (options) {\n  // skip if no har property defined\n  if (!options.har) {\n    return options\n  }\n\n  var har = {}\n  extend(har, options.har)\n\n  // only process the first entry\n  if (har.log && har.log.entries) {\n    har = har.log.entries[0]\n  }\n\n  // add optional properties to make validation successful\n  har.url = har.url || options.url || options.uri || options.baseUrl || '/'\n  har.httpVersion = har.httpVersion || 'HTTP/1.1'\n  har.queryString = har.queryString || []\n  har.headers = har.headers || []\n  har.cookies = har.cookies || []\n  har.postData = har.postData || {}\n  har.postData.mimeType = har.postData.mimeType || 'application/octet-stream'\n\n  har.bodySize = 0\n  har.headersSize = 0\n  har.postData.size = 0\n\n  if (!validate.request(har)) {\n    return options\n  }\n\n  // clean up and get some utility properties\n  var req = this.prep(har)\n\n  // construct new options\n  if (req.url) {\n    options.url = req.url\n  }\n\n  if (req.method) {\n    options.method = req.method\n  }\n\n  if (Object.keys(req.queryObj).length) {\n    options.qs = req.queryObj\n  }\n\n  if (Object.keys(req.headersObj).length) {\n    options.headers = req.headersObj\n  }\n\n  function test (type) {\n    return req.postData.mimeType.indexOf(type) === 0\n  }\n  if (test('application/x-www-form-urlencoded')) {\n    options.form = req.postData.paramsObj\n  } else if (test('application/json')) {\n    if (req.postData.jsonObj) {\n      options.body = req.postData.jsonObj\n      options.json = true\n    }\n  } else if (test('multipart/form-data')) {\n    options.formData = {}\n\n    req.postData.params.forEach(function (param) {\n      var attachment = {}\n\n      if (!param.fileName && !param.contentType) {\n        options.formData[param.name] = param.value\n        return\n      }\n\n      // attempt to read from disk!\n      if (param.fileName && !param.value) {\n        attachment.value = fs.createReadStream(param.fileName)\n      } else if (param.value) {\n        attachment.value = param.value\n      }\n\n      if (param.fileName) {\n        attachment.options = {\n          filename: param.fileName,\n          contentType: param.contentType ? param.contentType : null\n        }\n      }\n\n      options.formData[param.name] = attachment\n    })\n  } else {\n    if (req.postData.text) {\n      options.body = req.postData.text\n    }\n  }\n\n  return options\n}\n\nexports.Har = Har\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvaGFyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFNBQVMsbUJBQU8sQ0FBQyxjQUFJO0FBQ3JCLFNBQVMsbUJBQU8sQ0FBQyxnQ0FBYTtBQUM5QixlQUFlLG1CQUFPLENBQUMsd0VBQWU7QUFDdEMsYUFBYSxtQkFBTyxDQUFDLG9EQUFROztBQUU3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNEVBQTRFOztBQUU1RTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFdBQVciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYWdlLWZvcm0vLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvaGFyLmpzPzU0ZTUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcbnZhciBxcyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJylcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJ2hhci12YWxpZGF0b3InKVxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ2V4dGVuZCcpXG5cbmZ1bmN0aW9uIEhhciAocmVxdWVzdCkge1xuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0XG59XG5cbkhhci5wcm90b3R5cGUucmVkdWNlciA9IGZ1bmN0aW9uIChvYmosIHBhaXIpIHtcbiAgLy8gbmV3IHByb3BlcnR5ID9cbiAgaWYgKG9ialtwYWlyLm5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICBvYmpbcGFpci5uYW1lXSA9IHBhaXIudmFsdWVcbiAgICByZXR1cm4gb2JqXG4gIH1cblxuICAvLyBleGlzdGluZz8gY29udmVydCB0byBhcnJheVxuICB2YXIgYXJyID0gW1xuICAgIG9ialtwYWlyLm5hbWVdLFxuICAgIHBhaXIudmFsdWVcbiAgXVxuXG4gIG9ialtwYWlyLm5hbWVdID0gYXJyXG5cbiAgcmV0dXJuIG9ialxufVxuXG5IYXIucHJvdG90eXBlLnByZXAgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAvLyBjb25zdHJ1Y3QgdXRpbGl0eSBwcm9wZXJ0aWVzXG4gIGRhdGEucXVlcnlPYmogPSB7fVxuICBkYXRhLmhlYWRlcnNPYmogPSB7fVxuICBkYXRhLnBvc3REYXRhLmpzb25PYmogPSBmYWxzZVxuICBkYXRhLnBvc3REYXRhLnBhcmFtc09iaiA9IGZhbHNlXG5cbiAgLy8gY29uc3RydWN0IHF1ZXJ5IG9iamVjdHNcbiAgaWYgKGRhdGEucXVlcnlTdHJpbmcgJiYgZGF0YS5xdWVyeVN0cmluZy5sZW5ndGgpIHtcbiAgICBkYXRhLnF1ZXJ5T2JqID0gZGF0YS5xdWVyeVN0cmluZy5yZWR1Y2UodGhpcy5yZWR1Y2VyLCB7fSlcbiAgfVxuXG4gIC8vIGNvbnN0cnVjdCBoZWFkZXJzIG9iamVjdHNcbiAgaWYgKGRhdGEuaGVhZGVycyAmJiBkYXRhLmhlYWRlcnMubGVuZ3RoKSB7XG4gICAgLy8gbG93ZUNhc2UgaGVhZGVyIGtleXNcbiAgICBkYXRhLmhlYWRlcnNPYmogPSBkYXRhLmhlYWRlcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24gKGhlYWRlcnMsIGhlYWRlcikge1xuICAgICAgaGVhZGVyc1toZWFkZXIubmFtZV0gPSBoZWFkZXIudmFsdWVcbiAgICAgIHJldHVybiBoZWFkZXJzXG4gICAgfSwge30pXG4gIH1cblxuICAvLyBjb25zdHJ1Y3QgQ29va2llIGhlYWRlclxuICBpZiAoZGF0YS5jb29raWVzICYmIGRhdGEuY29va2llcy5sZW5ndGgpIHtcbiAgICB2YXIgY29va2llcyA9IGRhdGEuY29va2llcy5tYXAoZnVuY3Rpb24gKGNvb2tpZSkge1xuICAgICAgcmV0dXJuIGNvb2tpZS5uYW1lICsgJz0nICsgY29va2llLnZhbHVlXG4gICAgfSlcblxuICAgIGlmIChjb29raWVzLmxlbmd0aCkge1xuICAgICAgZGF0YS5oZWFkZXJzT2JqLmNvb2tpZSA9IGNvb2tpZXMuam9pbignOyAnKVxuICAgIH1cbiAgfVxuXG4gIC8vIHByZXAgYm9keVxuICBmdW5jdGlvbiBzb21lIChhcnIpIHtcbiAgICByZXR1cm4gYXJyLnNvbWUoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHJldHVybiBkYXRhLnBvc3REYXRhLm1pbWVUeXBlLmluZGV4T2YodHlwZSkgPT09IDBcbiAgICB9KVxuICB9XG5cbiAgaWYgKHNvbWUoW1xuICAgICdtdWx0aXBhcnQvbWl4ZWQnLFxuICAgICdtdWx0aXBhcnQvcmVsYXRlZCcsXG4gICAgJ211bHRpcGFydC9mb3JtLWRhdGEnLFxuICAgICdtdWx0aXBhcnQvYWx0ZXJuYXRpdmUnXSkpIHtcbiAgICAvLyByZXNldCB2YWx1ZXNcbiAgICBkYXRhLnBvc3REYXRhLm1pbWVUeXBlID0gJ211bHRpcGFydC9mb3JtLWRhdGEnXG4gIH0gZWxzZSBpZiAoc29tZShbXG4gICAgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCddKSkge1xuICAgIGlmICghZGF0YS5wb3N0RGF0YS5wYXJhbXMpIHtcbiAgICAgIGRhdGEucG9zdERhdGEudGV4dCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEucG9zdERhdGEucGFyYW1zT2JqID0gZGF0YS5wb3N0RGF0YS5wYXJhbXMucmVkdWNlKHRoaXMucmVkdWNlciwge30pXG5cbiAgICAgIC8vIGFsd2F5cyBvdmVyd3JpdGVcbiAgICAgIGRhdGEucG9zdERhdGEudGV4dCA9IHFzLnN0cmluZ2lmeShkYXRhLnBvc3REYXRhLnBhcmFtc09iailcbiAgICB9XG4gIH0gZWxzZSBpZiAoc29tZShbXG4gICAgJ3RleHQvanNvbicsXG4gICAgJ3RleHQveC1qc29uJyxcbiAgICAnYXBwbGljYXRpb24vanNvbicsXG4gICAgJ2FwcGxpY2F0aW9uL3gtanNvbiddKSkge1xuICAgIGRhdGEucG9zdERhdGEubWltZVR5cGUgPSAnYXBwbGljYXRpb24vanNvbidcblxuICAgIGlmIChkYXRhLnBvc3REYXRhLnRleHQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEucG9zdERhdGEuanNvbk9iaiA9IEpTT04ucGFyc2UoZGF0YS5wb3N0RGF0YS50ZXh0KVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLnJlcXVlc3QuZGVidWcoZSlcblxuICAgICAgICAvLyBmb3JjZSBiYWNrIHRvIHRleHQvcGxhaW5cbiAgICAgICAgZGF0YS5wb3N0RGF0YS5taW1lVHlwZSA9ICd0ZXh0L3BsYWluJ1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRhXG59XG5cbkhhci5wcm90b3R5cGUub3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIC8vIHNraXAgaWYgbm8gaGFyIHByb3BlcnR5IGRlZmluZWRcbiAgaWYgKCFvcHRpb25zLmhhcikge1xuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICB2YXIgaGFyID0ge31cbiAgZXh0ZW5kKGhhciwgb3B0aW9ucy5oYXIpXG5cbiAgLy8gb25seSBwcm9jZXNzIHRoZSBmaXJzdCBlbnRyeVxuICBpZiAoaGFyLmxvZyAmJiBoYXIubG9nLmVudHJpZXMpIHtcbiAgICBoYXIgPSBoYXIubG9nLmVudHJpZXNbMF1cbiAgfVxuXG4gIC8vIGFkZCBvcHRpb25hbCBwcm9wZXJ0aWVzIHRvIG1ha2UgdmFsaWRhdGlvbiBzdWNjZXNzZnVsXG4gIGhhci51cmwgPSBoYXIudXJsIHx8IG9wdGlvbnMudXJsIHx8IG9wdGlvbnMudXJpIHx8IG9wdGlvbnMuYmFzZVVybCB8fCAnLydcbiAgaGFyLmh0dHBWZXJzaW9uID0gaGFyLmh0dHBWZXJzaW9uIHx8ICdIVFRQLzEuMSdcbiAgaGFyLnF1ZXJ5U3RyaW5nID0gaGFyLnF1ZXJ5U3RyaW5nIHx8IFtdXG4gIGhhci5oZWFkZXJzID0gaGFyLmhlYWRlcnMgfHwgW11cbiAgaGFyLmNvb2tpZXMgPSBoYXIuY29va2llcyB8fCBbXVxuICBoYXIucG9zdERhdGEgPSBoYXIucG9zdERhdGEgfHwge31cbiAgaGFyLnBvc3REYXRhLm1pbWVUeXBlID0gaGFyLnBvc3REYXRhLm1pbWVUeXBlIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXG5cbiAgaGFyLmJvZHlTaXplID0gMFxuICBoYXIuaGVhZGVyc1NpemUgPSAwXG4gIGhhci5wb3N0RGF0YS5zaXplID0gMFxuXG4gIGlmICghdmFsaWRhdGUucmVxdWVzdChoYXIpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIC8vIGNsZWFuIHVwIGFuZCBnZXQgc29tZSB1dGlsaXR5IHByb3BlcnRpZXNcbiAgdmFyIHJlcSA9IHRoaXMucHJlcChoYXIpXG5cbiAgLy8gY29uc3RydWN0IG5ldyBvcHRpb25zXG4gIGlmIChyZXEudXJsKSB7XG4gICAgb3B0aW9ucy51cmwgPSByZXEudXJsXG4gIH1cblxuICBpZiAocmVxLm1ldGhvZCkge1xuICAgIG9wdGlvbnMubWV0aG9kID0gcmVxLm1ldGhvZFxuICB9XG5cbiAgaWYgKE9iamVjdC5rZXlzKHJlcS5xdWVyeU9iaikubGVuZ3RoKSB7XG4gICAgb3B0aW9ucy5xcyA9IHJlcS5xdWVyeU9ialxuICB9XG5cbiAgaWYgKE9iamVjdC5rZXlzKHJlcS5oZWFkZXJzT2JqKS5sZW5ndGgpIHtcbiAgICBvcHRpb25zLmhlYWRlcnMgPSByZXEuaGVhZGVyc09ialxuICB9XG5cbiAgZnVuY3Rpb24gdGVzdCAodHlwZSkge1xuICAgIHJldHVybiByZXEucG9zdERhdGEubWltZVR5cGUuaW5kZXhPZih0eXBlKSA9PT0gMFxuICB9XG4gIGlmICh0ZXN0KCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKSkge1xuICAgIG9wdGlvbnMuZm9ybSA9IHJlcS5wb3N0RGF0YS5wYXJhbXNPYmpcbiAgfSBlbHNlIGlmICh0ZXN0KCdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICBpZiAocmVxLnBvc3REYXRhLmpzb25PYmopIHtcbiAgICAgIG9wdGlvbnMuYm9keSA9IHJlcS5wb3N0RGF0YS5qc29uT2JqXG4gICAgICBvcHRpb25zLmpzb24gPSB0cnVlXG4gICAgfVxuICB9IGVsc2UgaWYgKHRlc3QoJ211bHRpcGFydC9mb3JtLWRhdGEnKSkge1xuICAgIG9wdGlvbnMuZm9ybURhdGEgPSB7fVxuXG4gICAgcmVxLnBvc3REYXRhLnBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIGF0dGFjaG1lbnQgPSB7fVxuXG4gICAgICBpZiAoIXBhcmFtLmZpbGVOYW1lICYmICFwYXJhbS5jb250ZW50VHlwZSkge1xuICAgICAgICBvcHRpb25zLmZvcm1EYXRhW3BhcmFtLm5hbWVdID0gcGFyYW0udmFsdWVcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIGF0dGVtcHQgdG8gcmVhZCBmcm9tIGRpc2shXG4gICAgICBpZiAocGFyYW0uZmlsZU5hbWUgJiYgIXBhcmFtLnZhbHVlKSB7XG4gICAgICAgIGF0dGFjaG1lbnQudmFsdWUgPSBmcy5jcmVhdGVSZWFkU3RyZWFtKHBhcmFtLmZpbGVOYW1lKVxuICAgICAgfSBlbHNlIGlmIChwYXJhbS52YWx1ZSkge1xuICAgICAgICBhdHRhY2htZW50LnZhbHVlID0gcGFyYW0udmFsdWVcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtLmZpbGVOYW1lKSB7XG4gICAgICAgIGF0dGFjaG1lbnQub3B0aW9ucyA9IHtcbiAgICAgICAgICBmaWxlbmFtZTogcGFyYW0uZmlsZU5hbWUsXG4gICAgICAgICAgY29udGVudFR5cGU6IHBhcmFtLmNvbnRlbnRUeXBlID8gcGFyYW0uY29udGVudFR5cGUgOiBudWxsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb3B0aW9ucy5mb3JtRGF0YVtwYXJhbS5uYW1lXSA9IGF0dGFjaG1lbnRcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGlmIChyZXEucG9zdERhdGEudGV4dCkge1xuICAgICAgb3B0aW9ucy5ib2R5ID0gcmVxLnBvc3REYXRhLnRleHRcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5leHBvcnRzLkhhciA9IEhhclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/request/lib/har.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/request/lib/hawk.js":
/*!******************************************!*\
  !*** ./node_modules/request/lib/hawk.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\")\n\nfunction randomString (size) {\n  var bits = (size + 1) * 6\n  var buffer = crypto.randomBytes(Math.ceil(bits / 8))\n  var string = buffer.toString('base64').replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '')\n  return string.slice(0, size)\n}\n\nfunction calculatePayloadHash (payload, algorithm, contentType) {\n  var hash = crypto.createHash(algorithm)\n  hash.update('hawk.1.payload\\n')\n  hash.update((contentType ? contentType.split(';')[0].trim().toLowerCase() : '') + '\\n')\n  hash.update(payload || '')\n  hash.update('\\n')\n  return hash.digest('base64')\n}\n\nexports.calculateMac = function (credentials, opts) {\n  var normalized = 'hawk.1.header\\n' +\n    opts.ts + '\\n' +\n    opts.nonce + '\\n' +\n    (opts.method || '').toUpperCase() + '\\n' +\n    opts.resource + '\\n' +\n    opts.host.toLowerCase() + '\\n' +\n    opts.port + '\\n' +\n    (opts.hash || '') + '\\n'\n\n  if (opts.ext) {\n    normalized = normalized + opts.ext.replace('\\\\', '\\\\\\\\').replace('\\n', '\\\\n')\n  }\n\n  normalized = normalized + '\\n'\n\n  if (opts.app) {\n    normalized = normalized + opts.app + '\\n' + (opts.dlg || '') + '\\n'\n  }\n\n  var hmac = crypto.createHmac(credentials.algorithm, credentials.key).update(normalized)\n  var digest = hmac.digest('base64')\n  return digest\n}\n\nexports.header = function (uri, method, opts) {\n  var timestamp = opts.timestamp || Math.floor((Date.now() + (opts.localtimeOffsetMsec || 0)) / 1000)\n  var credentials = opts.credentials\n  if (!credentials || !credentials.id || !credentials.key || !credentials.algorithm) {\n    return ''\n  }\n\n  if (['sha1', 'sha256'].indexOf(credentials.algorithm) === -1) {\n    return ''\n  }\n\n  var artifacts = {\n    ts: timestamp,\n    nonce: opts.nonce || randomString(6),\n    method: method,\n    resource: uri.pathname + (uri.search || ''),\n    host: uri.hostname,\n    port: uri.port || (uri.protocol === 'http:' ? 80 : 443),\n    hash: opts.hash,\n    ext: opts.ext,\n    app: opts.app,\n    dlg: opts.dlg\n  }\n\n  if (!artifacts.hash && (opts.payload || opts.payload === '')) {\n    artifacts.hash = calculatePayloadHash(opts.payload, credentials.algorithm, opts.contentType)\n  }\n\n  var mac = exports.calculateMac(credentials, artifacts)\n\n  var hasExt = artifacts.ext !== null && artifacts.ext !== undefined && artifacts.ext !== ''\n  var header = 'Hawk id=\"' + credentials.id +\n    '\", ts=\"' + artifacts.ts +\n    '\", nonce=\"' + artifacts.nonce +\n    (artifacts.hash ? '\", hash=\"' + artifacts.hash : '') +\n    (hasExt ? '\", ext=\"' + artifacts.ext.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"') : '') +\n    '\", mac=\"' + mac + '\"'\n\n  if (artifacts.app) {\n    header = header + ', app=\"' + artifacts.app + (artifacts.dlg ? '\", dlg=\"' + artifacts.dlg : '') + '\"'\n  }\n\n  return header\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvaGF3ay5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixhQUFhLG1CQUFPLENBQUMsc0JBQVE7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BhZ2UtZm9ybS8uL25vZGVfbW9kdWxlcy9yZXF1ZXN0L2xpYi9oYXdrLmpzPzhlNGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxuXG5mdW5jdGlvbiByYW5kb21TdHJpbmcgKHNpemUpIHtcbiAgdmFyIGJpdHMgPSAoc2l6ZSArIDEpICogNlxuICB2YXIgYnVmZmVyID0gY3J5cHRvLnJhbmRvbUJ5dGVzKE1hdGguY2VpbChiaXRzIC8gOCkpXG4gIHZhciBzdHJpbmcgPSBidWZmZXIudG9TdHJpbmcoJ2Jhc2U2NCcpLnJlcGxhY2UoL1xcKy9nLCAnLScpLnJlcGxhY2UoL1xcLy9nLCAnXycpLnJlcGxhY2UoLz0vZywgJycpXG4gIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUGF5bG9hZEhhc2ggKHBheWxvYWQsIGFsZ29yaXRobSwgY29udGVudFR5cGUpIHtcbiAgdmFyIGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaChhbGdvcml0aG0pXG4gIGhhc2gudXBkYXRlKCdoYXdrLjEucGF5bG9hZFxcbicpXG4gIGhhc2gudXBkYXRlKChjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLnNwbGl0KCc7JylbMF0udHJpbSgpLnRvTG93ZXJDYXNlKCkgOiAnJykgKyAnXFxuJylcbiAgaGFzaC51cGRhdGUocGF5bG9hZCB8fCAnJylcbiAgaGFzaC51cGRhdGUoJ1xcbicpXG4gIHJldHVybiBoYXNoLmRpZ2VzdCgnYmFzZTY0Jylcbn1cblxuZXhwb3J0cy5jYWxjdWxhdGVNYWMgPSBmdW5jdGlvbiAoY3JlZGVudGlhbHMsIG9wdHMpIHtcbiAgdmFyIG5vcm1hbGl6ZWQgPSAnaGF3ay4xLmhlYWRlclxcbicgK1xuICAgIG9wdHMudHMgKyAnXFxuJyArXG4gICAgb3B0cy5ub25jZSArICdcXG4nICtcbiAgICAob3B0cy5tZXRob2QgfHwgJycpLnRvVXBwZXJDYXNlKCkgKyAnXFxuJyArXG4gICAgb3B0cy5yZXNvdXJjZSArICdcXG4nICtcbiAgICBvcHRzLmhvc3QudG9Mb3dlckNhc2UoKSArICdcXG4nICtcbiAgICBvcHRzLnBvcnQgKyAnXFxuJyArXG4gICAgKG9wdHMuaGFzaCB8fCAnJykgKyAnXFxuJ1xuXG4gIGlmIChvcHRzLmV4dCkge1xuICAgIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVkICsgb3B0cy5leHQucmVwbGFjZSgnXFxcXCcsICdcXFxcXFxcXCcpLnJlcGxhY2UoJ1xcbicsICdcXFxcbicpXG4gIH1cblxuICBub3JtYWxpemVkID0gbm9ybWFsaXplZCArICdcXG4nXG5cbiAgaWYgKG9wdHMuYXBwKSB7XG4gICAgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQgKyBvcHRzLmFwcCArICdcXG4nICsgKG9wdHMuZGxnIHx8ICcnKSArICdcXG4nXG4gIH1cblxuICB2YXIgaG1hYyA9IGNyeXB0by5jcmVhdGVIbWFjKGNyZWRlbnRpYWxzLmFsZ29yaXRobSwgY3JlZGVudGlhbHMua2V5KS51cGRhdGUobm9ybWFsaXplZClcbiAgdmFyIGRpZ2VzdCA9IGhtYWMuZGlnZXN0KCdiYXNlNjQnKVxuICByZXR1cm4gZGlnZXN0XG59XG5cbmV4cG9ydHMuaGVhZGVyID0gZnVuY3Rpb24gKHVyaSwgbWV0aG9kLCBvcHRzKSB7XG4gIHZhciB0aW1lc3RhbXAgPSBvcHRzLnRpbWVzdGFtcCB8fCBNYXRoLmZsb29yKChEYXRlLm5vdygpICsgKG9wdHMubG9jYWx0aW1lT2Zmc2V0TXNlYyB8fCAwKSkgLyAxMDAwKVxuICB2YXIgY3JlZGVudGlhbHMgPSBvcHRzLmNyZWRlbnRpYWxzXG4gIGlmICghY3JlZGVudGlhbHMgfHwgIWNyZWRlbnRpYWxzLmlkIHx8ICFjcmVkZW50aWFscy5rZXkgfHwgIWNyZWRlbnRpYWxzLmFsZ29yaXRobSkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKFsnc2hhMScsICdzaGEyNTYnXS5pbmRleE9mKGNyZWRlbnRpYWxzLmFsZ29yaXRobSkgPT09IC0xKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICB2YXIgYXJ0aWZhY3RzID0ge1xuICAgIHRzOiB0aW1lc3RhbXAsXG4gICAgbm9uY2U6IG9wdHMubm9uY2UgfHwgcmFuZG9tU3RyaW5nKDYpLFxuICAgIG1ldGhvZDogbWV0aG9kLFxuICAgIHJlc291cmNlOiB1cmkucGF0aG5hbWUgKyAodXJpLnNlYXJjaCB8fCAnJyksXG4gICAgaG9zdDogdXJpLmhvc3RuYW1lLFxuICAgIHBvcnQ6IHVyaS5wb3J0IHx8ICh1cmkucHJvdG9jb2wgPT09ICdodHRwOicgPyA4MCA6IDQ0MyksXG4gICAgaGFzaDogb3B0cy5oYXNoLFxuICAgIGV4dDogb3B0cy5leHQsXG4gICAgYXBwOiBvcHRzLmFwcCxcbiAgICBkbGc6IG9wdHMuZGxnXG4gIH1cblxuICBpZiAoIWFydGlmYWN0cy5oYXNoICYmIChvcHRzLnBheWxvYWQgfHwgb3B0cy5wYXlsb2FkID09PSAnJykpIHtcbiAgICBhcnRpZmFjdHMuaGFzaCA9IGNhbGN1bGF0ZVBheWxvYWRIYXNoKG9wdHMucGF5bG9hZCwgY3JlZGVudGlhbHMuYWxnb3JpdGhtLCBvcHRzLmNvbnRlbnRUeXBlKVxuICB9XG5cbiAgdmFyIG1hYyA9IGV4cG9ydHMuY2FsY3VsYXRlTWFjKGNyZWRlbnRpYWxzLCBhcnRpZmFjdHMpXG5cbiAgdmFyIGhhc0V4dCA9IGFydGlmYWN0cy5leHQgIT09IG51bGwgJiYgYXJ0aWZhY3RzLmV4dCAhPT0gdW5kZWZpbmVkICYmIGFydGlmYWN0cy5leHQgIT09ICcnXG4gIHZhciBoZWFkZXIgPSAnSGF3ayBpZD1cIicgKyBjcmVkZW50aWFscy5pZCArXG4gICAgJ1wiLCB0cz1cIicgKyBhcnRpZmFjdHMudHMgK1xuICAgICdcIiwgbm9uY2U9XCInICsgYXJ0aWZhY3RzLm5vbmNlICtcbiAgICAoYXJ0aWZhY3RzLmhhc2ggPyAnXCIsIGhhc2g9XCInICsgYXJ0aWZhY3RzLmhhc2ggOiAnJykgK1xuICAgIChoYXNFeHQgPyAnXCIsIGV4dD1cIicgKyBhcnRpZmFjdHMuZXh0LnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpIDogJycpICtcbiAgICAnXCIsIG1hYz1cIicgKyBtYWMgKyAnXCInXG5cbiAgaWYgKGFydGlmYWN0cy5hcHApIHtcbiAgICBoZWFkZXIgPSBoZWFkZXIgKyAnLCBhcHA9XCInICsgYXJ0aWZhY3RzLmFwcCArIChhcnRpZmFjdHMuZGxnID8gJ1wiLCBkbGc9XCInICsgYXJ0aWZhY3RzLmRsZyA6ICcnKSArICdcIidcbiAgfVxuXG4gIHJldHVybiBoZWFkZXJcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/request/lib/hawk.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/request/lib/helpers.js":
/*!*********************************************!*\
  !*** ./node_modules/request/lib/helpers.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar jsonSafeStringify = __webpack_require__(/*! json-stringify-safe */ \"(rsc)/./node_modules/json-stringify-safe/stringify.js\")\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\")\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"(rsc)/./node_modules/safe-buffer/index.js\").Buffer)\n\nvar defer = typeof setImmediate === 'undefined'\n  ? process.nextTick\n  : setImmediate\n\nfunction paramsHaveRequestBody (params) {\n  return (\n    params.body ||\n    params.requestBodyStream ||\n    (params.json && typeof params.json !== 'boolean') ||\n    params.multipart\n  )\n}\n\nfunction safeStringify (obj, replacer) {\n  var ret\n  try {\n    ret = JSON.stringify(obj, replacer)\n  } catch (e) {\n    ret = jsonSafeStringify(obj, replacer)\n  }\n  return ret\n}\n\nfunction md5 (str) {\n  return crypto.createHash('md5').update(str).digest('hex')\n}\n\nfunction isReadStream (rs) {\n  return rs.readable && rs.path && rs.mode\n}\n\nfunction toBase64 (str) {\n  return Buffer.from(str || '', 'utf8').toString('base64')\n}\n\nfunction copy (obj) {\n  var o = {}\n  Object.keys(obj).forEach(function (i) {\n    o[i] = obj[i]\n  })\n  return o\n}\n\nfunction version () {\n  var numbers = process.version.replace('v', '').split('.')\n  return {\n    major: parseInt(numbers[0], 10),\n    minor: parseInt(numbers[1], 10),\n    patch: parseInt(numbers[2], 10)\n  }\n}\n\nexports.paramsHaveRequestBody = paramsHaveRequestBody\nexports.safeStringify = safeStringify\nexports.md5 = md5\nexports.isReadStream = isReadStream\nexports.toBase64 = toBase64\nexports.copy = copy\nexports.version = version\nexports.defer = defer\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWix3QkFBd0IsbUJBQU8sQ0FBQyxrRkFBcUI7QUFDckQsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGFBQWEsNEZBQTZCOztBQUUxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCLHFCQUFxQjtBQUNyQixXQUFXO0FBQ1gsb0JBQW9CO0FBQ3BCLGdCQUFnQjtBQUNoQixZQUFZO0FBQ1osZUFBZTtBQUNmLGFBQWEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYWdlLWZvcm0vLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvaGVscGVycy5qcz8yOTA5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG52YXIganNvblNhZmVTdHJpbmdpZnkgPSByZXF1aXJlKCdqc29uLXN0cmluZ2lmeS1zYWZlJylcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBkZWZlciA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICd1bmRlZmluZWQnXG4gID8gcHJvY2Vzcy5uZXh0VGlja1xuICA6IHNldEltbWVkaWF0ZVxuXG5mdW5jdGlvbiBwYXJhbXNIYXZlUmVxdWVzdEJvZHkgKHBhcmFtcykge1xuICByZXR1cm4gKFxuICAgIHBhcmFtcy5ib2R5IHx8XG4gICAgcGFyYW1zLnJlcXVlc3RCb2R5U3RyZWFtIHx8XG4gICAgKHBhcmFtcy5qc29uICYmIHR5cGVvZiBwYXJhbXMuanNvbiAhPT0gJ2Jvb2xlYW4nKSB8fFxuICAgIHBhcmFtcy5tdWx0aXBhcnRcbiAgKVxufVxuXG5mdW5jdGlvbiBzYWZlU3RyaW5naWZ5IChvYmosIHJlcGxhY2VyKSB7XG4gIHZhciByZXRcbiAgdHJ5IHtcbiAgICByZXQgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VyKVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0ID0ganNvblNhZmVTdHJpbmdpZnkob2JqLCByZXBsYWNlcilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIG1kNSAoc3RyKSB7XG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgnbWQ1JykudXBkYXRlKHN0cikuZGlnZXN0KCdoZXgnKVxufVxuXG5mdW5jdGlvbiBpc1JlYWRTdHJlYW0gKHJzKSB7XG4gIHJldHVybiBycy5yZWFkYWJsZSAmJiBycy5wYXRoICYmIHJzLm1vZGVcbn1cblxuZnVuY3Rpb24gdG9CYXNlNjQgKHN0cikge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc3RyIHx8ICcnLCAndXRmOCcpLnRvU3RyaW5nKCdiYXNlNjQnKVxufVxuXG5mdW5jdGlvbiBjb3B5IChvYmopIHtcbiAgdmFyIG8gPSB7fVxuICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICBvW2ldID0gb2JqW2ldXG4gIH0pXG4gIHJldHVybiBvXG59XG5cbmZ1bmN0aW9uIHZlcnNpb24gKCkge1xuICB2YXIgbnVtYmVycyA9IHByb2Nlc3MudmVyc2lvbi5yZXBsYWNlKCd2JywgJycpLnNwbGl0KCcuJylcbiAgcmV0dXJuIHtcbiAgICBtYWpvcjogcGFyc2VJbnQobnVtYmVyc1swXSwgMTApLFxuICAgIG1pbm9yOiBwYXJzZUludChudW1iZXJzWzFdLCAxMCksXG4gICAgcGF0Y2g6IHBhcnNlSW50KG51bWJlcnNbMl0sIDEwKVxuICB9XG59XG5cbmV4cG9ydHMucGFyYW1zSGF2ZVJlcXVlc3RCb2R5ID0gcGFyYW1zSGF2ZVJlcXVlc3RCb2R5XG5leHBvcnRzLnNhZmVTdHJpbmdpZnkgPSBzYWZlU3RyaW5naWZ5XG5leHBvcnRzLm1kNSA9IG1kNVxuZXhwb3J0cy5pc1JlYWRTdHJlYW0gPSBpc1JlYWRTdHJlYW1cbmV4cG9ydHMudG9CYXNlNjQgPSB0b0Jhc2U2NFxuZXhwb3J0cy5jb3B5ID0gY29weVxuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvblxuZXhwb3J0cy5kZWZlciA9IGRlZmVyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/request/lib/helpers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/request/lib/multipart.js":
/*!***********************************************!*\
  !*** ./node_modules/request/lib/multipart.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar uuid = __webpack_require__(/*! uuid/v4 */ \"(rsc)/./node_modules/request/node_modules/uuid/v4.js\")\nvar CombinedStream = __webpack_require__(/*! combined-stream */ \"(rsc)/./node_modules/combined-stream/lib/combined_stream.js\")\nvar isstream = __webpack_require__(/*! isstream */ \"(rsc)/./node_modules/isstream/isstream.js\")\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"(rsc)/./node_modules/safe-buffer/index.js\").Buffer)\n\nfunction Multipart (request) {\n  this.request = request\n  this.boundary = uuid()\n  this.chunked = false\n  this.body = null\n}\n\nMultipart.prototype.isChunked = function (options) {\n  var self = this\n  var chunked = false\n  var parts = options.data || options\n\n  if (!parts.forEach) {\n    self.request.emit('error', new Error('Argument error, options.multipart.'))\n  }\n\n  if (options.chunked !== undefined) {\n    chunked = options.chunked\n  }\n\n  if (self.request.getHeader('transfer-encoding') === 'chunked') {\n    chunked = true\n  }\n\n  if (!chunked) {\n    parts.forEach(function (part) {\n      if (typeof part.body === 'undefined') {\n        self.request.emit('error', new Error('Body attribute missing in multipart.'))\n      }\n      if (isstream(part.body)) {\n        chunked = true\n      }\n    })\n  }\n\n  return chunked\n}\n\nMultipart.prototype.setHeaders = function (chunked) {\n  var self = this\n\n  if (chunked && !self.request.hasHeader('transfer-encoding')) {\n    self.request.setHeader('transfer-encoding', 'chunked')\n  }\n\n  var header = self.request.getHeader('content-type')\n\n  if (!header || header.indexOf('multipart') === -1) {\n    self.request.setHeader('content-type', 'multipart/related; boundary=' + self.boundary)\n  } else {\n    if (header.indexOf('boundary') !== -1) {\n      self.boundary = header.replace(/.*boundary=([^\\s;]+).*/, '$1')\n    } else {\n      self.request.setHeader('content-type', header + '; boundary=' + self.boundary)\n    }\n  }\n}\n\nMultipart.prototype.build = function (parts, chunked) {\n  var self = this\n  var body = chunked ? new CombinedStream() : []\n\n  function add (part) {\n    if (typeof part === 'number') {\n      part = part.toString()\n    }\n    return chunked ? body.append(part) : body.push(Buffer.from(part))\n  }\n\n  if (self.request.preambleCRLF) {\n    add('\\r\\n')\n  }\n\n  parts.forEach(function (part) {\n    var preamble = '--' + self.boundary + '\\r\\n'\n    Object.keys(part).forEach(function (key) {\n      if (key === 'body') { return }\n      preamble += key + ': ' + part[key] + '\\r\\n'\n    })\n    preamble += '\\r\\n'\n    add(preamble)\n    add(part.body)\n    add('\\r\\n')\n  })\n  add('--' + self.boundary + '--')\n\n  if (self.request.postambleCRLF) {\n    add('\\r\\n')\n  }\n\n  return body\n}\n\nMultipart.prototype.onRequest = function (options) {\n  var self = this\n\n  var chunked = self.isChunked(options)\n  var parts = options.data || options\n\n  self.setHeaders(chunked)\n  self.chunked = chunked\n  self.body = self.build(parts, chunked)\n}\n\nexports.Multipart = Multipart\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvbXVsdGlwYXJ0LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFdBQVcsbUJBQU8sQ0FBQyxxRUFBUztBQUM1QixxQkFBcUIsbUJBQU8sQ0FBQyxvRkFBaUI7QUFDOUMsZUFBZSxtQkFBTyxDQUFDLDJEQUFVO0FBQ2pDLGFBQWEsNEZBQTZCOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0RBQStEO0FBQy9ELElBQUk7QUFDSjtBQUNBLHVEQUF1RDtBQUN2RCxNQUFNO0FBQ04seURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BhZ2UtZm9ybS8uL25vZGVfbW9kdWxlcy9yZXF1ZXN0L2xpYi9tdWx0aXBhcnQuanM/ZjE5YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxudmFyIHV1aWQgPSByZXF1aXJlKCd1dWlkL3Y0JylcbnZhciBDb21iaW5lZFN0cmVhbSA9IHJlcXVpcmUoJ2NvbWJpbmVkLXN0cmVhbScpXG52YXIgaXNzdHJlYW0gPSByZXF1aXJlKCdpc3N0cmVhbScpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxuZnVuY3Rpb24gTXVsdGlwYXJ0IChyZXF1ZXN0KSB7XG4gIHRoaXMucmVxdWVzdCA9IHJlcXVlc3RcbiAgdGhpcy5ib3VuZGFyeSA9IHV1aWQoKVxuICB0aGlzLmNodW5rZWQgPSBmYWxzZVxuICB0aGlzLmJvZHkgPSBudWxsXG59XG5cbk11bHRpcGFydC5wcm90b3R5cGUuaXNDaHVua2VkID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBjaHVua2VkID0gZmFsc2VcbiAgdmFyIHBhcnRzID0gb3B0aW9ucy5kYXRhIHx8IG9wdGlvbnNcblxuICBpZiAoIXBhcnRzLmZvckVhY2gpIHtcbiAgICBzZWxmLnJlcXVlc3QuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0FyZ3VtZW50IGVycm9yLCBvcHRpb25zLm11bHRpcGFydC4nKSlcbiAgfVxuXG4gIGlmIChvcHRpb25zLmNodW5rZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIGNodW5rZWQgPSBvcHRpb25zLmNodW5rZWRcbiAgfVxuXG4gIGlmIChzZWxmLnJlcXVlc3QuZ2V0SGVhZGVyKCd0cmFuc2Zlci1lbmNvZGluZycpID09PSAnY2h1bmtlZCcpIHtcbiAgICBjaHVua2VkID0gdHJ1ZVxuICB9XG5cbiAgaWYgKCFjaHVua2VkKSB7XG4gICAgcGFydHMuZm9yRWFjaChmdW5jdGlvbiAocGFydCkge1xuICAgICAgaWYgKHR5cGVvZiBwYXJ0LmJvZHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNlbGYucmVxdWVzdC5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQm9keSBhdHRyaWJ1dGUgbWlzc2luZyBpbiBtdWx0aXBhcnQuJykpXG4gICAgICB9XG4gICAgICBpZiAoaXNzdHJlYW0ocGFydC5ib2R5KSkge1xuICAgICAgICBjaHVua2VkID0gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gY2h1bmtlZFxufVxuXG5NdWx0aXBhcnQucHJvdG90eXBlLnNldEhlYWRlcnMgPSBmdW5jdGlvbiAoY2h1bmtlZCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBpZiAoY2h1bmtlZCAmJiAhc2VsZi5yZXF1ZXN0Lmhhc0hlYWRlcigndHJhbnNmZXItZW5jb2RpbmcnKSkge1xuICAgIHNlbGYucmVxdWVzdC5zZXRIZWFkZXIoJ3RyYW5zZmVyLWVuY29kaW5nJywgJ2NodW5rZWQnKVxuICB9XG5cbiAgdmFyIGhlYWRlciA9IHNlbGYucmVxdWVzdC5nZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScpXG5cbiAgaWYgKCFoZWFkZXIgfHwgaGVhZGVyLmluZGV4T2YoJ211bHRpcGFydCcpID09PSAtMSkge1xuICAgIHNlbGYucmVxdWVzdC5zZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScsICdtdWx0aXBhcnQvcmVsYXRlZDsgYm91bmRhcnk9JyArIHNlbGYuYm91bmRhcnkpXG4gIH0gZWxzZSB7XG4gICAgaWYgKGhlYWRlci5pbmRleE9mKCdib3VuZGFyeScpICE9PSAtMSkge1xuICAgICAgc2VsZi5ib3VuZGFyeSA9IGhlYWRlci5yZXBsYWNlKC8uKmJvdW5kYXJ5PShbXlxccztdKykuKi8sICckMScpXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYucmVxdWVzdC5zZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScsIGhlYWRlciArICc7IGJvdW5kYXJ5PScgKyBzZWxmLmJvdW5kYXJ5KVxuICAgIH1cbiAgfVxufVxuXG5NdWx0aXBhcnQucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKHBhcnRzLCBjaHVua2VkKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgYm9keSA9IGNodW5rZWQgPyBuZXcgQ29tYmluZWRTdHJlYW0oKSA6IFtdXG5cbiAgZnVuY3Rpb24gYWRkIChwYXJ0KSB7XG4gICAgaWYgKHR5cGVvZiBwYXJ0ID09PSAnbnVtYmVyJykge1xuICAgICAgcGFydCA9IHBhcnQudG9TdHJpbmcoKVxuICAgIH1cbiAgICByZXR1cm4gY2h1bmtlZCA/IGJvZHkuYXBwZW5kKHBhcnQpIDogYm9keS5wdXNoKEJ1ZmZlci5mcm9tKHBhcnQpKVxuICB9XG5cbiAgaWYgKHNlbGYucmVxdWVzdC5wcmVhbWJsZUNSTEYpIHtcbiAgICBhZGQoJ1xcclxcbicpXG4gIH1cblxuICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgdmFyIHByZWFtYmxlID0gJy0tJyArIHNlbGYuYm91bmRhcnkgKyAnXFxyXFxuJ1xuICAgIE9iamVjdC5rZXlzKHBhcnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKGtleSA9PT0gJ2JvZHknKSB7IHJldHVybiB9XG4gICAgICBwcmVhbWJsZSArPSBrZXkgKyAnOiAnICsgcGFydFtrZXldICsgJ1xcclxcbidcbiAgICB9KVxuICAgIHByZWFtYmxlICs9ICdcXHJcXG4nXG4gICAgYWRkKHByZWFtYmxlKVxuICAgIGFkZChwYXJ0LmJvZHkpXG4gICAgYWRkKCdcXHJcXG4nKVxuICB9KVxuICBhZGQoJy0tJyArIHNlbGYuYm91bmRhcnkgKyAnLS0nKVxuXG4gIGlmIChzZWxmLnJlcXVlc3QucG9zdGFtYmxlQ1JMRikge1xuICAgIGFkZCgnXFxyXFxuJylcbiAgfVxuXG4gIHJldHVybiBib2R5XG59XG5cbk11bHRpcGFydC5wcm90b3R5cGUub25SZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdmFyIGNodW5rZWQgPSBzZWxmLmlzQ2h1bmtlZChvcHRpb25zKVxuICB2YXIgcGFydHMgPSBvcHRpb25zLmRhdGEgfHwgb3B0aW9uc1xuXG4gIHNlbGYuc2V0SGVhZGVycyhjaHVua2VkKVxuICBzZWxmLmNodW5rZWQgPSBjaHVua2VkXG4gIHNlbGYuYm9keSA9IHNlbGYuYnVpbGQocGFydHMsIGNodW5rZWQpXG59XG5cbmV4cG9ydHMuTXVsdGlwYXJ0ID0gTXVsdGlwYXJ0XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/request/lib/multipart.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/request/lib/oauth.js":
/*!*******************************************!*\
  !*** ./node_modules/request/lib/oauth.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar url = __webpack_require__(/*! url */ \"url\")\nvar qs = __webpack_require__(/*! qs */ \"(rsc)/./node_modules/qs/lib/index.js\")\nvar caseless = __webpack_require__(/*! caseless */ \"(rsc)/./node_modules/caseless/index.js\")\nvar uuid = __webpack_require__(/*! uuid/v4 */ \"(rsc)/./node_modules/request/node_modules/uuid/v4.js\")\nvar oauth = __webpack_require__(/*! oauth-sign */ \"(rsc)/./node_modules/oauth-sign/index.js\")\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\")\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"(rsc)/./node_modules/safe-buffer/index.js\").Buffer)\n\nfunction OAuth (request) {\n  this.request = request\n  this.params = null\n}\n\nOAuth.prototype.buildParams = function (_oauth, uri, method, query, form, qsLib) {\n  var oa = {}\n  for (var i in _oauth) {\n    oa['oauth_' + i] = _oauth[i]\n  }\n  if (!oa.oauth_version) {\n    oa.oauth_version = '1.0'\n  }\n  if (!oa.oauth_timestamp) {\n    oa.oauth_timestamp = Math.floor(Date.now() / 1000).toString()\n  }\n  if (!oa.oauth_nonce) {\n    oa.oauth_nonce = uuid().replace(/-/g, '')\n  }\n  if (!oa.oauth_signature_method) {\n    oa.oauth_signature_method = 'HMAC-SHA1'\n  }\n\n  var consumer_secret_or_private_key = oa.oauth_consumer_secret || oa.oauth_private_key // eslint-disable-line camelcase\n  delete oa.oauth_consumer_secret\n  delete oa.oauth_private_key\n\n  var token_secret = oa.oauth_token_secret // eslint-disable-line camelcase\n  delete oa.oauth_token_secret\n\n  var realm = oa.oauth_realm\n  delete oa.oauth_realm\n  delete oa.oauth_transport_method\n\n  var baseurl = uri.protocol + '//' + uri.host + uri.pathname\n  var params = qsLib.parse([].concat(query, form, qsLib.stringify(oa)).join('&'))\n\n  oa.oauth_signature = oauth.sign(\n    oa.oauth_signature_method,\n    method,\n    baseurl,\n    params,\n    consumer_secret_or_private_key, // eslint-disable-line camelcase\n    token_secret // eslint-disable-line camelcase\n  )\n\n  if (realm) {\n    oa.realm = realm\n  }\n\n  return oa\n}\n\nOAuth.prototype.buildBodyHash = function (_oauth, body) {\n  if (['HMAC-SHA1', 'RSA-SHA1'].indexOf(_oauth.signature_method || 'HMAC-SHA1') < 0) {\n    this.request.emit('error', new Error('oauth: ' + _oauth.signature_method +\n      ' signature_method not supported with body_hash signing.'))\n  }\n\n  var shasum = crypto.createHash('sha1')\n  shasum.update(body || '')\n  var sha1 = shasum.digest('hex')\n\n  return Buffer.from(sha1, 'hex').toString('base64')\n}\n\nOAuth.prototype.concatParams = function (oa, sep, wrap) {\n  wrap = wrap || ''\n\n  var params = Object.keys(oa).filter(function (i) {\n    return i !== 'realm' && i !== 'oauth_signature'\n  }).sort()\n\n  if (oa.realm) {\n    params.splice(0, 0, 'realm')\n  }\n  params.push('oauth_signature')\n\n  return params.map(function (i) {\n    return i + '=' + wrap + oauth.rfc3986(oa[i]) + wrap\n  }).join(sep)\n}\n\nOAuth.prototype.onRequest = function (_oauth) {\n  var self = this\n  self.params = _oauth\n\n  var uri = self.request.uri || {}\n  var method = self.request.method || ''\n  var headers = caseless(self.request.headers)\n  var body = self.request.body || ''\n  var qsLib = self.request.qsLib || qs\n\n  var form\n  var query\n  var contentType = headers.get('content-type') || ''\n  var formContentType = 'application/x-www-form-urlencoded'\n  var transport = _oauth.transport_method || 'header'\n\n  if (contentType.slice(0, formContentType.length) === formContentType) {\n    contentType = formContentType\n    form = body\n  }\n  if (uri.query) {\n    query = uri.query\n  }\n  if (transport === 'body' && (method !== 'POST' || contentType !== formContentType)) {\n    self.request.emit('error', new Error('oauth: transport_method of body requires POST ' +\n      'and content-type ' + formContentType))\n  }\n\n  if (!form && typeof _oauth.body_hash === 'boolean') {\n    _oauth.body_hash = self.buildBodyHash(_oauth, self.request.body.toString())\n  }\n\n  var oa = self.buildParams(_oauth, uri, method, query, form, qsLib)\n\n  switch (transport) {\n    case 'header':\n      self.request.setHeader('Authorization', 'OAuth ' + self.concatParams(oa, ',', '\"'))\n      break\n\n    case 'query':\n      var href = self.request.uri.href += (query ? '&' : '?') + self.concatParams(oa, '&')\n      self.request.uri = url.parse(href)\n      self.request.path = self.request.uri.path\n      break\n\n    case 'body':\n      self.request.body = (form ? form + '&' : '') + self.concatParams(oa, '&')\n      break\n\n    default:\n      self.request.emit('error', new Error('oauth: transport_method invalid'))\n  }\n}\n\nexports.OAuth = OAuth\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvb2F1dGguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosVUFBVSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3ZCLFNBQVMsbUJBQU8sQ0FBQyxnREFBSTtBQUNyQixlQUFlLG1CQUFPLENBQUMsd0RBQVU7QUFDakMsV0FBVyxtQkFBTyxDQUFDLHFFQUFTO0FBQzVCLFlBQVksbUJBQU8sQ0FBQyw0REFBWTtBQUNoQyxhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsYUFBYSw0RkFBNkI7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYWdlLWZvcm0vLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvb2F1dGguanM/OTg2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpXG52YXIgcXMgPSByZXF1aXJlKCdxcycpXG52YXIgY2FzZWxlc3MgPSByZXF1aXJlKCdjYXNlbGVzcycpXG52YXIgdXVpZCA9IHJlcXVpcmUoJ3V1aWQvdjQnKVxudmFyIG9hdXRoID0gcmVxdWlyZSgnb2F1dGgtc2lnbicpXG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG5mdW5jdGlvbiBPQXV0aCAocmVxdWVzdCkge1xuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0XG4gIHRoaXMucGFyYW1zID0gbnVsbFxufVxuXG5PQXV0aC5wcm90b3R5cGUuYnVpbGRQYXJhbXMgPSBmdW5jdGlvbiAoX29hdXRoLCB1cmksIG1ldGhvZCwgcXVlcnksIGZvcm0sIHFzTGliKSB7XG4gIHZhciBvYSA9IHt9XG4gIGZvciAodmFyIGkgaW4gX29hdXRoKSB7XG4gICAgb2FbJ29hdXRoXycgKyBpXSA9IF9vYXV0aFtpXVxuICB9XG4gIGlmICghb2Eub2F1dGhfdmVyc2lvbikge1xuICAgIG9hLm9hdXRoX3ZlcnNpb24gPSAnMS4wJ1xuICB9XG4gIGlmICghb2Eub2F1dGhfdGltZXN0YW1wKSB7XG4gICAgb2Eub2F1dGhfdGltZXN0YW1wID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkudG9TdHJpbmcoKVxuICB9XG4gIGlmICghb2Eub2F1dGhfbm9uY2UpIHtcbiAgICBvYS5vYXV0aF9ub25jZSA9IHV1aWQoKS5yZXBsYWNlKC8tL2csICcnKVxuICB9XG4gIGlmICghb2Eub2F1dGhfc2lnbmF0dXJlX21ldGhvZCkge1xuICAgIG9hLm9hdXRoX3NpZ25hdHVyZV9tZXRob2QgPSAnSE1BQy1TSEExJ1xuICB9XG5cbiAgdmFyIGNvbnN1bWVyX3NlY3JldF9vcl9wcml2YXRlX2tleSA9IG9hLm9hdXRoX2NvbnN1bWVyX3NlY3JldCB8fCBvYS5vYXV0aF9wcml2YXRlX2tleSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuICBkZWxldGUgb2Eub2F1dGhfY29uc3VtZXJfc2VjcmV0XG4gIGRlbGV0ZSBvYS5vYXV0aF9wcml2YXRlX2tleVxuXG4gIHZhciB0b2tlbl9zZWNyZXQgPSBvYS5vYXV0aF90b2tlbl9zZWNyZXQgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgZGVsZXRlIG9hLm9hdXRoX3Rva2VuX3NlY3JldFxuXG4gIHZhciByZWFsbSA9IG9hLm9hdXRoX3JlYWxtXG4gIGRlbGV0ZSBvYS5vYXV0aF9yZWFsbVxuICBkZWxldGUgb2Eub2F1dGhfdHJhbnNwb3J0X21ldGhvZFxuXG4gIHZhciBiYXNldXJsID0gdXJpLnByb3RvY29sICsgJy8vJyArIHVyaS5ob3N0ICsgdXJpLnBhdGhuYW1lXG4gIHZhciBwYXJhbXMgPSBxc0xpYi5wYXJzZShbXS5jb25jYXQocXVlcnksIGZvcm0sIHFzTGliLnN0cmluZ2lmeShvYSkpLmpvaW4oJyYnKSlcblxuICBvYS5vYXV0aF9zaWduYXR1cmUgPSBvYXV0aC5zaWduKFxuICAgIG9hLm9hdXRoX3NpZ25hdHVyZV9tZXRob2QsXG4gICAgbWV0aG9kLFxuICAgIGJhc2V1cmwsXG4gICAgcGFyYW1zLFxuICAgIGNvbnN1bWVyX3NlY3JldF9vcl9wcml2YXRlX2tleSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICB0b2tlbl9zZWNyZXQgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgKVxuXG4gIGlmIChyZWFsbSkge1xuICAgIG9hLnJlYWxtID0gcmVhbG1cbiAgfVxuXG4gIHJldHVybiBvYVxufVxuXG5PQXV0aC5wcm90b3R5cGUuYnVpbGRCb2R5SGFzaCA9IGZ1bmN0aW9uIChfb2F1dGgsIGJvZHkpIHtcbiAgaWYgKFsnSE1BQy1TSEExJywgJ1JTQS1TSEExJ10uaW5kZXhPZihfb2F1dGguc2lnbmF0dXJlX21ldGhvZCB8fCAnSE1BQy1TSEExJykgPCAwKSB7XG4gICAgdGhpcy5yZXF1ZXN0LmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdvYXV0aDogJyArIF9vYXV0aC5zaWduYXR1cmVfbWV0aG9kICtcbiAgICAgICcgc2lnbmF0dXJlX21ldGhvZCBub3Qgc3VwcG9ydGVkIHdpdGggYm9keV9oYXNoIHNpZ25pbmcuJykpXG4gIH1cblxuICB2YXIgc2hhc3VtID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKVxuICBzaGFzdW0udXBkYXRlKGJvZHkgfHwgJycpXG4gIHZhciBzaGExID0gc2hhc3VtLmRpZ2VzdCgnaGV4JylcblxuICByZXR1cm4gQnVmZmVyLmZyb20oc2hhMSwgJ2hleCcpLnRvU3RyaW5nKCdiYXNlNjQnKVxufVxuXG5PQXV0aC5wcm90b3R5cGUuY29uY2F0UGFyYW1zID0gZnVuY3Rpb24gKG9hLCBzZXAsIHdyYXApIHtcbiAgd3JhcCA9IHdyYXAgfHwgJydcblxuICB2YXIgcGFyYW1zID0gT2JqZWN0LmtleXMob2EpLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBpICE9PSAncmVhbG0nICYmIGkgIT09ICdvYXV0aF9zaWduYXR1cmUnXG4gIH0pLnNvcnQoKVxuXG4gIGlmIChvYS5yZWFsbSkge1xuICAgIHBhcmFtcy5zcGxpY2UoMCwgMCwgJ3JlYWxtJylcbiAgfVxuICBwYXJhbXMucHVzaCgnb2F1dGhfc2lnbmF0dXJlJylcblxuICByZXR1cm4gcGFyYW1zLm1hcChmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBpICsgJz0nICsgd3JhcCArIG9hdXRoLnJmYzM5ODYob2FbaV0pICsgd3JhcFxuICB9KS5qb2luKHNlcClcbn1cblxuT0F1dGgucHJvdG90eXBlLm9uUmVxdWVzdCA9IGZ1bmN0aW9uIChfb2F1dGgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYucGFyYW1zID0gX29hdXRoXG5cbiAgdmFyIHVyaSA9IHNlbGYucmVxdWVzdC51cmkgfHwge31cbiAgdmFyIG1ldGhvZCA9IHNlbGYucmVxdWVzdC5tZXRob2QgfHwgJydcbiAgdmFyIGhlYWRlcnMgPSBjYXNlbGVzcyhzZWxmLnJlcXVlc3QuaGVhZGVycylcbiAgdmFyIGJvZHkgPSBzZWxmLnJlcXVlc3QuYm9keSB8fCAnJ1xuICB2YXIgcXNMaWIgPSBzZWxmLnJlcXVlc3QucXNMaWIgfHwgcXNcblxuICB2YXIgZm9ybVxuICB2YXIgcXVlcnlcbiAgdmFyIGNvbnRlbnRUeXBlID0gaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpIHx8ICcnXG4gIHZhciBmb3JtQ29udGVudFR5cGUgPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xuICB2YXIgdHJhbnNwb3J0ID0gX29hdXRoLnRyYW5zcG9ydF9tZXRob2QgfHwgJ2hlYWRlcidcblxuICBpZiAoY29udGVudFR5cGUuc2xpY2UoMCwgZm9ybUNvbnRlbnRUeXBlLmxlbmd0aCkgPT09IGZvcm1Db250ZW50VHlwZSkge1xuICAgIGNvbnRlbnRUeXBlID0gZm9ybUNvbnRlbnRUeXBlXG4gICAgZm9ybSA9IGJvZHlcbiAgfVxuICBpZiAodXJpLnF1ZXJ5KSB7XG4gICAgcXVlcnkgPSB1cmkucXVlcnlcbiAgfVxuICBpZiAodHJhbnNwb3J0ID09PSAnYm9keScgJiYgKG1ldGhvZCAhPT0gJ1BPU1QnIHx8IGNvbnRlbnRUeXBlICE9PSBmb3JtQ29udGVudFR5cGUpKSB7XG4gICAgc2VsZi5yZXF1ZXN0LmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdvYXV0aDogdHJhbnNwb3J0X21ldGhvZCBvZiBib2R5IHJlcXVpcmVzIFBPU1QgJyArXG4gICAgICAnYW5kIGNvbnRlbnQtdHlwZSAnICsgZm9ybUNvbnRlbnRUeXBlKSlcbiAgfVxuXG4gIGlmICghZm9ybSAmJiB0eXBlb2YgX29hdXRoLmJvZHlfaGFzaCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgX29hdXRoLmJvZHlfaGFzaCA9IHNlbGYuYnVpbGRCb2R5SGFzaChfb2F1dGgsIHNlbGYucmVxdWVzdC5ib2R5LnRvU3RyaW5nKCkpXG4gIH1cblxuICB2YXIgb2EgPSBzZWxmLmJ1aWxkUGFyYW1zKF9vYXV0aCwgdXJpLCBtZXRob2QsIHF1ZXJ5LCBmb3JtLCBxc0xpYilcblxuICBzd2l0Y2ggKHRyYW5zcG9ydCkge1xuICAgIGNhc2UgJ2hlYWRlcic6XG4gICAgICBzZWxmLnJlcXVlc3Quc2V0SGVhZGVyKCdBdXRob3JpemF0aW9uJywgJ09BdXRoICcgKyBzZWxmLmNvbmNhdFBhcmFtcyhvYSwgJywnLCAnXCInKSlcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdxdWVyeSc6XG4gICAgICB2YXIgaHJlZiA9IHNlbGYucmVxdWVzdC51cmkuaHJlZiArPSAocXVlcnkgPyAnJicgOiAnPycpICsgc2VsZi5jb25jYXRQYXJhbXMob2EsICcmJylcbiAgICAgIHNlbGYucmVxdWVzdC51cmkgPSB1cmwucGFyc2UoaHJlZilcbiAgICAgIHNlbGYucmVxdWVzdC5wYXRoID0gc2VsZi5yZXF1ZXN0LnVyaS5wYXRoXG4gICAgICBicmVha1xuXG4gICAgY2FzZSAnYm9keSc6XG4gICAgICBzZWxmLnJlcXVlc3QuYm9keSA9IChmb3JtID8gZm9ybSArICcmJyA6ICcnKSArIHNlbGYuY29uY2F0UGFyYW1zKG9hLCAnJicpXG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHNlbGYucmVxdWVzdC5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignb2F1dGg6IHRyYW5zcG9ydF9tZXRob2QgaW52YWxpZCcpKVxuICB9XG59XG5cbmV4cG9ydHMuT0F1dGggPSBPQXV0aFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/request/lib/oauth.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/request/lib/querystring.js":
/*!*************************************************!*\
  !*** ./node_modules/request/lib/querystring.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar qs = __webpack_require__(/*! qs */ \"(rsc)/./node_modules/qs/lib/index.js\")\nvar querystring = __webpack_require__(/*! querystring */ \"querystring\")\n\nfunction Querystring (request) {\n  this.request = request\n  this.lib = null\n  this.useQuerystring = null\n  this.parseOptions = null\n  this.stringifyOptions = null\n}\n\nQuerystring.prototype.init = function (options) {\n  if (this.lib) { return }\n\n  this.useQuerystring = options.useQuerystring\n  this.lib = (this.useQuerystring ? querystring : qs)\n\n  this.parseOptions = options.qsParseOptions || {}\n  this.stringifyOptions = options.qsStringifyOptions || {}\n}\n\nQuerystring.prototype.stringify = function (obj) {\n  return (this.useQuerystring)\n    ? this.rfc3986(this.lib.stringify(obj,\n      this.stringifyOptions.sep || null,\n      this.stringifyOptions.eq || null,\n      this.stringifyOptions))\n    : this.lib.stringify(obj, this.stringifyOptions)\n}\n\nQuerystring.prototype.parse = function (str) {\n  return (this.useQuerystring)\n    ? this.lib.parse(str,\n      this.parseOptions.sep || null,\n      this.parseOptions.eq || null,\n      this.parseOptions)\n    : this.lib.parse(str, this.parseOptions)\n}\n\nQuerystring.prototype.rfc3986 = function (str) {\n  return str.replace(/[!'()*]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\nQuerystring.prototype.unescape = querystring.unescape\n\nexports.Querystring = Querystring\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvcXVlcnlzdHJpbmcuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosU0FBUyxtQkFBTyxDQUFDLGdEQUFJO0FBQ3JCLGtCQUFrQixtQkFBTyxDQUFDLGdDQUFhOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYWdlLWZvcm0vLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvcXVlcnlzdHJpbmcuanM/N2M4NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxudmFyIHFzID0gcmVxdWlyZSgncXMnKVxudmFyIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKVxuXG5mdW5jdGlvbiBRdWVyeXN0cmluZyAocmVxdWVzdCkge1xuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0XG4gIHRoaXMubGliID0gbnVsbFxuICB0aGlzLnVzZVF1ZXJ5c3RyaW5nID0gbnVsbFxuICB0aGlzLnBhcnNlT3B0aW9ucyA9IG51bGxcbiAgdGhpcy5zdHJpbmdpZnlPcHRpb25zID0gbnVsbFxufVxuXG5RdWVyeXN0cmluZy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmICh0aGlzLmxpYikgeyByZXR1cm4gfVxuXG4gIHRoaXMudXNlUXVlcnlzdHJpbmcgPSBvcHRpb25zLnVzZVF1ZXJ5c3RyaW5nXG4gIHRoaXMubGliID0gKHRoaXMudXNlUXVlcnlzdHJpbmcgPyBxdWVyeXN0cmluZyA6IHFzKVxuXG4gIHRoaXMucGFyc2VPcHRpb25zID0gb3B0aW9ucy5xc1BhcnNlT3B0aW9ucyB8fCB7fVxuICB0aGlzLnN0cmluZ2lmeU9wdGlvbnMgPSBvcHRpb25zLnFzU3RyaW5naWZ5T3B0aW9ucyB8fCB7fVxufVxuXG5RdWVyeXN0cmluZy5wcm90b3R5cGUuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gKHRoaXMudXNlUXVlcnlzdHJpbmcpXG4gICAgPyB0aGlzLnJmYzM5ODYodGhpcy5saWIuc3RyaW5naWZ5KG9iaixcbiAgICAgIHRoaXMuc3RyaW5naWZ5T3B0aW9ucy5zZXAgfHwgbnVsbCxcbiAgICAgIHRoaXMuc3RyaW5naWZ5T3B0aW9ucy5lcSB8fCBudWxsLFxuICAgICAgdGhpcy5zdHJpbmdpZnlPcHRpb25zKSlcbiAgICA6IHRoaXMubGliLnN0cmluZ2lmeShvYmosIHRoaXMuc3RyaW5naWZ5T3B0aW9ucylcbn1cblxuUXVlcnlzdHJpbmcucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gKHRoaXMudXNlUXVlcnlzdHJpbmcpXG4gICAgPyB0aGlzLmxpYi5wYXJzZShzdHIsXG4gICAgICB0aGlzLnBhcnNlT3B0aW9ucy5zZXAgfHwgbnVsbCxcbiAgICAgIHRoaXMucGFyc2VPcHRpb25zLmVxIHx8IG51bGwsXG4gICAgICB0aGlzLnBhcnNlT3B0aW9ucylcbiAgICA6IHRoaXMubGliLnBhcnNlKHN0ciwgdGhpcy5wYXJzZU9wdGlvbnMpXG59XG5cblF1ZXJ5c3RyaW5nLnByb3RvdHlwZS5yZmMzOTg2ID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1shJygpKl0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cblF1ZXJ5c3RyaW5nLnByb3RvdHlwZS51bmVzY2FwZSA9IHF1ZXJ5c3RyaW5nLnVuZXNjYXBlXG5cbmV4cG9ydHMuUXVlcnlzdHJpbmcgPSBRdWVyeXN0cmluZ1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/request/lib/querystring.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/request/lib/redirect.js":
/*!**********************************************!*\
  !*** ./node_modules/request/lib/redirect.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar url = __webpack_require__(/*! url */ \"url\")\nvar isUrl = /^https?:/\n\nfunction Redirect (request) {\n  this.request = request\n  this.followRedirect = true\n  this.followRedirects = true\n  this.followAllRedirects = false\n  this.followOriginalHttpMethod = false\n  this.allowRedirect = function () { return true }\n  this.maxRedirects = 10\n  this.redirects = []\n  this.redirectsFollowed = 0\n  this.removeRefererHeader = false\n}\n\nRedirect.prototype.onRequest = function (options) {\n  var self = this\n\n  if (options.maxRedirects !== undefined) {\n    self.maxRedirects = options.maxRedirects\n  }\n  if (typeof options.followRedirect === 'function') {\n    self.allowRedirect = options.followRedirect\n  }\n  if (options.followRedirect !== undefined) {\n    self.followRedirects = !!options.followRedirect\n  }\n  if (options.followAllRedirects !== undefined) {\n    self.followAllRedirects = options.followAllRedirects\n  }\n  if (self.followRedirects || self.followAllRedirects) {\n    self.redirects = self.redirects || []\n  }\n  if (options.removeRefererHeader !== undefined) {\n    self.removeRefererHeader = options.removeRefererHeader\n  }\n  if (options.followOriginalHttpMethod !== undefined) {\n    self.followOriginalHttpMethod = options.followOriginalHttpMethod\n  }\n}\n\nRedirect.prototype.redirectTo = function (response) {\n  var self = this\n  var request = self.request\n\n  var redirectTo = null\n  if (response.statusCode >= 300 && response.statusCode < 400 && response.caseless.has('location')) {\n    var location = response.caseless.get('location')\n    request.debug('redirect', location)\n\n    if (self.followAllRedirects) {\n      redirectTo = location\n    } else if (self.followRedirects) {\n      switch (request.method) {\n        case 'PATCH':\n        case 'PUT':\n        case 'POST':\n        case 'DELETE':\n          // Do not follow redirects\n          break\n        default:\n          redirectTo = location\n          break\n      }\n    }\n  } else if (response.statusCode === 401) {\n    var authHeader = request._auth.onResponse(response)\n    if (authHeader) {\n      request.setHeader('authorization', authHeader)\n      redirectTo = request.uri\n    }\n  }\n  return redirectTo\n}\n\nRedirect.prototype.onResponse = function (response) {\n  var self = this\n  var request = self.request\n\n  var redirectTo = self.redirectTo(response)\n  if (!redirectTo || !self.allowRedirect.call(request, response)) {\n    return false\n  }\n\n  request.debug('redirect to', redirectTo)\n\n  // ignore any potential response body.  it cannot possibly be useful\n  // to us at this point.\n  // response.resume should be defined, but check anyway before calling. Workaround for browserify.\n  if (response.resume) {\n    response.resume()\n  }\n\n  if (self.redirectsFollowed >= self.maxRedirects) {\n    request.emit('error', new Error('Exceeded maxRedirects. Probably stuck in a redirect loop ' + request.uri.href))\n    return false\n  }\n  self.redirectsFollowed += 1\n\n  if (!isUrl.test(redirectTo)) {\n    redirectTo = url.resolve(request.uri.href, redirectTo)\n  }\n\n  var uriPrev = request.uri\n  request.uri = url.parse(redirectTo)\n\n  // handle the case where we change protocol from https to http or vice versa\n  if (request.uri.protocol !== uriPrev.protocol) {\n    delete request.agent\n  }\n\n  self.redirects.push({ statusCode: response.statusCode, redirectUri: redirectTo })\n\n  if (self.followAllRedirects && request.method !== 'HEAD' &&\n    response.statusCode !== 401 && response.statusCode !== 307) {\n    request.method = self.followOriginalHttpMethod ? request.method : 'GET'\n  }\n  // request.method = 'GET' // Force all redirects to use GET || commented out fixes #215\n  delete request.src\n  delete request.req\n  delete request._started\n  if (response.statusCode !== 401 && response.statusCode !== 307) {\n    // Remove parameters from the previous response, unless this is the second request\n    // for a server that requires digest authentication.\n    delete request.body\n    delete request._form\n    if (request.headers) {\n      request.removeHeader('host')\n      request.removeHeader('content-type')\n      request.removeHeader('content-length')\n      if (request.uri.hostname !== request.originalHost.split(':')[0]) {\n        // Remove authorization if changing hostnames (but not if just\n        // changing ports or protocols).  This matches the behavior of curl:\n        // https://github.com/bagder/curl/blob/6beb0eee/lib/http.c#L710\n        request.removeHeader('authorization')\n      }\n    }\n  }\n\n  if (!self.removeRefererHeader) {\n    request.setHeader('referer', uriPrev.href)\n  }\n\n  request.emit('redirect')\n\n  request.init()\n\n  return true\n}\n\nexports.Redirect = Redirect\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvcmVkaXJlY3QuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosVUFBVSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QiwwREFBMEQ7O0FBRWxGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BhZ2UtZm9ybS8uL25vZGVfbW9kdWxlcy9yZXF1ZXN0L2xpYi9yZWRpcmVjdC5qcz8wYTI3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJylcbnZhciBpc1VybCA9IC9eaHR0cHM/Oi9cblxuZnVuY3Rpb24gUmVkaXJlY3QgKHJlcXVlc3QpIHtcbiAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdFxuICB0aGlzLmZvbGxvd1JlZGlyZWN0ID0gdHJ1ZVxuICB0aGlzLmZvbGxvd1JlZGlyZWN0cyA9IHRydWVcbiAgdGhpcy5mb2xsb3dBbGxSZWRpcmVjdHMgPSBmYWxzZVxuICB0aGlzLmZvbGxvd09yaWdpbmFsSHR0cE1ldGhvZCA9IGZhbHNlXG4gIHRoaXMuYWxsb3dSZWRpcmVjdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWUgfVxuICB0aGlzLm1heFJlZGlyZWN0cyA9IDEwXG4gIHRoaXMucmVkaXJlY3RzID0gW11cbiAgdGhpcy5yZWRpcmVjdHNGb2xsb3dlZCA9IDBcbiAgdGhpcy5yZW1vdmVSZWZlcmVySGVhZGVyID0gZmFsc2Vcbn1cblxuUmVkaXJlY3QucHJvdG90eXBlLm9uUmVxdWVzdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGlmIChvcHRpb25zLm1heFJlZGlyZWN0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2VsZi5tYXhSZWRpcmVjdHMgPSBvcHRpb25zLm1heFJlZGlyZWN0c1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5mb2xsb3dSZWRpcmVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNlbGYuYWxsb3dSZWRpcmVjdCA9IG9wdGlvbnMuZm9sbG93UmVkaXJlY3RcbiAgfVxuICBpZiAob3B0aW9ucy5mb2xsb3dSZWRpcmVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2VsZi5mb2xsb3dSZWRpcmVjdHMgPSAhIW9wdGlvbnMuZm9sbG93UmVkaXJlY3RcbiAgfVxuICBpZiAob3B0aW9ucy5mb2xsb3dBbGxSZWRpcmVjdHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHNlbGYuZm9sbG93QWxsUmVkaXJlY3RzID0gb3B0aW9ucy5mb2xsb3dBbGxSZWRpcmVjdHNcbiAgfVxuICBpZiAoc2VsZi5mb2xsb3dSZWRpcmVjdHMgfHwgc2VsZi5mb2xsb3dBbGxSZWRpcmVjdHMpIHtcbiAgICBzZWxmLnJlZGlyZWN0cyA9IHNlbGYucmVkaXJlY3RzIHx8IFtdXG4gIH1cbiAgaWYgKG9wdGlvbnMucmVtb3ZlUmVmZXJlckhlYWRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2VsZi5yZW1vdmVSZWZlcmVySGVhZGVyID0gb3B0aW9ucy5yZW1vdmVSZWZlcmVySGVhZGVyXG4gIH1cbiAgaWYgKG9wdGlvbnMuZm9sbG93T3JpZ2luYWxIdHRwTWV0aG9kICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZWxmLmZvbGxvd09yaWdpbmFsSHR0cE1ldGhvZCA9IG9wdGlvbnMuZm9sbG93T3JpZ2luYWxIdHRwTWV0aG9kXG4gIH1cbn1cblxuUmVkaXJlY3QucHJvdG90eXBlLnJlZGlyZWN0VG8gPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciByZXF1ZXN0ID0gc2VsZi5yZXF1ZXN0XG5cbiAgdmFyIHJlZGlyZWN0VG8gPSBudWxsXG4gIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID49IDMwMCAmJiByZXNwb25zZS5zdGF0dXNDb2RlIDwgNDAwICYmIHJlc3BvbnNlLmNhc2VsZXNzLmhhcygnbG9jYXRpb24nKSkge1xuICAgIHZhciBsb2NhdGlvbiA9IHJlc3BvbnNlLmNhc2VsZXNzLmdldCgnbG9jYXRpb24nKVxuICAgIHJlcXVlc3QuZGVidWcoJ3JlZGlyZWN0JywgbG9jYXRpb24pXG5cbiAgICBpZiAoc2VsZi5mb2xsb3dBbGxSZWRpcmVjdHMpIHtcbiAgICAgIHJlZGlyZWN0VG8gPSBsb2NhdGlvblxuICAgIH0gZWxzZSBpZiAoc2VsZi5mb2xsb3dSZWRpcmVjdHMpIHtcbiAgICAgIHN3aXRjaCAocmVxdWVzdC5tZXRob2QpIHtcbiAgICAgICAgY2FzZSAnUEFUQ0gnOlxuICAgICAgICBjYXNlICdQVVQnOlxuICAgICAgICBjYXNlICdQT1NUJzpcbiAgICAgICAgY2FzZSAnREVMRVRFJzpcbiAgICAgICAgICAvLyBEbyBub3QgZm9sbG93IHJlZGlyZWN0c1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVkaXJlY3RUbyA9IGxvY2F0aW9uXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDAxKSB7XG4gICAgdmFyIGF1dGhIZWFkZXIgPSByZXF1ZXN0Ll9hdXRoLm9uUmVzcG9uc2UocmVzcG9uc2UpXG4gICAgaWYgKGF1dGhIZWFkZXIpIHtcbiAgICAgIHJlcXVlc3Quc2V0SGVhZGVyKCdhdXRob3JpemF0aW9uJywgYXV0aEhlYWRlcilcbiAgICAgIHJlZGlyZWN0VG8gPSByZXF1ZXN0LnVyaVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVkaXJlY3RUb1xufVxuXG5SZWRpcmVjdC5wcm90b3R5cGUub25SZXNwb25zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHJlcXVlc3QgPSBzZWxmLnJlcXVlc3RcblxuICB2YXIgcmVkaXJlY3RUbyA9IHNlbGYucmVkaXJlY3RUbyhyZXNwb25zZSlcbiAgaWYgKCFyZWRpcmVjdFRvIHx8ICFzZWxmLmFsbG93UmVkaXJlY3QuY2FsbChyZXF1ZXN0LCByZXNwb25zZSkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJlcXVlc3QuZGVidWcoJ3JlZGlyZWN0IHRvJywgcmVkaXJlY3RUbylcblxuICAvLyBpZ25vcmUgYW55IHBvdGVudGlhbCByZXNwb25zZSBib2R5LiAgaXQgY2Fubm90IHBvc3NpYmx5IGJlIHVzZWZ1bFxuICAvLyB0byB1cyBhdCB0aGlzIHBvaW50LlxuICAvLyByZXNwb25zZS5yZXN1bWUgc2hvdWxkIGJlIGRlZmluZWQsIGJ1dCBjaGVjayBhbnl3YXkgYmVmb3JlIGNhbGxpbmcuIFdvcmthcm91bmQgZm9yIGJyb3dzZXJpZnkuXG4gIGlmIChyZXNwb25zZS5yZXN1bWUpIHtcbiAgICByZXNwb25zZS5yZXN1bWUoKVxuICB9XG5cbiAgaWYgKHNlbGYucmVkaXJlY3RzRm9sbG93ZWQgPj0gc2VsZi5tYXhSZWRpcmVjdHMpIHtcbiAgICByZXF1ZXN0LmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdFeGNlZWRlZCBtYXhSZWRpcmVjdHMuIFByb2JhYmx5IHN0dWNrIGluIGEgcmVkaXJlY3QgbG9vcCAnICsgcmVxdWVzdC51cmkuaHJlZikpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgc2VsZi5yZWRpcmVjdHNGb2xsb3dlZCArPSAxXG5cbiAgaWYgKCFpc1VybC50ZXN0KHJlZGlyZWN0VG8pKSB7XG4gICAgcmVkaXJlY3RUbyA9IHVybC5yZXNvbHZlKHJlcXVlc3QudXJpLmhyZWYsIHJlZGlyZWN0VG8pXG4gIH1cblxuICB2YXIgdXJpUHJldiA9IHJlcXVlc3QudXJpXG4gIHJlcXVlc3QudXJpID0gdXJsLnBhcnNlKHJlZGlyZWN0VG8pXG5cbiAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHdlIGNoYW5nZSBwcm90b2NvbCBmcm9tIGh0dHBzIHRvIGh0dHAgb3IgdmljZSB2ZXJzYVxuICBpZiAocmVxdWVzdC51cmkucHJvdG9jb2wgIT09IHVyaVByZXYucHJvdG9jb2wpIHtcbiAgICBkZWxldGUgcmVxdWVzdC5hZ2VudFxuICB9XG5cbiAgc2VsZi5yZWRpcmVjdHMucHVzaCh7IHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1c0NvZGUsIHJlZGlyZWN0VXJpOiByZWRpcmVjdFRvIH0pXG5cbiAgaWYgKHNlbGYuZm9sbG93QWxsUmVkaXJlY3RzICYmIHJlcXVlc3QubWV0aG9kICE9PSAnSEVBRCcgJiZcbiAgICByZXNwb25zZS5zdGF0dXNDb2RlICE9PSA0MDEgJiYgcmVzcG9uc2Uuc3RhdHVzQ29kZSAhPT0gMzA3KSB7XG4gICAgcmVxdWVzdC5tZXRob2QgPSBzZWxmLmZvbGxvd09yaWdpbmFsSHR0cE1ldGhvZCA/IHJlcXVlc3QubWV0aG9kIDogJ0dFVCdcbiAgfVxuICAvLyByZXF1ZXN0Lm1ldGhvZCA9ICdHRVQnIC8vIEZvcmNlIGFsbCByZWRpcmVjdHMgdG8gdXNlIEdFVCB8fCBjb21tZW50ZWQgb3V0IGZpeGVzICMyMTVcbiAgZGVsZXRlIHJlcXVlc3Quc3JjXG4gIGRlbGV0ZSByZXF1ZXN0LnJlcVxuICBkZWxldGUgcmVxdWVzdC5fc3RhcnRlZFxuICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSAhPT0gNDAxICYmIHJlc3BvbnNlLnN0YXR1c0NvZGUgIT09IDMwNykge1xuICAgIC8vIFJlbW92ZSBwYXJhbWV0ZXJzIGZyb20gdGhlIHByZXZpb3VzIHJlc3BvbnNlLCB1bmxlc3MgdGhpcyBpcyB0aGUgc2Vjb25kIHJlcXVlc3RcbiAgICAvLyBmb3IgYSBzZXJ2ZXIgdGhhdCByZXF1aXJlcyBkaWdlc3QgYXV0aGVudGljYXRpb24uXG4gICAgZGVsZXRlIHJlcXVlc3QuYm9keVxuICAgIGRlbGV0ZSByZXF1ZXN0Ll9mb3JtXG4gICAgaWYgKHJlcXVlc3QuaGVhZGVycykge1xuICAgICAgcmVxdWVzdC5yZW1vdmVIZWFkZXIoJ2hvc3QnKVxuICAgICAgcmVxdWVzdC5yZW1vdmVIZWFkZXIoJ2NvbnRlbnQtdHlwZScpXG4gICAgICByZXF1ZXN0LnJlbW92ZUhlYWRlcignY29udGVudC1sZW5ndGgnKVxuICAgICAgaWYgKHJlcXVlc3QudXJpLmhvc3RuYW1lICE9PSByZXF1ZXN0Lm9yaWdpbmFsSG9zdC5zcGxpdCgnOicpWzBdKSB7XG4gICAgICAgIC8vIFJlbW92ZSBhdXRob3JpemF0aW9uIGlmIGNoYW5naW5nIGhvc3RuYW1lcyAoYnV0IG5vdCBpZiBqdXN0XG4gICAgICAgIC8vIGNoYW5naW5nIHBvcnRzIG9yIHByb3RvY29scykuICBUaGlzIG1hdGNoZXMgdGhlIGJlaGF2aW9yIG9mIGN1cmw6XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iYWdkZXIvY3VybC9ibG9iLzZiZWIwZWVlL2xpYi9odHRwLmMjTDcxMFxuICAgICAgICByZXF1ZXN0LnJlbW92ZUhlYWRlcignYXV0aG9yaXphdGlvbicpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzZWxmLnJlbW92ZVJlZmVyZXJIZWFkZXIpIHtcbiAgICByZXF1ZXN0LnNldEhlYWRlcigncmVmZXJlcicsIHVyaVByZXYuaHJlZilcbiAgfVxuXG4gIHJlcXVlc3QuZW1pdCgncmVkaXJlY3QnKVxuXG4gIHJlcXVlc3QuaW5pdCgpXG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZXhwb3J0cy5SZWRpcmVjdCA9IFJlZGlyZWN0XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/request/lib/redirect.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/request/lib/tunnel.js":
/*!********************************************!*\
  !*** ./node_modules/request/lib/tunnel.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar url = __webpack_require__(/*! url */ \"url\")\nvar tunnel = __webpack_require__(/*! tunnel-agent */ \"(rsc)/./node_modules/tunnel-agent/index.js\")\n\nvar defaultProxyHeaderWhiteList = [\n  'accept',\n  'accept-charset',\n  'accept-encoding',\n  'accept-language',\n  'accept-ranges',\n  'cache-control',\n  'content-encoding',\n  'content-language',\n  'content-location',\n  'content-md5',\n  'content-range',\n  'content-type',\n  'connection',\n  'date',\n  'expect',\n  'max-forwards',\n  'pragma',\n  'referer',\n  'te',\n  'user-agent',\n  'via'\n]\n\nvar defaultProxyHeaderExclusiveList = [\n  'proxy-authorization'\n]\n\nfunction constructProxyHost (uriObject) {\n  var port = uriObject.port\n  var protocol = uriObject.protocol\n  var proxyHost = uriObject.hostname + ':'\n\n  if (port) {\n    proxyHost += port\n  } else if (protocol === 'https:') {\n    proxyHost += '443'\n  } else {\n    proxyHost += '80'\n  }\n\n  return proxyHost\n}\n\nfunction constructProxyHeaderWhiteList (headers, proxyHeaderWhiteList) {\n  var whiteList = proxyHeaderWhiteList\n    .reduce(function (set, header) {\n      set[header.toLowerCase()] = true\n      return set\n    }, {})\n\n  return Object.keys(headers)\n    .filter(function (header) {\n      return whiteList[header.toLowerCase()]\n    })\n    .reduce(function (set, header) {\n      set[header] = headers[header]\n      return set\n    }, {})\n}\n\nfunction constructTunnelOptions (request, proxyHeaders) {\n  var proxy = request.proxy\n\n  var tunnelOptions = {\n    proxy: {\n      host: proxy.hostname,\n      port: +proxy.port,\n      proxyAuth: proxy.auth,\n      headers: proxyHeaders\n    },\n    headers: request.headers,\n    ca: request.ca,\n    cert: request.cert,\n    key: request.key,\n    passphrase: request.passphrase,\n    pfx: request.pfx,\n    ciphers: request.ciphers,\n    rejectUnauthorized: request.rejectUnauthorized,\n    secureOptions: request.secureOptions,\n    secureProtocol: request.secureProtocol\n  }\n\n  return tunnelOptions\n}\n\nfunction constructTunnelFnName (uri, proxy) {\n  var uriProtocol = (uri.protocol === 'https:' ? 'https' : 'http')\n  var proxyProtocol = (proxy.protocol === 'https:' ? 'Https' : 'Http')\n  return [uriProtocol, proxyProtocol].join('Over')\n}\n\nfunction getTunnelFn (request) {\n  var uri = request.uri\n  var proxy = request.proxy\n  var tunnelFnName = constructTunnelFnName(uri, proxy)\n  return tunnel[tunnelFnName]\n}\n\nfunction Tunnel (request) {\n  this.request = request\n  this.proxyHeaderWhiteList = defaultProxyHeaderWhiteList\n  this.proxyHeaderExclusiveList = []\n  if (typeof request.tunnel !== 'undefined') {\n    this.tunnelOverride = request.tunnel\n  }\n}\n\nTunnel.prototype.isEnabled = function () {\n  var self = this\n  var request = self.request\n    // Tunnel HTTPS by default. Allow the user to override this setting.\n\n  // If self.tunnelOverride is set (the user specified a value), use it.\n  if (typeof self.tunnelOverride !== 'undefined') {\n    return self.tunnelOverride\n  }\n\n  // If the destination is HTTPS, tunnel.\n  if (request.uri.protocol === 'https:') {\n    return true\n  }\n\n  // Otherwise, do not use tunnel.\n  return false\n}\n\nTunnel.prototype.setup = function (options) {\n  var self = this\n  var request = self.request\n\n  options = options || {}\n\n  if (typeof request.proxy === 'string') {\n    request.proxy = url.parse(request.proxy)\n  }\n\n  if (!request.proxy || !request.tunnel) {\n    return false\n  }\n\n  // Setup Proxy Header Exclusive List and White List\n  if (options.proxyHeaderWhiteList) {\n    self.proxyHeaderWhiteList = options.proxyHeaderWhiteList\n  }\n  if (options.proxyHeaderExclusiveList) {\n    self.proxyHeaderExclusiveList = options.proxyHeaderExclusiveList\n  }\n\n  var proxyHeaderExclusiveList = self.proxyHeaderExclusiveList.concat(defaultProxyHeaderExclusiveList)\n  var proxyHeaderWhiteList = self.proxyHeaderWhiteList.concat(proxyHeaderExclusiveList)\n\n  // Setup Proxy Headers and Proxy Headers Host\n  // Only send the Proxy White Listed Header names\n  var proxyHeaders = constructProxyHeaderWhiteList(request.headers, proxyHeaderWhiteList)\n  proxyHeaders.host = constructProxyHost(request.uri)\n\n  proxyHeaderExclusiveList.forEach(request.removeHeader, request)\n\n  // Set Agent from Tunnel Data\n  var tunnelFn = getTunnelFn(request)\n  var tunnelOptions = constructTunnelOptions(request, proxyHeaders)\n  request.agent = tunnelFn(tunnelOptions)\n\n  return true\n}\n\nTunnel.defaultProxyHeaderWhiteList = defaultProxyHeaderWhiteList\nTunnel.defaultProxyHeaderExclusiveList = defaultProxyHeaderExclusiveList\nexports.Tunnel = Tunnel\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvdHVubmVsLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFVBQVUsbUJBQU8sQ0FBQyxnQkFBSztBQUN2QixhQUFhLG1CQUFPLENBQUMsZ0VBQWM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYWdlLWZvcm0vLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvdHVubmVsLmpzP2E2NzkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKVxudmFyIHR1bm5lbCA9IHJlcXVpcmUoJ3R1bm5lbC1hZ2VudCcpXG5cbnZhciBkZWZhdWx0UHJveHlIZWFkZXJXaGl0ZUxpc3QgPSBbXG4gICdhY2NlcHQnLFxuICAnYWNjZXB0LWNoYXJzZXQnLFxuICAnYWNjZXB0LWVuY29kaW5nJyxcbiAgJ2FjY2VwdC1sYW5ndWFnZScsXG4gICdhY2NlcHQtcmFuZ2VzJyxcbiAgJ2NhY2hlLWNvbnRyb2wnLFxuICAnY29udGVudC1lbmNvZGluZycsXG4gICdjb250ZW50LWxhbmd1YWdlJyxcbiAgJ2NvbnRlbnQtbG9jYXRpb24nLFxuICAnY29udGVudC1tZDUnLFxuICAnY29udGVudC1yYW5nZScsXG4gICdjb250ZW50LXR5cGUnLFxuICAnY29ubmVjdGlvbicsXG4gICdkYXRlJyxcbiAgJ2V4cGVjdCcsXG4gICdtYXgtZm9yd2FyZHMnLFxuICAncHJhZ21hJyxcbiAgJ3JlZmVyZXInLFxuICAndGUnLFxuICAndXNlci1hZ2VudCcsXG4gICd2aWEnXG5dXG5cbnZhciBkZWZhdWx0UHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0ID0gW1xuICAncHJveHktYXV0aG9yaXphdGlvbidcbl1cblxuZnVuY3Rpb24gY29uc3RydWN0UHJveHlIb3N0ICh1cmlPYmplY3QpIHtcbiAgdmFyIHBvcnQgPSB1cmlPYmplY3QucG9ydFxuICB2YXIgcHJvdG9jb2wgPSB1cmlPYmplY3QucHJvdG9jb2xcbiAgdmFyIHByb3h5SG9zdCA9IHVyaU9iamVjdC5ob3N0bmFtZSArICc6J1xuXG4gIGlmIChwb3J0KSB7XG4gICAgcHJveHlIb3N0ICs9IHBvcnRcbiAgfSBlbHNlIGlmIChwcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICBwcm94eUhvc3QgKz0gJzQ0MydcbiAgfSBlbHNlIHtcbiAgICBwcm94eUhvc3QgKz0gJzgwJ1xuICB9XG5cbiAgcmV0dXJuIHByb3h5SG9zdFxufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RQcm94eUhlYWRlcldoaXRlTGlzdCAoaGVhZGVycywgcHJveHlIZWFkZXJXaGl0ZUxpc3QpIHtcbiAgdmFyIHdoaXRlTGlzdCA9IHByb3h5SGVhZGVyV2hpdGVMaXN0XG4gICAgLnJlZHVjZShmdW5jdGlvbiAoc2V0LCBoZWFkZXIpIHtcbiAgICAgIHNldFtoZWFkZXIudG9Mb3dlckNhc2UoKV0gPSB0cnVlXG4gICAgICByZXR1cm4gc2V0XG4gICAgfSwge30pXG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKGhlYWRlcnMpXG4gICAgLmZpbHRlcihmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICByZXR1cm4gd2hpdGVMaXN0W2hlYWRlci50b0xvd2VyQ2FzZSgpXVxuICAgIH0pXG4gICAgLnJlZHVjZShmdW5jdGlvbiAoc2V0LCBoZWFkZXIpIHtcbiAgICAgIHNldFtoZWFkZXJdID0gaGVhZGVyc1toZWFkZXJdXG4gICAgICByZXR1cm4gc2V0XG4gICAgfSwge30pXG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFR1bm5lbE9wdGlvbnMgKHJlcXVlc3QsIHByb3h5SGVhZGVycykge1xuICB2YXIgcHJveHkgPSByZXF1ZXN0LnByb3h5XG5cbiAgdmFyIHR1bm5lbE9wdGlvbnMgPSB7XG4gICAgcHJveHk6IHtcbiAgICAgIGhvc3Q6IHByb3h5Lmhvc3RuYW1lLFxuICAgICAgcG9ydDogK3Byb3h5LnBvcnQsXG4gICAgICBwcm94eUF1dGg6IHByb3h5LmF1dGgsXG4gICAgICBoZWFkZXJzOiBwcm94eUhlYWRlcnNcbiAgICB9LFxuICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICBjYTogcmVxdWVzdC5jYSxcbiAgICBjZXJ0OiByZXF1ZXN0LmNlcnQsXG4gICAga2V5OiByZXF1ZXN0LmtleSxcbiAgICBwYXNzcGhyYXNlOiByZXF1ZXN0LnBhc3NwaHJhc2UsXG4gICAgcGZ4OiByZXF1ZXN0LnBmeCxcbiAgICBjaXBoZXJzOiByZXF1ZXN0LmNpcGhlcnMsXG4gICAgcmVqZWN0VW5hdXRob3JpemVkOiByZXF1ZXN0LnJlamVjdFVuYXV0aG9yaXplZCxcbiAgICBzZWN1cmVPcHRpb25zOiByZXF1ZXN0LnNlY3VyZU9wdGlvbnMsXG4gICAgc2VjdXJlUHJvdG9jb2w6IHJlcXVlc3Quc2VjdXJlUHJvdG9jb2xcbiAgfVxuXG4gIHJldHVybiB0dW5uZWxPcHRpb25zXG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFR1bm5lbEZuTmFtZSAodXJpLCBwcm94eSkge1xuICB2YXIgdXJpUHJvdG9jb2wgPSAodXJpLnByb3RvY29sID09PSAnaHR0cHM6JyA/ICdodHRwcycgOiAnaHR0cCcpXG4gIHZhciBwcm94eVByb3RvY29sID0gKHByb3h5LnByb3RvY29sID09PSAnaHR0cHM6JyA/ICdIdHRwcycgOiAnSHR0cCcpXG4gIHJldHVybiBbdXJpUHJvdG9jb2wsIHByb3h5UHJvdG9jb2xdLmpvaW4oJ092ZXInKVxufVxuXG5mdW5jdGlvbiBnZXRUdW5uZWxGbiAocmVxdWVzdCkge1xuICB2YXIgdXJpID0gcmVxdWVzdC51cmlcbiAgdmFyIHByb3h5ID0gcmVxdWVzdC5wcm94eVxuICB2YXIgdHVubmVsRm5OYW1lID0gY29uc3RydWN0VHVubmVsRm5OYW1lKHVyaSwgcHJveHkpXG4gIHJldHVybiB0dW5uZWxbdHVubmVsRm5OYW1lXVxufVxuXG5mdW5jdGlvbiBUdW5uZWwgKHJlcXVlc3QpIHtcbiAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdFxuICB0aGlzLnByb3h5SGVhZGVyV2hpdGVMaXN0ID0gZGVmYXVsdFByb3h5SGVhZGVyV2hpdGVMaXN0XG4gIHRoaXMucHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0ID0gW11cbiAgaWYgKHR5cGVvZiByZXF1ZXN0LnR1bm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLnR1bm5lbE92ZXJyaWRlID0gcmVxdWVzdC50dW5uZWxcbiAgfVxufVxuXG5UdW5uZWwucHJvdG90eXBlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciByZXF1ZXN0ID0gc2VsZi5yZXF1ZXN0XG4gICAgLy8gVHVubmVsIEhUVFBTIGJ5IGRlZmF1bHQuIEFsbG93IHRoZSB1c2VyIHRvIG92ZXJyaWRlIHRoaXMgc2V0dGluZy5cblxuICAvLyBJZiBzZWxmLnR1bm5lbE92ZXJyaWRlIGlzIHNldCAodGhlIHVzZXIgc3BlY2lmaWVkIGEgdmFsdWUpLCB1c2UgaXQuXG4gIGlmICh0eXBlb2Ygc2VsZi50dW5uZWxPdmVycmlkZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gc2VsZi50dW5uZWxPdmVycmlkZVxuICB9XG5cbiAgLy8gSWYgdGhlIGRlc3RpbmF0aW9uIGlzIEhUVFBTLCB0dW5uZWwuXG4gIGlmIChyZXF1ZXN0LnVyaS5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCBkbyBub3QgdXNlIHR1bm5lbC5cbiAgcmV0dXJuIGZhbHNlXG59XG5cblR1bm5lbC5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHJlcXVlc3QgPSBzZWxmLnJlcXVlc3RcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIGlmICh0eXBlb2YgcmVxdWVzdC5wcm94eSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXF1ZXN0LnByb3h5ID0gdXJsLnBhcnNlKHJlcXVlc3QucHJveHkpXG4gIH1cblxuICBpZiAoIXJlcXVlc3QucHJveHkgfHwgIXJlcXVlc3QudHVubmVsKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBTZXR1cCBQcm94eSBIZWFkZXIgRXhjbHVzaXZlIExpc3QgYW5kIFdoaXRlIExpc3RcbiAgaWYgKG9wdGlvbnMucHJveHlIZWFkZXJXaGl0ZUxpc3QpIHtcbiAgICBzZWxmLnByb3h5SGVhZGVyV2hpdGVMaXN0ID0gb3B0aW9ucy5wcm94eUhlYWRlcldoaXRlTGlzdFxuICB9XG4gIGlmIChvcHRpb25zLnByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdCkge1xuICAgIHNlbGYucHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0ID0gb3B0aW9ucy5wcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3RcbiAgfVxuXG4gIHZhciBwcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QgPSBzZWxmLnByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdC5jb25jYXQoZGVmYXVsdFByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdClcbiAgdmFyIHByb3h5SGVhZGVyV2hpdGVMaXN0ID0gc2VsZi5wcm94eUhlYWRlcldoaXRlTGlzdC5jb25jYXQocHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0KVxuXG4gIC8vIFNldHVwIFByb3h5IEhlYWRlcnMgYW5kIFByb3h5IEhlYWRlcnMgSG9zdFxuICAvLyBPbmx5IHNlbmQgdGhlIFByb3h5IFdoaXRlIExpc3RlZCBIZWFkZXIgbmFtZXNcbiAgdmFyIHByb3h5SGVhZGVycyA9IGNvbnN0cnVjdFByb3h5SGVhZGVyV2hpdGVMaXN0KHJlcXVlc3QuaGVhZGVycywgcHJveHlIZWFkZXJXaGl0ZUxpc3QpXG4gIHByb3h5SGVhZGVycy5ob3N0ID0gY29uc3RydWN0UHJveHlIb3N0KHJlcXVlc3QudXJpKVxuXG4gIHByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdC5mb3JFYWNoKHJlcXVlc3QucmVtb3ZlSGVhZGVyLCByZXF1ZXN0KVxuXG4gIC8vIFNldCBBZ2VudCBmcm9tIFR1bm5lbCBEYXRhXG4gIHZhciB0dW5uZWxGbiA9IGdldFR1bm5lbEZuKHJlcXVlc3QpXG4gIHZhciB0dW5uZWxPcHRpb25zID0gY29uc3RydWN0VHVubmVsT3B0aW9ucyhyZXF1ZXN0LCBwcm94eUhlYWRlcnMpXG4gIHJlcXVlc3QuYWdlbnQgPSB0dW5uZWxGbih0dW5uZWxPcHRpb25zKVxuXG4gIHJldHVybiB0cnVlXG59XG5cblR1bm5lbC5kZWZhdWx0UHJveHlIZWFkZXJXaGl0ZUxpc3QgPSBkZWZhdWx0UHJveHlIZWFkZXJXaGl0ZUxpc3RcblR1bm5lbC5kZWZhdWx0UHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0ID0gZGVmYXVsdFByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdFxuZXhwb3J0cy5UdW5uZWwgPSBUdW5uZWxcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/request/lib/tunnel.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/request/node_modules/form-data/lib/form_data.js":
/*!**********************************************************************!*\
  !*** ./node_modules/request/node_modules/form-data/lib/form_data.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var CombinedStream = __webpack_require__(/*! combined-stream */ \"(rsc)/./node_modules/combined-stream/lib/combined_stream.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar http = __webpack_require__(/*! http */ \"http\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar parseUrl = (__webpack_require__(/*! url */ \"url\").parse);\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar mime = __webpack_require__(/*! mime-types */ \"(rsc)/./node_modules/mime-types/index.js\");\nvar asynckit = __webpack_require__(/*! asynckit */ \"(rsc)/./node_modules/asynckit/index.js\");\nvar populate = __webpack_require__(/*! ./populate.js */ \"(rsc)/./node_modules/request/node_modules/form-data/lib/populate.js\");\n\n// Public API\nmodule.exports = FormData;\n\n// make it a Stream\nutil.inherits(FormData, CombinedStream);\n\n/**\n * Create readable \"multipart/form-data\" streams.\n * Can be used to submit forms\n * and file uploads to other web applications.\n *\n * @constructor\n * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream\n */\nfunction FormData(options) {\n  if (!(this instanceof FormData)) {\n    return new FormData();\n  }\n\n  this._overheadLength = 0;\n  this._valueLength = 0;\n  this._valuesToMeasure = [];\n\n  CombinedStream.call(this);\n\n  options = options || {};\n  for (var option in options) {\n    this[option] = options[option];\n  }\n}\n\nFormData.LINE_BREAK = '\\r\\n';\nFormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';\n\nFormData.prototype.append = function(field, value, options) {\n\n  options = options || {};\n\n  // allow filename as single option\n  if (typeof options == 'string') {\n    options = {filename: options};\n  }\n\n  var append = CombinedStream.prototype.append.bind(this);\n\n  // all that streamy business can't handle numbers\n  if (typeof value == 'number') {\n    value = '' + value;\n  }\n\n  // https://github.com/felixge/node-form-data/issues/38\n  if (util.isArray(value)) {\n    // Please convert your array into string\n    // the way web server expects it\n    this._error(new Error('Arrays are not supported.'));\n    return;\n  }\n\n  var header = this._multiPartHeader(field, value, options);\n  var footer = this._multiPartFooter();\n\n  append(header);\n  append(value);\n  append(footer);\n\n  // pass along options.knownLength\n  this._trackLength(header, value, options);\n};\n\nFormData.prototype._trackLength = function(header, value, options) {\n  var valueLength = 0;\n\n  // used w/ getLengthSync(), when length is known.\n  // e.g. for streaming directly from a remote server,\n  // w/ a known file a size, and not wanting to wait for\n  // incoming file to finish to get its size.\n  if (options.knownLength != null) {\n    valueLength += +options.knownLength;\n  } else if (Buffer.isBuffer(value)) {\n    valueLength = value.length;\n  } else if (typeof value === 'string') {\n    valueLength = Buffer.byteLength(value);\n  }\n\n  this._valueLength += valueLength;\n\n  // @check why add CRLF? does this account for custom/multiple CRLFs?\n  this._overheadLength +=\n    Buffer.byteLength(header) +\n    FormData.LINE_BREAK.length;\n\n  // empty or either doesn't have path or not an http response\n  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) )) {\n    return;\n  }\n\n  // no need to bother with the length\n  if (!options.knownLength) {\n    this._valuesToMeasure.push(value);\n  }\n};\n\nFormData.prototype._lengthRetriever = function(value, callback) {\n\n  if (value.hasOwnProperty('fd')) {\n\n    // take read range into a account\n    // `end` = Infinity > read file till the end\n    //\n    // TODO: Looks like there is bug in Node fs.createReadStream\n    // it doesn't respect `end` options without `start` options\n    // Fix it when node fixes it.\n    // https://github.com/joyent/node/issues/7819\n    if (value.end != undefined && value.end != Infinity && value.start != undefined) {\n\n      // when end specified\n      // no need to calculate range\n      // inclusive, starts with 0\n      callback(null, value.end + 1 - (value.start ? value.start : 0));\n\n    // not that fast snoopy\n    } else {\n      // still need to fetch file size from fs\n      fs.stat(value.path, function(err, stat) {\n\n        var fileSize;\n\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        // update final size based on the range options\n        fileSize = stat.size - (value.start ? value.start : 0);\n        callback(null, fileSize);\n      });\n    }\n\n  // or http response\n  } else if (value.hasOwnProperty('httpVersion')) {\n    callback(null, +value.headers['content-length']);\n\n  // or request stream http://github.com/mikeal/request\n  } else if (value.hasOwnProperty('httpModule')) {\n    // wait till response come back\n    value.on('response', function(response) {\n      value.pause();\n      callback(null, +response.headers['content-length']);\n    });\n    value.resume();\n\n  // something else\n  } else {\n    callback('Unknown stream');\n  }\n};\n\nFormData.prototype._multiPartHeader = function(field, value, options) {\n  // custom header specified (as string)?\n  // it becomes responsible for boundary\n  // (e.g. to handle extra CRLFs on .NET servers)\n  if (typeof options.header == 'string') {\n    return options.header;\n  }\n\n  var contentDisposition = this._getContentDisposition(value, options);\n  var contentType = this._getContentType(value, options);\n\n  var contents = '';\n  var headers  = {\n    // add custom disposition as third element or keep it two elements if not\n    'Content-Disposition': ['form-data', 'name=\"' + field + '\"'].concat(contentDisposition || []),\n    // if no content type. allow it to be empty array\n    'Content-Type': [].concat(contentType || [])\n  };\n\n  // allow custom headers.\n  if (typeof options.header == 'object') {\n    populate(headers, options.header);\n  }\n\n  var header;\n  for (var prop in headers) {\n    if (!headers.hasOwnProperty(prop)) continue;\n    header = headers[prop];\n\n    // skip nullish headers.\n    if (header == null) {\n      continue;\n    }\n\n    // convert all headers to arrays.\n    if (!Array.isArray(header)) {\n      header = [header];\n    }\n\n    // add non-empty headers.\n    if (header.length) {\n      contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;\n    }\n  }\n\n  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;\n};\n\nFormData.prototype._getContentDisposition = function(value, options) {\n\n  var filename\n    , contentDisposition\n    ;\n\n  if (typeof options.filepath === 'string') {\n    // custom filepath for relative paths\n    filename = path.normalize(options.filepath).replace(/\\\\/g, '/');\n  } else if (options.filename || value.name || value.path) {\n    // custom filename take precedence\n    // formidable and the browser add a name property\n    // fs- and request- streams have path property\n    filename = path.basename(options.filename || value.name || value.path);\n  } else if (value.readable && value.hasOwnProperty('httpVersion')) {\n    // or try http response\n    filename = path.basename(value.client._httpMessage.path);\n  }\n\n  if (filename) {\n    contentDisposition = 'filename=\"' + filename + '\"';\n  }\n\n  return contentDisposition;\n};\n\nFormData.prototype._getContentType = function(value, options) {\n\n  // use custom content-type above all\n  var contentType = options.contentType;\n\n  // or try `name` from formidable, browser\n  if (!contentType && value.name) {\n    contentType = mime.lookup(value.name);\n  }\n\n  // or try `path` from fs-, request- streams\n  if (!contentType && value.path) {\n    contentType = mime.lookup(value.path);\n  }\n\n  // or if it's http-reponse\n  if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {\n    contentType = value.headers['content-type'];\n  }\n\n  // or guess it from the filepath or filename\n  if (!contentType && (options.filepath || options.filename)) {\n    contentType = mime.lookup(options.filepath || options.filename);\n  }\n\n  // fallback to the default content type if `value` is not simple value\n  if (!contentType && typeof value == 'object') {\n    contentType = FormData.DEFAULT_CONTENT_TYPE;\n  }\n\n  return contentType;\n};\n\nFormData.prototype._multiPartFooter = function() {\n  return function(next) {\n    var footer = FormData.LINE_BREAK;\n\n    var lastPart = (this._streams.length === 0);\n    if (lastPart) {\n      footer += this._lastBoundary();\n    }\n\n    next(footer);\n  }.bind(this);\n};\n\nFormData.prototype._lastBoundary = function() {\n  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;\n};\n\nFormData.prototype.getHeaders = function(userHeaders) {\n  var header;\n  var formHeaders = {\n    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()\n  };\n\n  for (header in userHeaders) {\n    if (userHeaders.hasOwnProperty(header)) {\n      formHeaders[header.toLowerCase()] = userHeaders[header];\n    }\n  }\n\n  return formHeaders;\n};\n\nFormData.prototype.getBoundary = function() {\n  if (!this._boundary) {\n    this._generateBoundary();\n  }\n\n  return this._boundary;\n};\n\nFormData.prototype._generateBoundary = function() {\n  // This generates a 50 character boundary similar to those used by Firefox.\n  // They are optimized for boyer-moore parsing.\n  var boundary = '--------------------------';\n  for (var i = 0; i < 24; i++) {\n    boundary += Math.floor(Math.random() * 10).toString(16);\n  }\n\n  this._boundary = boundary;\n};\n\n// Note: getLengthSync DOESN'T calculate streams length\n// As workaround one can calculate file size manually\n// and add it as knownLength option\nFormData.prototype.getLengthSync = function() {\n  var knownLength = this._overheadLength + this._valueLength;\n\n  // Don't get confused, there are 3 \"internal\" streams for each keyval pair\n  // so it basically checks if there is any value added to the form\n  if (this._streams.length) {\n    knownLength += this._lastBoundary().length;\n  }\n\n  // https://github.com/form-data/form-data/issues/40\n  if (!this.hasKnownLength()) {\n    // Some async length retrievers are present\n    // therefore synchronous length calculation is false.\n    // Please use getLength(callback) to get proper length\n    this._error(new Error('Cannot calculate proper length in synchronous way.'));\n  }\n\n  return knownLength;\n};\n\n// Public API to check if length of added values is known\n// https://github.com/form-data/form-data/issues/196\n// https://github.com/form-data/form-data/issues/262\nFormData.prototype.hasKnownLength = function() {\n  var hasKnownLength = true;\n\n  if (this._valuesToMeasure.length) {\n    hasKnownLength = false;\n  }\n\n  return hasKnownLength;\n};\n\nFormData.prototype.getLength = function(cb) {\n  var knownLength = this._overheadLength + this._valueLength;\n\n  if (this._streams.length) {\n    knownLength += this._lastBoundary().length;\n  }\n\n  if (!this._valuesToMeasure.length) {\n    process.nextTick(cb.bind(this, null, knownLength));\n    return;\n  }\n\n  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {\n    if (err) {\n      cb(err);\n      return;\n    }\n\n    values.forEach(function(length) {\n      knownLength += length;\n    });\n\n    cb(null, knownLength);\n  });\n};\n\nFormData.prototype.submit = function(params, cb) {\n  var request\n    , options\n    , defaults = {method: 'post'}\n    ;\n\n  // parse provided url if it's string\n  // or treat it as options object\n  if (typeof params == 'string') {\n\n    params = parseUrl(params);\n    options = populate({\n      port: params.port,\n      path: params.pathname,\n      host: params.hostname,\n      protocol: params.protocol\n    }, defaults);\n\n  // use custom params\n  } else {\n\n    options = populate(params, defaults);\n    // if no port provided use default one\n    if (!options.port) {\n      options.port = options.protocol == 'https:' ? 443 : 80;\n    }\n  }\n\n  // put that good code in getHeaders to some use\n  options.headers = this.getHeaders(params.headers);\n\n  // https if specified, fallback to http in any other case\n  if (options.protocol == 'https:') {\n    request = https.request(options);\n  } else {\n    request = http.request(options);\n  }\n\n  // get content length and fire away\n  this.getLength(function(err, length) {\n    if (err) {\n      this._error(err);\n      return;\n    }\n\n    // add content length\n    request.setHeader('Content-Length', length);\n\n    this.pipe(request);\n    if (cb) {\n      request.on('error', cb);\n      request.on('response', cb.bind(this, null));\n    }\n  }.bind(this));\n\n  return request;\n};\n\nFormData.prototype._error = function(err) {\n  if (!this.error) {\n    this.error = err;\n    this.pause();\n    this.emit('error', err);\n  }\n};\n\nFormData.prototype.toString = function () {\n  return '[object FormData]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9mb3JtX2RhdGEuanMiLCJtYXBwaW5ncyI6IkFBQUEscUJBQXFCLG1CQUFPLENBQUMsb0ZBQWlCO0FBQzlDLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLFlBQVksbUJBQU8sQ0FBQyxvQkFBTztBQUMzQixlQUFlLDZDQUFvQjtBQUNuQyxTQUFTLG1CQUFPLENBQUMsY0FBSTtBQUNyQixXQUFXLG1CQUFPLENBQUMsNERBQVk7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLHdEQUFVO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQywwRkFBZTs7QUFFdEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGFnZS1mb3JtLy4vbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2Zvcm0tZGF0YS9saWIvZm9ybV9kYXRhLmpzP2IzNjAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIENvbWJpbmVkU3RyZWFtID0gcmVxdWlyZSgnY29tYmluZWQtc3RyZWFtJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG52YXIgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xudmFyIHBhcnNlVXJsID0gcmVxdWlyZSgndXJsJykucGFyc2U7XG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIG1pbWUgPSByZXF1aXJlKCdtaW1lLXR5cGVzJyk7XG52YXIgYXN5bmNraXQgPSByZXF1aXJlKCdhc3luY2tpdCcpO1xudmFyIHBvcHVsYXRlID0gcmVxdWlyZSgnLi9wb3B1bGF0ZS5qcycpO1xuXG4vLyBQdWJsaWMgQVBJXG5tb2R1bGUuZXhwb3J0cyA9IEZvcm1EYXRhO1xuXG4vLyBtYWtlIGl0IGEgU3RyZWFtXG51dGlsLmluaGVyaXRzKEZvcm1EYXRhLCBDb21iaW5lZFN0cmVhbSk7XG5cbi8qKlxuICogQ3JlYXRlIHJlYWRhYmxlIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiIHN0cmVhbXMuXG4gKiBDYW4gYmUgdXNlZCB0byBzdWJtaXQgZm9ybXNcbiAqIGFuZCBmaWxlIHVwbG9hZHMgdG8gb3RoZXIgd2ViIGFwcGxpY2F0aW9ucy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUHJvcGVydGllcyB0byBiZSBhZGRlZC9vdmVycmlkZW4gZm9yIEZvcm1EYXRhIGFuZCBDb21iaW5lZFN0cmVhbVxuICovXG5mdW5jdGlvbiBGb3JtRGF0YShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGb3JtRGF0YSkpIHtcbiAgICByZXR1cm4gbmV3IEZvcm1EYXRhKCk7XG4gIH1cblxuICB0aGlzLl9vdmVyaGVhZExlbmd0aCA9IDA7XG4gIHRoaXMuX3ZhbHVlTGVuZ3RoID0gMDtcbiAgdGhpcy5fdmFsdWVzVG9NZWFzdXJlID0gW107XG5cbiAgQ29tYmluZWRTdHJlYW0uY2FsbCh0aGlzKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgZm9yICh2YXIgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICB0aGlzW29wdGlvbl0gPSBvcHRpb25zW29wdGlvbl07XG4gIH1cbn1cblxuRm9ybURhdGEuTElORV9CUkVBSyA9ICdcXHJcXG4nO1xuRm9ybURhdGEuREVGQVVMVF9DT05URU5UX1RZUEUgPSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcblxuRm9ybURhdGEucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKGZpZWxkLCB2YWx1ZSwgb3B0aW9ucykge1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIGFsbG93IGZpbGVuYW1lIGFzIHNpbmdsZSBvcHRpb25cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHtmaWxlbmFtZTogb3B0aW9uc307XG4gIH1cblxuICB2YXIgYXBwZW5kID0gQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLmFwcGVuZC5iaW5kKHRoaXMpO1xuXG4gIC8vIGFsbCB0aGF0IHN0cmVhbXkgYnVzaW5lc3MgY2FuJ3QgaGFuZGxlIG51bWJlcnNcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHZhbHVlID0gJycgKyB2YWx1ZTtcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZWxpeGdlL25vZGUtZm9ybS1kYXRhL2lzc3Vlcy8zOFxuICBpZiAodXRpbC5pc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFBsZWFzZSBjb252ZXJ0IHlvdXIgYXJyYXkgaW50byBzdHJpbmdcbiAgICAvLyB0aGUgd2F5IHdlYiBzZXJ2ZXIgZXhwZWN0cyBpdFxuICAgIHRoaXMuX2Vycm9yKG5ldyBFcnJvcignQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkLicpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaGVhZGVyID0gdGhpcy5fbXVsdGlQYXJ0SGVhZGVyKGZpZWxkLCB2YWx1ZSwgb3B0aW9ucyk7XG4gIHZhciBmb290ZXIgPSB0aGlzLl9tdWx0aVBhcnRGb290ZXIoKTtcblxuICBhcHBlbmQoaGVhZGVyKTtcbiAgYXBwZW5kKHZhbHVlKTtcbiAgYXBwZW5kKGZvb3Rlcik7XG5cbiAgLy8gcGFzcyBhbG9uZyBvcHRpb25zLmtub3duTGVuZ3RoXG4gIHRoaXMuX3RyYWNrTGVuZ3RoKGhlYWRlciwgdmFsdWUsIG9wdGlvbnMpO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLl90cmFja0xlbmd0aCA9IGZ1bmN0aW9uKGhlYWRlciwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIHZhbHVlTGVuZ3RoID0gMDtcblxuICAvLyB1c2VkIHcvIGdldExlbmd0aFN5bmMoKSwgd2hlbiBsZW5ndGggaXMga25vd24uXG4gIC8vIGUuZy4gZm9yIHN0cmVhbWluZyBkaXJlY3RseSBmcm9tIGEgcmVtb3RlIHNlcnZlcixcbiAgLy8gdy8gYSBrbm93biBmaWxlIGEgc2l6ZSwgYW5kIG5vdCB3YW50aW5nIHRvIHdhaXQgZm9yXG4gIC8vIGluY29taW5nIGZpbGUgdG8gZmluaXNoIHRvIGdldCBpdHMgc2l6ZS5cbiAgaWYgKG9wdGlvbnMua25vd25MZW5ndGggIT0gbnVsbCkge1xuICAgIHZhbHVlTGVuZ3RoICs9ICtvcHRpb25zLmtub3duTGVuZ3RoO1xuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICB2YWx1ZUxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSk7XG4gIH1cblxuICB0aGlzLl92YWx1ZUxlbmd0aCArPSB2YWx1ZUxlbmd0aDtcblxuICAvLyBAY2hlY2sgd2h5IGFkZCBDUkxGPyBkb2VzIHRoaXMgYWNjb3VudCBmb3IgY3VzdG9tL211bHRpcGxlIENSTEZzP1xuICB0aGlzLl9vdmVyaGVhZExlbmd0aCArPVxuICAgIEJ1ZmZlci5ieXRlTGVuZ3RoKGhlYWRlcikgK1xuICAgIEZvcm1EYXRhLkxJTkVfQlJFQUsubGVuZ3RoO1xuXG4gIC8vIGVtcHR5IG9yIGVpdGhlciBkb2Vzbid0IGhhdmUgcGF0aCBvciBub3QgYW4gaHR0cCByZXNwb25zZVxuICBpZiAoIXZhbHVlIHx8ICggIXZhbHVlLnBhdGggJiYgISh2YWx1ZS5yZWFkYWJsZSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnaHR0cFZlcnNpb24nKSkgKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIG5vIG5lZWQgdG8gYm90aGVyIHdpdGggdGhlIGxlbmd0aFxuICBpZiAoIW9wdGlvbnMua25vd25MZW5ndGgpIHtcbiAgICB0aGlzLl92YWx1ZXNUb01lYXN1cmUucHVzaCh2YWx1ZSk7XG4gIH1cbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fbGVuZ3RoUmV0cmlldmVyID0gZnVuY3Rpb24odmFsdWUsIGNhbGxiYWNrKSB7XG5cbiAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KCdmZCcpKSB7XG5cbiAgICAvLyB0YWtlIHJlYWQgcmFuZ2UgaW50byBhIGFjY291bnRcbiAgICAvLyBgZW5kYCA9IEluZmluaXR5IOKAkz4gcmVhZCBmaWxlIHRpbGwgdGhlIGVuZFxuICAgIC8vXG4gICAgLy8gVE9ETzogTG9va3MgbGlrZSB0aGVyZSBpcyBidWcgaW4gTm9kZSBmcy5jcmVhdGVSZWFkU3RyZWFtXG4gICAgLy8gaXQgZG9lc24ndCByZXNwZWN0IGBlbmRgIG9wdGlvbnMgd2l0aG91dCBgc3RhcnRgIG9wdGlvbnNcbiAgICAvLyBGaXggaXQgd2hlbiBub2RlIGZpeGVzIGl0LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvNzgxOVxuICAgIGlmICh2YWx1ZS5lbmQgIT0gdW5kZWZpbmVkICYmIHZhbHVlLmVuZCAhPSBJbmZpbml0eSAmJiB2YWx1ZS5zdGFydCAhPSB1bmRlZmluZWQpIHtcblxuICAgICAgLy8gd2hlbiBlbmQgc3BlY2lmaWVkXG4gICAgICAvLyBubyBuZWVkIHRvIGNhbGN1bGF0ZSByYW5nZVxuICAgICAgLy8gaW5jbHVzaXZlLCBzdGFydHMgd2l0aCAwXG4gICAgICBjYWxsYmFjayhudWxsLCB2YWx1ZS5lbmQgKyAxIC0gKHZhbHVlLnN0YXJ0ID8gdmFsdWUuc3RhcnQgOiAwKSk7XG5cbiAgICAvLyBub3QgdGhhdCBmYXN0IHNub29weVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzdGlsbCBuZWVkIHRvIGZldGNoIGZpbGUgc2l6ZSBmcm9tIGZzXG4gICAgICBmcy5zdGF0KHZhbHVlLnBhdGgsIGZ1bmN0aW9uKGVyciwgc3RhdCkge1xuXG4gICAgICAgIHZhciBmaWxlU2l6ZTtcblxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgZmluYWwgc2l6ZSBiYXNlZCBvbiB0aGUgcmFuZ2Ugb3B0aW9uc1xuICAgICAgICBmaWxlU2l6ZSA9IHN0YXQuc2l6ZSAtICh2YWx1ZS5zdGFydCA/IHZhbHVlLnN0YXJ0IDogMCk7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGZpbGVTaXplKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAvLyBvciBodHRwIHJlc3BvbnNlXG4gIH0gZWxzZSBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoJ2h0dHBWZXJzaW9uJykpIHtcbiAgICBjYWxsYmFjayhudWxsLCArdmFsdWUuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSk7XG5cbiAgLy8gb3IgcmVxdWVzdCBzdHJlYW0gaHR0cDovL2dpdGh1Yi5jb20vbWlrZWFsL3JlcXVlc3RcbiAgfSBlbHNlIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnaHR0cE1vZHVsZScpKSB7XG4gICAgLy8gd2FpdCB0aWxsIHJlc3BvbnNlIGNvbWUgYmFja1xuICAgIHZhbHVlLm9uKCdyZXNwb25zZScsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICB2YWx1ZS5wYXVzZSgpO1xuICAgICAgY2FsbGJhY2sobnVsbCwgK3Jlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10pO1xuICAgIH0pO1xuICAgIHZhbHVlLnJlc3VtZSgpO1xuXG4gIC8vIHNvbWV0aGluZyBlbHNlXG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2soJ1Vua25vd24gc3RyZWFtJyk7XG4gIH1cbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fbXVsdGlQYXJ0SGVhZGVyID0gZnVuY3Rpb24oZmllbGQsIHZhbHVlLCBvcHRpb25zKSB7XG4gIC8vIGN1c3RvbSBoZWFkZXIgc3BlY2lmaWVkIChhcyBzdHJpbmcpP1xuICAvLyBpdCBiZWNvbWVzIHJlc3BvbnNpYmxlIGZvciBib3VuZGFyeVxuICAvLyAoZS5nLiB0byBoYW5kbGUgZXh0cmEgQ1JMRnMgb24gLk5FVCBzZXJ2ZXJzKVxuICBpZiAodHlwZW9mIG9wdGlvbnMuaGVhZGVyID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuaGVhZGVyO1xuICB9XG5cbiAgdmFyIGNvbnRlbnREaXNwb3NpdGlvbiA9IHRoaXMuX2dldENvbnRlbnREaXNwb3NpdGlvbih2YWx1ZSwgb3B0aW9ucyk7XG4gIHZhciBjb250ZW50VHlwZSA9IHRoaXMuX2dldENvbnRlbnRUeXBlKHZhbHVlLCBvcHRpb25zKTtcblxuICB2YXIgY29udGVudHMgPSAnJztcbiAgdmFyIGhlYWRlcnMgID0ge1xuICAgIC8vIGFkZCBjdXN0b20gZGlzcG9zaXRpb24gYXMgdGhpcmQgZWxlbWVudCBvciBrZWVwIGl0IHR3byBlbGVtZW50cyBpZiBub3RcbiAgICAnQ29udGVudC1EaXNwb3NpdGlvbic6IFsnZm9ybS1kYXRhJywgJ25hbWU9XCInICsgZmllbGQgKyAnXCInXS5jb25jYXQoY29udGVudERpc3Bvc2l0aW9uIHx8IFtdKSxcbiAgICAvLyBpZiBubyBjb250ZW50IHR5cGUuIGFsbG93IGl0IHRvIGJlIGVtcHR5IGFycmF5XG4gICAgJ0NvbnRlbnQtVHlwZSc6IFtdLmNvbmNhdChjb250ZW50VHlwZSB8fCBbXSlcbiAgfTtcblxuICAvLyBhbGxvdyBjdXN0b20gaGVhZGVycy5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmhlYWRlciA9PSAnb2JqZWN0Jykge1xuICAgIHBvcHVsYXRlKGhlYWRlcnMsIG9wdGlvbnMuaGVhZGVyKTtcbiAgfVxuXG4gIHZhciBoZWFkZXI7XG4gIGZvciAodmFyIHByb3AgaW4gaGVhZGVycykge1xuICAgIGlmICghaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgY29udGludWU7XG4gICAgaGVhZGVyID0gaGVhZGVyc1twcm9wXTtcblxuICAgIC8vIHNraXAgbnVsbGlzaCBoZWFkZXJzLlxuICAgIGlmIChoZWFkZXIgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBhbGwgaGVhZGVycyB0byBhcnJheXMuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGhlYWRlcikpIHtcbiAgICAgIGhlYWRlciA9IFtoZWFkZXJdO1xuICAgIH1cblxuICAgIC8vIGFkZCBub24tZW1wdHkgaGVhZGVycy5cbiAgICBpZiAoaGVhZGVyLmxlbmd0aCkge1xuICAgICAgY29udGVudHMgKz0gcHJvcCArICc6ICcgKyBoZWFkZXIuam9pbignOyAnKSArIEZvcm1EYXRhLkxJTkVfQlJFQUs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICctLScgKyB0aGlzLmdldEJvdW5kYXJ5KCkgKyBGb3JtRGF0YS5MSU5FX0JSRUFLICsgY29udGVudHMgKyBGb3JtRGF0YS5MSU5FX0JSRUFLO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLl9nZXRDb250ZW50RGlzcG9zaXRpb24gPSBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuXG4gIHZhciBmaWxlbmFtZVxuICAgICwgY29udGVudERpc3Bvc2l0aW9uXG4gICAgO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5maWxlcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBjdXN0b20gZmlsZXBhdGggZm9yIHJlbGF0aXZlIHBhdGhzXG4gICAgZmlsZW5hbWUgPSBwYXRoLm5vcm1hbGl6ZShvcHRpb25zLmZpbGVwYXRoKS5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5maWxlbmFtZSB8fCB2YWx1ZS5uYW1lIHx8IHZhbHVlLnBhdGgpIHtcbiAgICAvLyBjdXN0b20gZmlsZW5hbWUgdGFrZSBwcmVjZWRlbmNlXG4gICAgLy8gZm9ybWlkYWJsZSBhbmQgdGhlIGJyb3dzZXIgYWRkIGEgbmFtZSBwcm9wZXJ0eVxuICAgIC8vIGZzLSBhbmQgcmVxdWVzdC0gc3RyZWFtcyBoYXZlIHBhdGggcHJvcGVydHlcbiAgICBmaWxlbmFtZSA9IHBhdGguYmFzZW5hbWUob3B0aW9ucy5maWxlbmFtZSB8fCB2YWx1ZS5uYW1lIHx8IHZhbHVlLnBhdGgpO1xuICB9IGVsc2UgaWYgKHZhbHVlLnJlYWRhYmxlICYmIHZhbHVlLmhhc093blByb3BlcnR5KCdodHRwVmVyc2lvbicpKSB7XG4gICAgLy8gb3IgdHJ5IGh0dHAgcmVzcG9uc2VcbiAgICBmaWxlbmFtZSA9IHBhdGguYmFzZW5hbWUodmFsdWUuY2xpZW50Ll9odHRwTWVzc2FnZS5wYXRoKTtcbiAgfVxuXG4gIGlmIChmaWxlbmFtZSkge1xuICAgIGNvbnRlbnREaXNwb3NpdGlvbiA9ICdmaWxlbmFtZT1cIicgKyBmaWxlbmFtZSArICdcIic7XG4gIH1cblxuICByZXR1cm4gY29udGVudERpc3Bvc2l0aW9uO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLl9nZXRDb250ZW50VHlwZSA9IGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zKSB7XG5cbiAgLy8gdXNlIGN1c3RvbSBjb250ZW50LXR5cGUgYWJvdmUgYWxsXG4gIHZhciBjb250ZW50VHlwZSA9IG9wdGlvbnMuY29udGVudFR5cGU7XG5cbiAgLy8gb3IgdHJ5IGBuYW1lYCBmcm9tIGZvcm1pZGFibGUsIGJyb3dzZXJcbiAgaWYgKCFjb250ZW50VHlwZSAmJiB2YWx1ZS5uYW1lKSB7XG4gICAgY29udGVudFR5cGUgPSBtaW1lLmxvb2t1cCh2YWx1ZS5uYW1lKTtcbiAgfVxuXG4gIC8vIG9yIHRyeSBgcGF0aGAgZnJvbSBmcy0sIHJlcXVlc3QtIHN0cmVhbXNcbiAgaWYgKCFjb250ZW50VHlwZSAmJiB2YWx1ZS5wYXRoKSB7XG4gICAgY29udGVudFR5cGUgPSBtaW1lLmxvb2t1cCh2YWx1ZS5wYXRoKTtcbiAgfVxuXG4gIC8vIG9yIGlmIGl0J3MgaHR0cC1yZXBvbnNlXG4gIGlmICghY29udGVudFR5cGUgJiYgdmFsdWUucmVhZGFibGUgJiYgdmFsdWUuaGFzT3duUHJvcGVydHkoJ2h0dHBWZXJzaW9uJykpIHtcbiAgICBjb250ZW50VHlwZSA9IHZhbHVlLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddO1xuICB9XG5cbiAgLy8gb3IgZ3Vlc3MgaXQgZnJvbSB0aGUgZmlsZXBhdGggb3IgZmlsZW5hbWVcbiAgaWYgKCFjb250ZW50VHlwZSAmJiAob3B0aW9ucy5maWxlcGF0aCB8fCBvcHRpb25zLmZpbGVuYW1lKSkge1xuICAgIGNvbnRlbnRUeXBlID0gbWltZS5sb29rdXAob3B0aW9ucy5maWxlcGF0aCB8fCBvcHRpb25zLmZpbGVuYW1lKTtcbiAgfVxuXG4gIC8vIGZhbGxiYWNrIHRvIHRoZSBkZWZhdWx0IGNvbnRlbnQgdHlwZSBpZiBgdmFsdWVgIGlzIG5vdCBzaW1wbGUgdmFsdWVcbiAgaWYgKCFjb250ZW50VHlwZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICBjb250ZW50VHlwZSA9IEZvcm1EYXRhLkRFRkFVTFRfQ09OVEVOVF9UWVBFO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRlbnRUeXBlO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLl9tdWx0aVBhcnRGb290ZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG5leHQpIHtcbiAgICB2YXIgZm9vdGVyID0gRm9ybURhdGEuTElORV9CUkVBSztcblxuICAgIHZhciBsYXN0UGFydCA9ICh0aGlzLl9zdHJlYW1zLmxlbmd0aCA9PT0gMCk7XG4gICAgaWYgKGxhc3RQYXJ0KSB7XG4gICAgICBmb290ZXIgKz0gdGhpcy5fbGFzdEJvdW5kYXJ5KCk7XG4gICAgfVxuXG4gICAgbmV4dChmb290ZXIpO1xuICB9LmJpbmQodGhpcyk7XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuX2xhc3RCb3VuZGFyeSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJy0tJyArIHRoaXMuZ2V0Qm91bmRhcnkoKSArICctLScgKyBGb3JtRGF0YS5MSU5FX0JSRUFLO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLmdldEhlYWRlcnMgPSBmdW5jdGlvbih1c2VySGVhZGVycykge1xuICB2YXIgaGVhZGVyO1xuICB2YXIgZm9ybUhlYWRlcnMgPSB7XG4gICAgJ2NvbnRlbnQtdHlwZSc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT0nICsgdGhpcy5nZXRCb3VuZGFyeSgpXG4gIH07XG5cbiAgZm9yIChoZWFkZXIgaW4gdXNlckhlYWRlcnMpIHtcbiAgICBpZiAodXNlckhlYWRlcnMuaGFzT3duUHJvcGVydHkoaGVhZGVyKSkge1xuICAgICAgZm9ybUhlYWRlcnNbaGVhZGVyLnRvTG93ZXJDYXNlKCldID0gdXNlckhlYWRlcnNbaGVhZGVyXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZm9ybUhlYWRlcnM7XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuZ2V0Qm91bmRhcnkgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9ib3VuZGFyeSkge1xuICAgIHRoaXMuX2dlbmVyYXRlQm91bmRhcnkoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9ib3VuZGFyeTtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fZ2VuZXJhdGVCb3VuZGFyeSA9IGZ1bmN0aW9uKCkge1xuICAvLyBUaGlzIGdlbmVyYXRlcyBhIDUwIGNoYXJhY3RlciBib3VuZGFyeSBzaW1pbGFyIHRvIHRob3NlIHVzZWQgYnkgRmlyZWZveC5cbiAgLy8gVGhleSBhcmUgb3B0aW1pemVkIGZvciBib3llci1tb29yZSBwYXJzaW5nLlxuICB2YXIgYm91bmRhcnkgPSAnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDI0OyBpKyspIHtcbiAgICBib3VuZGFyeSArPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMCkudG9TdHJpbmcoMTYpO1xuICB9XG5cbiAgdGhpcy5fYm91bmRhcnkgPSBib3VuZGFyeTtcbn07XG5cbi8vIE5vdGU6IGdldExlbmd0aFN5bmMgRE9FU04nVCBjYWxjdWxhdGUgc3RyZWFtcyBsZW5ndGhcbi8vIEFzIHdvcmthcm91bmQgb25lIGNhbiBjYWxjdWxhdGUgZmlsZSBzaXplIG1hbnVhbGx5XG4vLyBhbmQgYWRkIGl0IGFzIGtub3duTGVuZ3RoIG9wdGlvblxuRm9ybURhdGEucHJvdG90eXBlLmdldExlbmd0aFN5bmMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGtub3duTGVuZ3RoID0gdGhpcy5fb3ZlcmhlYWRMZW5ndGggKyB0aGlzLl92YWx1ZUxlbmd0aDtcblxuICAvLyBEb24ndCBnZXQgY29uZnVzZWQsIHRoZXJlIGFyZSAzIFwiaW50ZXJuYWxcIiBzdHJlYW1zIGZvciBlYWNoIGtleXZhbCBwYWlyXG4gIC8vIHNvIGl0IGJhc2ljYWxseSBjaGVja3MgaWYgdGhlcmUgaXMgYW55IHZhbHVlIGFkZGVkIHRvIHRoZSBmb3JtXG4gIGlmICh0aGlzLl9zdHJlYW1zLmxlbmd0aCkge1xuICAgIGtub3duTGVuZ3RoICs9IHRoaXMuX2xhc3RCb3VuZGFyeSgpLmxlbmd0aDtcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JtLWRhdGEvZm9ybS1kYXRhL2lzc3Vlcy80MFxuICBpZiAoIXRoaXMuaGFzS25vd25MZW5ndGgoKSkge1xuICAgIC8vIFNvbWUgYXN5bmMgbGVuZ3RoIHJldHJpZXZlcnMgYXJlIHByZXNlbnRcbiAgICAvLyB0aGVyZWZvcmUgc3luY2hyb25vdXMgbGVuZ3RoIGNhbGN1bGF0aW9uIGlzIGZhbHNlLlxuICAgIC8vIFBsZWFzZSB1c2UgZ2V0TGVuZ3RoKGNhbGxiYWNrKSB0byBnZXQgcHJvcGVyIGxlbmd0aFxuICAgIHRoaXMuX2Vycm9yKG5ldyBFcnJvcignQ2Fubm90IGNhbGN1bGF0ZSBwcm9wZXIgbGVuZ3RoIGluIHN5bmNocm9ub3VzIHdheS4nKSk7XG4gIH1cblxuICByZXR1cm4ga25vd25MZW5ndGg7XG59O1xuXG4vLyBQdWJsaWMgQVBJIHRvIGNoZWNrIGlmIGxlbmd0aCBvZiBhZGRlZCB2YWx1ZXMgaXMga25vd25cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JtLWRhdGEvZm9ybS1kYXRhL2lzc3Vlcy8xOTZcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JtLWRhdGEvZm9ybS1kYXRhL2lzc3Vlcy8yNjJcbkZvcm1EYXRhLnByb3RvdHlwZS5oYXNLbm93bkxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaGFzS25vd25MZW5ndGggPSB0cnVlO1xuXG4gIGlmICh0aGlzLl92YWx1ZXNUb01lYXN1cmUubGVuZ3RoKSB7XG4gICAgaGFzS25vd25MZW5ndGggPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBoYXNLbm93bkxlbmd0aDtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbihjYikge1xuICB2YXIga25vd25MZW5ndGggPSB0aGlzLl9vdmVyaGVhZExlbmd0aCArIHRoaXMuX3ZhbHVlTGVuZ3RoO1xuXG4gIGlmICh0aGlzLl9zdHJlYW1zLmxlbmd0aCkge1xuICAgIGtub3duTGVuZ3RoICs9IHRoaXMuX2xhc3RCb3VuZGFyeSgpLmxlbmd0aDtcbiAgfVxuXG4gIGlmICghdGhpcy5fdmFsdWVzVG9NZWFzdXJlLmxlbmd0aCkge1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IuYmluZCh0aGlzLCBudWxsLCBrbm93bkxlbmd0aCkpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGFzeW5ja2l0LnBhcmFsbGVsKHRoaXMuX3ZhbHVlc1RvTWVhc3VyZSwgdGhpcy5fbGVuZ3RoUmV0cmlldmVyLCBmdW5jdGlvbihlcnIsIHZhbHVlcykge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNiKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgICBrbm93bkxlbmd0aCArPSBsZW5ndGg7XG4gICAgfSk7XG5cbiAgICBjYihudWxsLCBrbm93bkxlbmd0aCk7XG4gIH0pO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLnN1Ym1pdCA9IGZ1bmN0aW9uKHBhcmFtcywgY2IpIHtcbiAgdmFyIHJlcXVlc3RcbiAgICAsIG9wdGlvbnNcbiAgICAsIGRlZmF1bHRzID0ge21ldGhvZDogJ3Bvc3QnfVxuICAgIDtcblxuICAvLyBwYXJzZSBwcm92aWRlZCB1cmwgaWYgaXQncyBzdHJpbmdcbiAgLy8gb3IgdHJlYXQgaXQgYXMgb3B0aW9ucyBvYmplY3RcbiAgaWYgKHR5cGVvZiBwYXJhbXMgPT0gJ3N0cmluZycpIHtcblxuICAgIHBhcmFtcyA9IHBhcnNlVXJsKHBhcmFtcyk7XG4gICAgb3B0aW9ucyA9IHBvcHVsYXRlKHtcbiAgICAgIHBvcnQ6IHBhcmFtcy5wb3J0LFxuICAgICAgcGF0aDogcGFyYW1zLnBhdGhuYW1lLFxuICAgICAgaG9zdDogcGFyYW1zLmhvc3RuYW1lLFxuICAgICAgcHJvdG9jb2w6IHBhcmFtcy5wcm90b2NvbFxuICAgIH0sIGRlZmF1bHRzKTtcblxuICAvLyB1c2UgY3VzdG9tIHBhcmFtc1xuICB9IGVsc2Uge1xuXG4gICAgb3B0aW9ucyA9IHBvcHVsYXRlKHBhcmFtcywgZGVmYXVsdHMpO1xuICAgIC8vIGlmIG5vIHBvcnQgcHJvdmlkZWQgdXNlIGRlZmF1bHQgb25lXG4gICAgaWYgKCFvcHRpb25zLnBvcnQpIHtcbiAgICAgIG9wdGlvbnMucG9ydCA9IG9wdGlvbnMucHJvdG9jb2wgPT0gJ2h0dHBzOicgPyA0NDMgOiA4MDtcbiAgICB9XG4gIH1cblxuICAvLyBwdXQgdGhhdCBnb29kIGNvZGUgaW4gZ2V0SGVhZGVycyB0byBzb21lIHVzZVxuICBvcHRpb25zLmhlYWRlcnMgPSB0aGlzLmdldEhlYWRlcnMocGFyYW1zLmhlYWRlcnMpO1xuXG4gIC8vIGh0dHBzIGlmIHNwZWNpZmllZCwgZmFsbGJhY2sgdG8gaHR0cCBpbiBhbnkgb3RoZXIgY2FzZVxuICBpZiAob3B0aW9ucy5wcm90b2NvbCA9PSAnaHR0cHM6Jykge1xuICAgIHJlcXVlc3QgPSBodHRwcy5yZXF1ZXN0KG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHJlcXVlc3QgPSBodHRwLnJlcXVlc3Qob3B0aW9ucyk7XG4gIH1cblxuICAvLyBnZXQgY29udGVudCBsZW5ndGggYW5kIGZpcmUgYXdheVxuICB0aGlzLmdldExlbmd0aChmdW5jdGlvbihlcnIsIGxlbmd0aCkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYWRkIGNvbnRlbnQgbGVuZ3RoXG4gICAgcmVxdWVzdC5zZXRIZWFkZXIoJ0NvbnRlbnQtTGVuZ3RoJywgbGVuZ3RoKTtcblxuICAgIHRoaXMucGlwZShyZXF1ZXN0KTtcbiAgICBpZiAoY2IpIHtcbiAgICAgIHJlcXVlc3Qub24oJ2Vycm9yJywgY2IpO1xuICAgICAgcmVxdWVzdC5vbigncmVzcG9uc2UnLCBjYi5iaW5kKHRoaXMsIG51bGwpKTtcbiAgICB9XG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgcmV0dXJuIHJlcXVlc3Q7XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gIGlmICghdGhpcy5lcnJvcikge1xuICAgIHRoaXMuZXJyb3IgPSBlcnI7XG4gICAgdGhpcy5wYXVzZSgpO1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnW29iamVjdCBGb3JtRGF0YV0nO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/request/node_modules/form-data/lib/form_data.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/request/node_modules/form-data/lib/populate.js":
/*!*********************************************************************!*\
  !*** ./node_modules/request/node_modules/form-data/lib/populate.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("// populates missing values\nmodule.exports = function(dst, src) {\n\n  Object.keys(src).forEach(function(prop)\n  {\n    dst[prop] = dst[prop] || src[prop];\n  });\n\n  return dst;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9wb3B1bGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BhZ2UtZm9ybS8uL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9mb3JtLWRhdGEvbGliL3BvcHVsYXRlLmpzPzU5YmUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcG9wdWxhdGVzIG1pc3NpbmcgdmFsdWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRzdCwgc3JjKSB7XG5cbiAgT2JqZWN0LmtleXMoc3JjKS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApXG4gIHtcbiAgICBkc3RbcHJvcF0gPSBkc3RbcHJvcF0gfHwgc3JjW3Byb3BdO1xuICB9KTtcblxuICByZXR1cm4gZHN0O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/request/node_modules/form-data/lib/populate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/request/node_modules/tough-cookie/lib/cookie.js":
/*!**********************************************************************!*\
  !*** ./node_modules/request/node_modules/tough-cookie/lib/cookie.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2015, Salesforce.com, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar net = __webpack_require__(/*! net */ \"net\");\nvar urlParse = (__webpack_require__(/*! url */ \"url\").parse);\nvar util = __webpack_require__(/*! util */ \"util\");\nvar pubsuffix = __webpack_require__(/*! ./pubsuffix-psl */ \"(rsc)/./node_modules/request/node_modules/tough-cookie/lib/pubsuffix-psl.js\");\nvar Store = (__webpack_require__(/*! ./store */ \"(rsc)/./node_modules/request/node_modules/tough-cookie/lib/store.js\").Store);\nvar MemoryCookieStore = (__webpack_require__(/*! ./memstore */ \"(rsc)/./node_modules/request/node_modules/tough-cookie/lib/memstore.js\").MemoryCookieStore);\nvar pathMatch = (__webpack_require__(/*! ./pathMatch */ \"(rsc)/./node_modules/request/node_modules/tough-cookie/lib/pathMatch.js\").pathMatch);\nvar VERSION = __webpack_require__(/*! ./version */ \"(rsc)/./node_modules/request/node_modules/tough-cookie/lib/version.js\");\n\nvar punycode;\ntry {\n  punycode = __webpack_require__(/*! punycode */ \"punycode\");\n} catch(e) {\n  console.warn(\"tough-cookie: can't load punycode; won't use punycode for domain normalization\");\n}\n\n// From RFC6265 S4.1.1\n// note that it excludes \\x3B \";\"\nvar COOKIE_OCTETS = /^[\\x21\\x23-\\x2B\\x2D-\\x3A\\x3C-\\x5B\\x5D-\\x7E]+$/;\n\nvar CONTROL_CHARS = /[\\x00-\\x1F]/;\n\n// From Chromium // '\\r', '\\n' and '\\0' should be treated as a terminator in\n// the \"relaxed\" mode, see:\n// https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/parsed_cookie.cc#L60\nvar TERMINATORS = ['\\n', '\\r', '\\0'];\n\n// RFC6265 S4.1.1 defines path value as 'any CHAR except CTLs or \";\"'\n// Note ';' is \\x3B\nvar PATH_VALUE = /[\\x20-\\x3A\\x3C-\\x7E]+/;\n\n// date-time parsing constants (RFC6265 S5.1.1)\n\nvar DATE_DELIM = /[\\x09\\x20-\\x2F\\x3B-\\x40\\x5B-\\x60\\x7B-\\x7E]/;\n\nvar MONTH_TO_NUM = {\n  jan:0, feb:1, mar:2, apr:3, may:4, jun:5,\n  jul:6, aug:7, sep:8, oct:9, nov:10, dec:11\n};\nvar NUM_TO_MONTH = [\n  'Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'\n];\nvar NUM_TO_DAY = [\n  'Sun','Mon','Tue','Wed','Thu','Fri','Sat'\n];\n\nvar MAX_TIME = 2147483647000; // 31-bit max\nvar MIN_TIME = 0; // 31-bit min\n\n/*\n * Parses a Natural number (i.e., non-negative integer) with either the\n *    <min>*<max>DIGIT ( non-digit *OCTET )\n * or\n *    <min>*<max>DIGIT\n * grammar (RFC6265 S5.1.1).\n *\n * The \"trailingOK\" boolean controls if the grammar accepts a\n * \"( non-digit *OCTET )\" trailer.\n */\nfunction parseDigits(token, minDigits, maxDigits, trailingOK) {\n  var count = 0;\n  while (count < token.length) {\n    var c = token.charCodeAt(count);\n    // \"non-digit = %x00-2F / %x3A-FF\"\n    if (c <= 0x2F || c >= 0x3A) {\n      break;\n    }\n    count++;\n  }\n\n  // constrain to a minimum and maximum number of digits.\n  if (count < minDigits || count > maxDigits) {\n    return null;\n  }\n\n  if (!trailingOK && count != token.length) {\n    return null;\n  }\n\n  return parseInt(token.substr(0,count), 10);\n}\n\nfunction parseTime(token) {\n  var parts = token.split(':');\n  var result = [0,0,0];\n\n  /* RF6256 S5.1.1:\n   *      time            = hms-time ( non-digit *OCTET )\n   *      hms-time        = time-field \":\" time-field \":\" time-field\n   *      time-field      = 1*2DIGIT\n   */\n\n  if (parts.length !== 3) {\n    return null;\n  }\n\n  for (var i = 0; i < 3; i++) {\n    // \"time-field\" must be strictly \"1*2DIGIT\", HOWEVER, \"hms-time\" can be\n    // followed by \"( non-digit *OCTET )\" so therefore the last time-field can\n    // have a trailer\n    var trailingOK = (i == 2);\n    var num = parseDigits(parts[i], 1, 2, trailingOK);\n    if (num === null) {\n      return null;\n    }\n    result[i] = num;\n  }\n\n  return result;\n}\n\nfunction parseMonth(token) {\n  token = String(token).substr(0,3).toLowerCase();\n  var num = MONTH_TO_NUM[token];\n  return num >= 0 ? num : null;\n}\n\n/*\n * RFC6265 S5.1.1 date parser (see RFC for full grammar)\n */\nfunction parseDate(str) {\n  if (!str) {\n    return;\n  }\n\n  /* RFC6265 S5.1.1:\n   * 2. Process each date-token sequentially in the order the date-tokens\n   * appear in the cookie-date\n   */\n  var tokens = str.split(DATE_DELIM);\n  if (!tokens) {\n    return;\n  }\n\n  var hour = null;\n  var minute = null;\n  var second = null;\n  var dayOfMonth = null;\n  var month = null;\n  var year = null;\n\n  for (var i=0; i<tokens.length; i++) {\n    var token = tokens[i].trim();\n    if (!token.length) {\n      continue;\n    }\n\n    var result;\n\n    /* 2.1. If the found-time flag is not set and the token matches the time\n     * production, set the found-time flag and set the hour- value,\n     * minute-value, and second-value to the numbers denoted by the digits in\n     * the date-token, respectively.  Skip the remaining sub-steps and continue\n     * to the next date-token.\n     */\n    if (second === null) {\n      result = parseTime(token);\n      if (result) {\n        hour = result[0];\n        minute = result[1];\n        second = result[2];\n        continue;\n      }\n    }\n\n    /* 2.2. If the found-day-of-month flag is not set and the date-token matches\n     * the day-of-month production, set the found-day-of- month flag and set\n     * the day-of-month-value to the number denoted by the date-token.  Skip\n     * the remaining sub-steps and continue to the next date-token.\n     */\n    if (dayOfMonth === null) {\n      // \"day-of-month = 1*2DIGIT ( non-digit *OCTET )\"\n      result = parseDigits(token, 1, 2, true);\n      if (result !== null) {\n        dayOfMonth = result;\n        continue;\n      }\n    }\n\n    /* 2.3. If the found-month flag is not set and the date-token matches the\n     * month production, set the found-month flag and set the month-value to\n     * the month denoted by the date-token.  Skip the remaining sub-steps and\n     * continue to the next date-token.\n     */\n    if (month === null) {\n      result = parseMonth(token);\n      if (result !== null) {\n        month = result;\n        continue;\n      }\n    }\n\n    /* 2.4. If the found-year flag is not set and the date-token matches the\n     * year production, set the found-year flag and set the year-value to the\n     * number denoted by the date-token.  Skip the remaining sub-steps and\n     * continue to the next date-token.\n     */\n    if (year === null) {\n      // \"year = 2*4DIGIT ( non-digit *OCTET )\"\n      result = parseDigits(token, 2, 4, true);\n      if (result !== null) {\n        year = result;\n        /* From S5.1.1:\n         * 3.  If the year-value is greater than or equal to 70 and less\n         * than or equal to 99, increment the year-value by 1900.\n         * 4.  If the year-value is greater than or equal to 0 and less\n         * than or equal to 69, increment the year-value by 2000.\n         */\n        if (year >= 70 && year <= 99) {\n          year += 1900;\n        } else if (year >= 0 && year <= 69) {\n          year += 2000;\n        }\n      }\n    }\n  }\n\n  /* RFC 6265 S5.1.1\n   * \"5. Abort these steps and fail to parse the cookie-date if:\n   *     *  at least one of the found-day-of-month, found-month, found-\n   *        year, or found-time flags is not set,\n   *     *  the day-of-month-value is less than 1 or greater than 31,\n   *     *  the year-value is less than 1601,\n   *     *  the hour-value is greater than 23,\n   *     *  the minute-value is greater than 59, or\n   *     *  the second-value is greater than 59.\n   *     (Note that leap seconds cannot be represented in this syntax.)\"\n   *\n   * So, in order as above:\n   */\n  if (\n    dayOfMonth === null || month === null || year === null || second === null ||\n    dayOfMonth < 1 || dayOfMonth > 31 ||\n    year < 1601 ||\n    hour > 23 ||\n    minute > 59 ||\n    second > 59\n  ) {\n    return;\n  }\n\n  return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));\n}\n\nfunction formatDate(date) {\n  var d = date.getUTCDate(); d = d >= 10 ? d : '0'+d;\n  var h = date.getUTCHours(); h = h >= 10 ? h : '0'+h;\n  var m = date.getUTCMinutes(); m = m >= 10 ? m : '0'+m;\n  var s = date.getUTCSeconds(); s = s >= 10 ? s : '0'+s;\n  return NUM_TO_DAY[date.getUTCDay()] + ', ' +\n    d+' '+ NUM_TO_MONTH[date.getUTCMonth()] +' '+ date.getUTCFullYear() +' '+\n    h+':'+m+':'+s+' GMT';\n}\n\n// S5.1.2 Canonicalized Host Names\nfunction canonicalDomain(str) {\n  if (str == null) {\n    return null;\n  }\n  str = str.trim().replace(/^\\./,''); // S4.1.2.3 & S5.2.3: ignore leading .\n\n  // convert to IDN if any non-ASCII characters\n  if (punycode && /[^\\u0001-\\u007f]/.test(str)) {\n    str = punycode.toASCII(str);\n  }\n\n  return str.toLowerCase();\n}\n\n// S5.1.3 Domain Matching\nfunction domainMatch(str, domStr, canonicalize) {\n  if (str == null || domStr == null) {\n    return null;\n  }\n  if (canonicalize !== false) {\n    str = canonicalDomain(str);\n    domStr = canonicalDomain(domStr);\n  }\n\n  /*\n   * \"The domain string and the string are identical. (Note that both the\n   * domain string and the string will have been canonicalized to lower case at\n   * this point)\"\n   */\n  if (str == domStr) {\n    return true;\n  }\n\n  /* \"All of the following [three] conditions hold:\" (order adjusted from the RFC) */\n\n  /* \"* The string is a host name (i.e., not an IP address).\" */\n  if (net.isIP(str)) {\n    return false;\n  }\n\n  /* \"* The domain string is a suffix of the string\" */\n  var idx = str.indexOf(domStr);\n  if (idx <= 0) {\n    return false; // it's a non-match (-1) or prefix (0)\n  }\n\n  // e.g \"a.b.c\".indexOf(\"b.c\") === 2\n  // 5 === 3+2\n  if (str.length !== domStr.length + idx) { // it's not a suffix\n    return false;\n  }\n\n  /* \"* The last character of the string that is not included in the domain\n  * string is a %x2E (\".\") character.\" */\n  if (str.substr(idx-1,1) !== '.') {\n    return false;\n  }\n\n  return true;\n}\n\n\n// RFC6265 S5.1.4 Paths and Path-Match\n\n/*\n * \"The user agent MUST use an algorithm equivalent to the following algorithm\n * to compute the default-path of a cookie:\"\n *\n * Assumption: the path (and not query part or absolute uri) is passed in.\n */\nfunction defaultPath(path) {\n  // \"2. If the uri-path is empty or if the first character of the uri-path is not\n  // a %x2F (\"/\") character, output %x2F (\"/\") and skip the remaining steps.\n  if (!path || path.substr(0,1) !== \"/\") {\n    return \"/\";\n  }\n\n  // \"3. If the uri-path contains no more than one %x2F (\"/\") character, output\n  // %x2F (\"/\") and skip the remaining step.\"\n  if (path === \"/\") {\n    return path;\n  }\n\n  var rightSlash = path.lastIndexOf(\"/\");\n  if (rightSlash === 0) {\n    return \"/\";\n  }\n\n  // \"4. Output the characters of the uri-path from the first character up to,\n  // but not including, the right-most %x2F (\"/\").\"\n  return path.slice(0, rightSlash);\n}\n\nfunction trimTerminator(str) {\n  for (var t = 0; t < TERMINATORS.length; t++) {\n    var terminatorIdx = str.indexOf(TERMINATORS[t]);\n    if (terminatorIdx !== -1) {\n      str = str.substr(0,terminatorIdx);\n    }\n  }\n\n  return str;\n}\n\nfunction parseCookiePair(cookiePair, looseMode) {\n  cookiePair = trimTerminator(cookiePair);\n\n  var firstEq = cookiePair.indexOf('=');\n  if (looseMode) {\n    if (firstEq === 0) { // '=' is immediately at start\n      cookiePair = cookiePair.substr(1);\n      firstEq = cookiePair.indexOf('='); // might still need to split on '='\n    }\n  } else { // non-loose mode\n    if (firstEq <= 0) { // no '=' or is at start\n      return; // needs to have non-empty \"cookie-name\"\n    }\n  }\n\n  var cookieName, cookieValue;\n  if (firstEq <= 0) {\n    cookieName = \"\";\n    cookieValue = cookiePair.trim();\n  } else {\n    cookieName = cookiePair.substr(0, firstEq).trim();\n    cookieValue = cookiePair.substr(firstEq+1).trim();\n  }\n\n  if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {\n    return;\n  }\n\n  var c = new Cookie();\n  c.key = cookieName;\n  c.value = cookieValue;\n  return c;\n}\n\nfunction parse(str, options) {\n  if (!options || typeof options !== 'object') {\n    options = {};\n  }\n  str = str.trim();\n\n  // We use a regex to parse the \"name-value-pair\" part of S5.2\n  var firstSemi = str.indexOf(';'); // S5.2 step 1\n  var cookiePair = (firstSemi === -1) ? str : str.substr(0, firstSemi);\n  var c = parseCookiePair(cookiePair, !!options.loose);\n  if (!c) {\n    return;\n  }\n\n  if (firstSemi === -1) {\n    return c;\n  }\n\n  // S5.2.3 \"unparsed-attributes consist of the remainder of the set-cookie-string\n  // (including the %x3B (\";\") in question).\" plus later on in the same section\n  // \"discard the first \";\" and trim\".\n  var unparsed = str.slice(firstSemi + 1).trim();\n\n  // \"If the unparsed-attributes string is empty, skip the rest of these\n  // steps.\"\n  if (unparsed.length === 0) {\n    return c;\n  }\n\n  /*\n   * S5.2 says that when looping over the items \"[p]rocess the attribute-name\n   * and attribute-value according to the requirements in the following\n   * subsections\" for every item.  Plus, for many of the individual attributes\n   * in S5.3 it says to use the \"attribute-value of the last attribute in the\n   * cookie-attribute-list\".  Therefore, in this implementation, we overwrite\n   * the previous value.\n   */\n  var cookie_avs = unparsed.split(';');\n  while (cookie_avs.length) {\n    var av = cookie_avs.shift().trim();\n    if (av.length === 0) { // happens if \";;\" appears\n      continue;\n    }\n    var av_sep = av.indexOf('=');\n    var av_key, av_value;\n\n    if (av_sep === -1) {\n      av_key = av;\n      av_value = null;\n    } else {\n      av_key = av.substr(0,av_sep);\n      av_value = av.substr(av_sep+1);\n    }\n\n    av_key = av_key.trim().toLowerCase();\n\n    if (av_value) {\n      av_value = av_value.trim();\n    }\n\n    switch(av_key) {\n    case 'expires': // S5.2.1\n      if (av_value) {\n        var exp = parseDate(av_value);\n        // \"If the attribute-value failed to parse as a cookie date, ignore the\n        // cookie-av.\"\n        if (exp) {\n          // over and underflow not realistically a concern: V8's getTime() seems to\n          // store something larger than a 32-bit time_t (even with 32-bit node)\n          c.expires = exp;\n        }\n      }\n      break;\n\n    case 'max-age': // S5.2.2\n      if (av_value) {\n        // \"If the first character of the attribute-value is not a DIGIT or a \"-\"\n        // character ...[or]... If the remainder of attribute-value contains a\n        // non-DIGIT character, ignore the cookie-av.\"\n        if (/^-?[0-9]+$/.test(av_value)) {\n          var delta = parseInt(av_value, 10);\n          // \"If delta-seconds is less than or equal to zero (0), let expiry-time\n          // be the earliest representable date and time.\"\n          c.setMaxAge(delta);\n        }\n      }\n      break;\n\n    case 'domain': // S5.2.3\n      // \"If the attribute-value is empty, the behavior is undefined.  However,\n      // the user agent SHOULD ignore the cookie-av entirely.\"\n      if (av_value) {\n        // S5.2.3 \"Let cookie-domain be the attribute-value without the leading %x2E\n        // (\".\") character.\"\n        var domain = av_value.trim().replace(/^\\./, '');\n        if (domain) {\n          // \"Convert the cookie-domain to lower case.\"\n          c.domain = domain.toLowerCase();\n        }\n      }\n      break;\n\n    case 'path': // S5.2.4\n      /*\n       * \"If the attribute-value is empty or if the first character of the\n       * attribute-value is not %x2F (\"/\"):\n       *   Let cookie-path be the default-path.\n       * Otherwise:\n       *   Let cookie-path be the attribute-value.\"\n       *\n       * We'll represent the default-path as null since it depends on the\n       * context of the parsing.\n       */\n      c.path = av_value && av_value[0] === \"/\" ? av_value : null;\n      break;\n\n    case 'secure': // S5.2.5\n      /*\n       * \"If the attribute-name case-insensitively matches the string \"Secure\",\n       * the user agent MUST append an attribute to the cookie-attribute-list\n       * with an attribute-name of Secure and an empty attribute-value.\"\n       */\n      c.secure = true;\n      break;\n\n    case 'httponly': // S5.2.6 -- effectively the same as 'secure'\n      c.httpOnly = true;\n      break;\n\n    default:\n      c.extensions = c.extensions || [];\n      c.extensions.push(av);\n      break;\n    }\n  }\n\n  return c;\n}\n\n// avoid the V8 deoptimization monster!\nfunction jsonParse(str) {\n  var obj;\n  try {\n    obj = JSON.parse(str);\n  } catch (e) {\n    return e;\n  }\n  return obj;\n}\n\nfunction fromJSON(str) {\n  if (!str) {\n    return null;\n  }\n\n  var obj;\n  if (typeof str === 'string') {\n    obj = jsonParse(str);\n    if (obj instanceof Error) {\n      return null;\n    }\n  } else {\n    // assume it's an Object\n    obj = str;\n  }\n\n  var c = new Cookie();\n  for (var i=0; i<Cookie.serializableProperties.length; i++) {\n    var prop = Cookie.serializableProperties[i];\n    if (obj[prop] === undefined ||\n        obj[prop] === Cookie.prototype[prop])\n    {\n      continue; // leave as prototype default\n    }\n\n    if (prop === 'expires' ||\n        prop === 'creation' ||\n        prop === 'lastAccessed')\n    {\n      if (obj[prop] === null) {\n        c[prop] = null;\n      } else {\n        c[prop] = obj[prop] == \"Infinity\" ?\n          \"Infinity\" : new Date(obj[prop]);\n      }\n    } else {\n      c[prop] = obj[prop];\n    }\n  }\n\n  return c;\n}\n\n/* Section 5.4 part 2:\n * \"*  Cookies with longer paths are listed before cookies with\n *     shorter paths.\n *\n *  *  Among cookies that have equal-length path fields, cookies with\n *     earlier creation-times are listed before cookies with later\n *     creation-times.\"\n */\n\nfunction cookieCompare(a,b) {\n  var cmp = 0;\n\n  // descending for length: b CMP a\n  var aPathLen = a.path ? a.path.length : 0;\n  var bPathLen = b.path ? b.path.length : 0;\n  cmp = bPathLen - aPathLen;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  // ascending for time: a CMP b\n  var aTime = a.creation ? a.creation.getTime() : MAX_TIME;\n  var bTime = b.creation ? b.creation.getTime() : MAX_TIME;\n  cmp = aTime - bTime;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  // break ties for the same millisecond (precision of JavaScript's clock)\n  cmp = a.creationIndex - b.creationIndex;\n\n  return cmp;\n}\n\n// Gives the permutation of all possible pathMatch()es of a given path. The\n// array is in longest-to-shortest order.  Handy for indexing.\nfunction permutePath(path) {\n  if (path === '/') {\n    return ['/'];\n  }\n  if (path.lastIndexOf('/') === path.length-1) {\n    path = path.substr(0,path.length-1);\n  }\n  var permutations = [path];\n  while (path.length > 1) {\n    var lindex = path.lastIndexOf('/');\n    if (lindex === 0) {\n      break;\n    }\n    path = path.substr(0,lindex);\n    permutations.push(path);\n  }\n  permutations.push('/');\n  return permutations;\n}\n\nfunction getCookieContext(url) {\n  if (url instanceof Object) {\n    return url;\n  }\n  // NOTE: decodeURI will throw on malformed URIs (see GH-32).\n  // Therefore, we will just skip decoding for such URIs.\n  try {\n    url = decodeURI(url);\n  }\n  catch(err) {\n    // Silently swallow error\n  }\n\n  return urlParse(url);\n}\n\nfunction Cookie(options) {\n  options = options || {};\n\n  Object.keys(options).forEach(function(prop) {\n    if (Cookie.prototype.hasOwnProperty(prop) &&\n        Cookie.prototype[prop] !== options[prop] &&\n        prop.substr(0,1) !== '_')\n    {\n      this[prop] = options[prop];\n    }\n  }, this);\n\n  this.creation = this.creation || new Date();\n\n  // used to break creation ties in cookieCompare():\n  Object.defineProperty(this, 'creationIndex', {\n    configurable: false,\n    enumerable: false, // important for assert.deepEqual checks\n    writable: true,\n    value: ++Cookie.cookiesCreated\n  });\n}\n\nCookie.cookiesCreated = 0; // incremented each time a cookie is created\n\nCookie.parse = parse;\nCookie.fromJSON = fromJSON;\n\nCookie.prototype.key = \"\";\nCookie.prototype.value = \"\";\n\n// the order in which the RFC has them:\nCookie.prototype.expires = \"Infinity\"; // coerces to literal Infinity\nCookie.prototype.maxAge = null; // takes precedence over expires for TTL\nCookie.prototype.domain = null;\nCookie.prototype.path = null;\nCookie.prototype.secure = false;\nCookie.prototype.httpOnly = false;\nCookie.prototype.extensions = null;\n\n// set by the CookieJar:\nCookie.prototype.hostOnly = null; // boolean when set\nCookie.prototype.pathIsDefault = null; // boolean when set\nCookie.prototype.creation = null; // Date when set; defaulted by Cookie.parse\nCookie.prototype.lastAccessed = null; // Date when set\nObject.defineProperty(Cookie.prototype, 'creationIndex', {\n  configurable: true,\n  enumerable: false,\n  writable: true,\n  value: 0\n});\n\nCookie.serializableProperties = Object.keys(Cookie.prototype)\n  .filter(function(prop) {\n    return !(\n      Cookie.prototype[prop] instanceof Function ||\n      prop === 'creationIndex' ||\n      prop.substr(0,1) === '_'\n    );\n  });\n\nCookie.prototype.inspect = function inspect() {\n  var now = Date.now();\n  return 'Cookie=\"'+this.toString() +\n    '; hostOnly='+(this.hostOnly != null ? this.hostOnly : '?') +\n    '; aAge='+(this.lastAccessed ? (now-this.lastAccessed.getTime())+'ms' : '?') +\n    '; cAge='+(this.creation ? (now-this.creation.getTime())+'ms' : '?') +\n    '\"';\n};\n\n// Use the new custom inspection symbol to add the custom inspect function if\n// available.\nif (util.inspect.custom) {\n  Cookie.prototype[util.inspect.custom] = Cookie.prototype.inspect;\n}\n\nCookie.prototype.toJSON = function() {\n  var obj = {};\n\n  var props = Cookie.serializableProperties;\n  for (var i=0; i<props.length; i++) {\n    var prop = props[i];\n    if (this[prop] === Cookie.prototype[prop]) {\n      continue; // leave as prototype default\n    }\n\n    if (prop === 'expires' ||\n        prop === 'creation' ||\n        prop === 'lastAccessed')\n    {\n      if (this[prop] === null) {\n        obj[prop] = null;\n      } else {\n        obj[prop] = this[prop] == \"Infinity\" ? // intentionally not ===\n          \"Infinity\" : this[prop].toISOString();\n      }\n    } else if (prop === 'maxAge') {\n      if (this[prop] !== null) {\n        // again, intentionally not ===\n        obj[prop] = (this[prop] == Infinity || this[prop] == -Infinity) ?\n          this[prop].toString() : this[prop];\n      }\n    } else {\n      if (this[prop] !== Cookie.prototype[prop]) {\n        obj[prop] = this[prop];\n      }\n    }\n  }\n\n  return obj;\n};\n\nCookie.prototype.clone = function() {\n  return fromJSON(this.toJSON());\n};\n\nCookie.prototype.validate = function validate() {\n  if (!COOKIE_OCTETS.test(this.value)) {\n    return false;\n  }\n  if (this.expires != Infinity && !(this.expires instanceof Date) && !parseDate(this.expires)) {\n    return false;\n  }\n  if (this.maxAge != null && this.maxAge <= 0) {\n    return false; // \"Max-Age=\" non-zero-digit *DIGIT\n  }\n  if (this.path != null && !PATH_VALUE.test(this.path)) {\n    return false;\n  }\n\n  var cdomain = this.cdomain();\n  if (cdomain) {\n    if (cdomain.match(/\\.$/)) {\n      return false; // S4.1.2.3 suggests that this is bad. domainMatch() tests confirm this\n    }\n    var suffix = pubsuffix.getPublicSuffix(cdomain);\n    if (suffix == null) { // it's a public suffix\n      return false;\n    }\n  }\n  return true;\n};\n\nCookie.prototype.setExpires = function setExpires(exp) {\n  if (exp instanceof Date) {\n    this.expires = exp;\n  } else {\n    this.expires = parseDate(exp) || \"Infinity\";\n  }\n};\n\nCookie.prototype.setMaxAge = function setMaxAge(age) {\n  if (age === Infinity || age === -Infinity) {\n    this.maxAge = age.toString(); // so JSON.stringify() works\n  } else {\n    this.maxAge = age;\n  }\n};\n\n// gives Cookie header format\nCookie.prototype.cookieString = function cookieString() {\n  var val = this.value;\n  if (val == null) {\n    val = '';\n  }\n  if (this.key === '') {\n    return val;\n  }\n  return this.key+'='+val;\n};\n\n// gives Set-Cookie header format\nCookie.prototype.toString = function toString() {\n  var str = this.cookieString();\n\n  if (this.expires != Infinity) {\n    if (this.expires instanceof Date) {\n      str += '; Expires='+formatDate(this.expires);\n    } else {\n      str += '; Expires='+this.expires;\n    }\n  }\n\n  if (this.maxAge != null && this.maxAge != Infinity) {\n    str += '; Max-Age='+this.maxAge;\n  }\n\n  if (this.domain && !this.hostOnly) {\n    str += '; Domain='+this.domain;\n  }\n  if (this.path) {\n    str += '; Path='+this.path;\n  }\n\n  if (this.secure) {\n    str += '; Secure';\n  }\n  if (this.httpOnly) {\n    str += '; HttpOnly';\n  }\n  if (this.extensions) {\n    this.extensions.forEach(function(ext) {\n      str += '; '+ext;\n    });\n  }\n\n  return str;\n};\n\n// TTL() partially replaces the \"expiry-time\" parts of S5.3 step 3 (setCookie()\n// elsewhere)\n// S5.3 says to give the \"latest representable date\" for which we use Infinity\n// For \"expired\" we use 0\nCookie.prototype.TTL = function TTL(now) {\n  /* RFC6265 S4.1.2.2 If a cookie has both the Max-Age and the Expires\n   * attribute, the Max-Age attribute has precedence and controls the\n   * expiration date of the cookie.\n   * (Concurs with S5.3 step 3)\n   */\n  if (this.maxAge != null) {\n    return this.maxAge<=0 ? 0 : this.maxAge*1000;\n  }\n\n  var expires = this.expires;\n  if (expires != Infinity) {\n    if (!(expires instanceof Date)) {\n      expires = parseDate(expires) || Infinity;\n    }\n\n    if (expires == Infinity) {\n      return Infinity;\n    }\n\n    return expires.getTime() - (now || Date.now());\n  }\n\n  return Infinity;\n};\n\n// expiryTime() replaces the \"expiry-time\" parts of S5.3 step 3 (setCookie()\n// elsewhere)\nCookie.prototype.expiryTime = function expiryTime(now) {\n  if (this.maxAge != null) {\n    var relativeTo = now || this.creation || new Date();\n    var age = (this.maxAge <= 0) ? -Infinity : this.maxAge*1000;\n    return relativeTo.getTime() + age;\n  }\n\n  if (this.expires == Infinity) {\n    return Infinity;\n  }\n  return this.expires.getTime();\n};\n\n// expiryDate() replaces the \"expiry-time\" parts of S5.3 step 3 (setCookie()\n// elsewhere), except it returns a Date\nCookie.prototype.expiryDate = function expiryDate(now) {\n  var millisec = this.expiryTime(now);\n  if (millisec == Infinity) {\n    return new Date(MAX_TIME);\n  } else if (millisec == -Infinity) {\n    return new Date(MIN_TIME);\n  } else {\n    return new Date(millisec);\n  }\n};\n\n// This replaces the \"persistent-flag\" parts of S5.3 step 3\nCookie.prototype.isPersistent = function isPersistent() {\n  return (this.maxAge != null || this.expires != Infinity);\n};\n\n// Mostly S5.1.2 and S5.2.3:\nCookie.prototype.cdomain =\nCookie.prototype.canonicalizedDomain = function canonicalizedDomain() {\n  if (this.domain == null) {\n    return null;\n  }\n  return canonicalDomain(this.domain);\n};\n\nfunction CookieJar(store, options) {\n  if (typeof options === \"boolean\") {\n    options = {rejectPublicSuffixes: options};\n  } else if (options == null) {\n    options = {};\n  }\n  if (options.rejectPublicSuffixes != null) {\n    this.rejectPublicSuffixes = options.rejectPublicSuffixes;\n  }\n  if (options.looseMode != null) {\n    this.enableLooseMode = options.looseMode;\n  }\n\n  if (!store) {\n    store = new MemoryCookieStore();\n  }\n  this.store = store;\n}\nCookieJar.prototype.store = null;\nCookieJar.prototype.rejectPublicSuffixes = true;\nCookieJar.prototype.enableLooseMode = false;\nvar CAN_BE_SYNC = [];\n\nCAN_BE_SYNC.push('setCookie');\nCookieJar.prototype.setCookie = function(cookie, url, options, cb) {\n  var err;\n  var context = getCookieContext(url);\n  if (options instanceof Function) {\n    cb = options;\n    options = {};\n  }\n\n  var host = canonicalDomain(context.hostname);\n  var loose = this.enableLooseMode;\n  if (options.loose != null) {\n    loose = options.loose;\n  }\n\n  // S5.3 step 1\n  if (!(cookie instanceof Cookie)) {\n    cookie = Cookie.parse(cookie, { loose: loose });\n  }\n  if (!cookie) {\n    err = new Error(\"Cookie failed to parse\");\n    return cb(options.ignoreError ? null : err);\n  }\n\n  // S5.3 step 2\n  var now = options.now || new Date(); // will assign later to save effort in the face of errors\n\n  // S5.3 step 3: NOOP; persistent-flag and expiry-time is handled by getCookie()\n\n  // S5.3 step 4: NOOP; domain is null by default\n\n  // S5.3 step 5: public suffixes\n  if (this.rejectPublicSuffixes && cookie.domain) {\n    var suffix = pubsuffix.getPublicSuffix(cookie.cdomain());\n    if (suffix == null) { // e.g. \"com\"\n      err = new Error(\"Cookie has domain set to a public suffix\");\n      return cb(options.ignoreError ? null : err);\n    }\n  }\n\n  // S5.3 step 6:\n  if (cookie.domain) {\n    if (!domainMatch(host, cookie.cdomain(), false)) {\n      err = new Error(\"Cookie not in this host's domain. Cookie:\"+cookie.cdomain()+\" Request:\"+host);\n      return cb(options.ignoreError ? null : err);\n    }\n\n    if (cookie.hostOnly == null) { // don't reset if already set\n      cookie.hostOnly = false;\n    }\n\n  } else {\n    cookie.hostOnly = true;\n    cookie.domain = host;\n  }\n\n  //S5.2.4 If the attribute-value is empty or if the first character of the\n  //attribute-value is not %x2F (\"/\"):\n  //Let cookie-path be the default-path.\n  if (!cookie.path || cookie.path[0] !== '/') {\n    cookie.path = defaultPath(context.pathname);\n    cookie.pathIsDefault = true;\n  }\n\n  // S5.3 step 8: NOOP; secure attribute\n  // S5.3 step 9: NOOP; httpOnly attribute\n\n  // S5.3 step 10\n  if (options.http === false && cookie.httpOnly) {\n    err = new Error(\"Cookie is HttpOnly and this isn't an HTTP API\");\n    return cb(options.ignoreError ? null : err);\n  }\n\n  var store = this.store;\n\n  if (!store.updateCookie) {\n    store.updateCookie = function(oldCookie, newCookie, cb) {\n      this.putCookie(newCookie, cb);\n    };\n  }\n\n  function withCookie(err, oldCookie) {\n    if (err) {\n      return cb(err);\n    }\n\n    var next = function(err) {\n      if (err) {\n        return cb(err);\n      } else {\n        cb(null, cookie);\n      }\n    };\n\n    if (oldCookie) {\n      // S5.3 step 11 - \"If the cookie store contains a cookie with the same name,\n      // domain, and path as the newly created cookie:\"\n      if (options.http === false && oldCookie.httpOnly) { // step 11.2\n        err = new Error(\"old Cookie is HttpOnly and this isn't an HTTP API\");\n        return cb(options.ignoreError ? null : err);\n      }\n      cookie.creation = oldCookie.creation; // step 11.3\n      cookie.creationIndex = oldCookie.creationIndex; // preserve tie-breaker\n      cookie.lastAccessed = now;\n      // Step 11.4 (delete cookie) is implied by just setting the new one:\n      store.updateCookie(oldCookie, cookie, next); // step 12\n\n    } else {\n      cookie.creation = cookie.lastAccessed = now;\n      store.putCookie(cookie, next); // step 12\n    }\n  }\n\n  store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);\n};\n\n// RFC6365 S5.4\nCAN_BE_SYNC.push('getCookies');\nCookieJar.prototype.getCookies = function(url, options, cb) {\n  var context = getCookieContext(url);\n  if (options instanceof Function) {\n    cb = options;\n    options = {};\n  }\n\n  var host = canonicalDomain(context.hostname);\n  var path = context.pathname || '/';\n\n  var secure = options.secure;\n  if (secure == null && context.protocol &&\n      (context.protocol == 'https:' || context.protocol == 'wss:'))\n  {\n    secure = true;\n  }\n\n  var http = options.http;\n  if (http == null) {\n    http = true;\n  }\n\n  var now = options.now || Date.now();\n  var expireCheck = options.expire !== false;\n  var allPaths = !!options.allPaths;\n  var store = this.store;\n\n  function matchingCookie(c) {\n    // \"Either:\n    //   The cookie's host-only-flag is true and the canonicalized\n    //   request-host is identical to the cookie's domain.\n    // Or:\n    //   The cookie's host-only-flag is false and the canonicalized\n    //   request-host domain-matches the cookie's domain.\"\n    if (c.hostOnly) {\n      if (c.domain != host) {\n        return false;\n      }\n    } else {\n      if (!domainMatch(host, c.domain, false)) {\n        return false;\n      }\n    }\n\n    // \"The request-uri's path path-matches the cookie's path.\"\n    if (!allPaths && !pathMatch(path, c.path)) {\n      return false;\n    }\n\n    // \"If the cookie's secure-only-flag is true, then the request-uri's\n    // scheme must denote a \"secure\" protocol\"\n    if (c.secure && !secure) {\n      return false;\n    }\n\n    // \"If the cookie's http-only-flag is true, then exclude the cookie if the\n    // cookie-string is being generated for a \"non-HTTP\" API\"\n    if (c.httpOnly && !http) {\n      return false;\n    }\n\n    // deferred from S5.3\n    // non-RFC: allow retention of expired cookies by choice\n    if (expireCheck && c.expiryTime() <= now) {\n      store.removeCookie(c.domain, c.path, c.key, function(){}); // result ignored\n      return false;\n    }\n\n    return true;\n  }\n\n  store.findCookies(host, allPaths ? null : path, function(err,cookies) {\n    if (err) {\n      return cb(err);\n    }\n\n    cookies = cookies.filter(matchingCookie);\n\n    // sorting of S5.4 part 2\n    if (options.sort !== false) {\n      cookies = cookies.sort(cookieCompare);\n    }\n\n    // S5.4 part 3\n    var now = new Date();\n    cookies.forEach(function(c) {\n      c.lastAccessed = now;\n    });\n    // TODO persist lastAccessed\n\n    cb(null,cookies);\n  });\n};\n\nCAN_BE_SYNC.push('getCookieString');\nCookieJar.prototype.getCookieString = function(/*..., cb*/) {\n  var args = Array.prototype.slice.call(arguments,0);\n  var cb = args.pop();\n  var next = function(err,cookies) {\n    if (err) {\n      cb(err);\n    } else {\n      cb(null, cookies\n        .sort(cookieCompare)\n        .map(function(c){\n          return c.cookieString();\n        })\n        .join('; '));\n    }\n  };\n  args.push(next);\n  this.getCookies.apply(this,args);\n};\n\nCAN_BE_SYNC.push('getSetCookieStrings');\nCookieJar.prototype.getSetCookieStrings = function(/*..., cb*/) {\n  var args = Array.prototype.slice.call(arguments,0);\n  var cb = args.pop();\n  var next = function(err,cookies) {\n    if (err) {\n      cb(err);\n    } else {\n      cb(null, cookies.map(function(c){\n        return c.toString();\n      }));\n    }\n  };\n  args.push(next);\n  this.getCookies.apply(this,args);\n};\n\nCAN_BE_SYNC.push('serialize');\nCookieJar.prototype.serialize = function(cb) {\n  var type = this.store.constructor.name;\n  if (type === 'Object') {\n    type = null;\n  }\n\n  // update README.md \"Serialization Format\" if you change this, please!\n  var serialized = {\n    // The version of tough-cookie that serialized this jar. Generally a good\n    // practice since future versions can make data import decisions based on\n    // known past behavior. When/if this matters, use `semver`.\n    version: 'tough-cookie@'+VERSION,\n\n    // add the store type, to make humans happy:\n    storeType: type,\n\n    // CookieJar configuration:\n    rejectPublicSuffixes: !!this.rejectPublicSuffixes,\n\n    // this gets filled from getAllCookies:\n    cookies: []\n  };\n\n  if (!(this.store.getAllCookies &&\n        typeof this.store.getAllCookies === 'function'))\n  {\n    return cb(new Error('store does not support getAllCookies and cannot be serialized'));\n  }\n\n  this.store.getAllCookies(function(err,cookies) {\n    if (err) {\n      return cb(err);\n    }\n\n    serialized.cookies = cookies.map(function(cookie) {\n      // convert to serialized 'raw' cookies\n      cookie = (cookie instanceof Cookie) ? cookie.toJSON() : cookie;\n\n      // Remove the index so new ones get assigned during deserialization\n      delete cookie.creationIndex;\n\n      return cookie;\n    });\n\n    return cb(null, serialized);\n  });\n};\n\n// well-known name that JSON.stringify calls\nCookieJar.prototype.toJSON = function() {\n  return this.serializeSync();\n};\n\n// use the class method CookieJar.deserialize instead of calling this directly\nCAN_BE_SYNC.push('_importCookies');\nCookieJar.prototype._importCookies = function(serialized, cb) {\n  var jar = this;\n  var cookies = serialized.cookies;\n  if (!cookies || !Array.isArray(cookies)) {\n    return cb(new Error('serialized jar has no cookies array'));\n  }\n  cookies = cookies.slice(); // do not modify the original\n\n  function putNext(err) {\n    if (err) {\n      return cb(err);\n    }\n\n    if (!cookies.length) {\n      return cb(err, jar);\n    }\n\n    var cookie;\n    try {\n      cookie = fromJSON(cookies.shift());\n    } catch (e) {\n      return cb(e);\n    }\n\n    if (cookie === null) {\n      return putNext(null); // skip this cookie\n    }\n\n    jar.store.putCookie(cookie, putNext);\n  }\n\n  putNext();\n};\n\nCookieJar.deserialize = function(strOrObj, store, cb) {\n  if (arguments.length !== 3) {\n    // store is optional\n    cb = store;\n    store = null;\n  }\n\n  var serialized;\n  if (typeof strOrObj === 'string') {\n    serialized = jsonParse(strOrObj);\n    if (serialized instanceof Error) {\n      return cb(serialized);\n    }\n  } else {\n    serialized = strOrObj;\n  }\n\n  var jar = new CookieJar(store, serialized.rejectPublicSuffixes);\n  jar._importCookies(serialized, function(err) {\n    if (err) {\n      return cb(err);\n    }\n    cb(null, jar);\n  });\n};\n\nCookieJar.deserializeSync = function(strOrObj, store) {\n  var serialized = typeof strOrObj === 'string' ?\n    JSON.parse(strOrObj) : strOrObj;\n  var jar = new CookieJar(store, serialized.rejectPublicSuffixes);\n\n  // catch this mistake early:\n  if (!jar.store.synchronous) {\n    throw new Error('CookieJar store is not synchronous; use async API instead.');\n  }\n\n  jar._importCookiesSync(serialized);\n  return jar;\n};\nCookieJar.fromJSON = CookieJar.deserializeSync;\n\nCookieJar.prototype.clone = function(newStore, cb) {\n  if (arguments.length === 1) {\n    cb = newStore;\n    newStore = null;\n  }\n\n  this.serialize(function(err,serialized) {\n    if (err) {\n      return cb(err);\n    }\n    CookieJar.deserialize(serialized, newStore, cb);\n  });\n};\n\nCAN_BE_SYNC.push('removeAllCookies');\nCookieJar.prototype.removeAllCookies = function(cb) {\n  var store = this.store;\n\n  // Check that the store implements its own removeAllCookies(). The default\n  // implementation in Store will immediately call the callback with a \"not\n  // implemented\" Error.\n  if (store.removeAllCookies instanceof Function &&\n      store.removeAllCookies !== Store.prototype.removeAllCookies)\n  {\n    return store.removeAllCookies(cb);\n  }\n\n  store.getAllCookies(function(err, cookies) {\n    if (err) {\n      return cb(err);\n    }\n\n    if (cookies.length === 0) {\n      return cb(null);\n    }\n\n    var completedCount = 0;\n    var removeErrors = [];\n\n    function removeCookieCb(removeErr) {\n      if (removeErr) {\n        removeErrors.push(removeErr);\n      }\n\n      completedCount++;\n\n      if (completedCount === cookies.length) {\n        return cb(removeErrors.length ? removeErrors[0] : null);\n      }\n    }\n\n    cookies.forEach(function(cookie) {\n      store.removeCookie(cookie.domain, cookie.path, cookie.key, removeCookieCb);\n    });\n  });\n};\n\nCookieJar.prototype._cloneSync = syncWrap('clone');\nCookieJar.prototype.cloneSync = function(newStore) {\n  if (!newStore.synchronous) {\n    throw new Error('CookieJar clone destination store is not synchronous; use async API instead.');\n  }\n  return this._cloneSync(newStore);\n};\n\n// Use a closure to provide a true imperative API for synchronous stores.\nfunction syncWrap(method) {\n  return function() {\n    if (!this.store.synchronous) {\n      throw new Error('CookieJar store is not synchronous; use async API instead.');\n    }\n\n    var args = Array.prototype.slice.call(arguments);\n    var syncErr, syncResult;\n    args.push(function syncCb(err, result) {\n      syncErr = err;\n      syncResult = result;\n    });\n    this[method].apply(this, args);\n\n    if (syncErr) {\n      throw syncErr;\n    }\n    return syncResult;\n  };\n}\n\n// wrap all declared CAN_BE_SYNC methods in the sync wrapper\nCAN_BE_SYNC.forEach(function(method) {\n  CookieJar.prototype[method+'Sync'] = syncWrap(method);\n});\n\nexports.version = VERSION;\nexports.CookieJar = CookieJar;\nexports.Cookie = Cookie;\nexports.Store = Store;\nexports.MemoryCookieStore = MemoryCookieStore;\nexports.parseDate = parseDate;\nexports.formatDate = formatDate;\nexports.parse = parse;\nexports.fromJSON = fromJSON;\nexports.domainMatch = domainMatch;\nexports.defaultPath = defaultPath;\nexports.pathMatch = pathMatch;\nexports.getPublicSuffix = pubsuffix.getPublicSuffix;\nexports.cookieCompare = cookieCompare;\nexports.permuteDomain = __webpack_require__(/*! ./permuteDomain */ \"(rsc)/./node_modules/request/node_modules/tough-cookie/lib/permuteDomain.js\").permuteDomain;\nexports.permutePath = permutePath;\nexports.canonicalDomain = canonicalDomain;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL2xpYi9jb29raWUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLCtCQUErQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYixVQUFVLG1CQUFPLENBQUMsZ0JBQUs7QUFDdkIsZUFBZSw2Q0FBb0I7QUFDbkMsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLGdCQUFnQixtQkFBTyxDQUFDLG9HQUFpQjtBQUN6QyxZQUFZLGlIQUF3QjtBQUNwQyx3QkFBd0IsbUlBQXVDO0FBQy9ELGdCQUFnQiw2SEFBZ0M7QUFDaEQsY0FBYyxtQkFBTyxDQUFDLHdGQUFXOztBQUVqQztBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLDBCQUFVO0FBQy9CLEVBQUU7QUFDRixtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUVBQW1FO0FBQ25FLFVBQVU7QUFDVjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUIsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3Qiw4QkFBOEI7QUFDOUIsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlDQUF5QztBQUN6QztBQUNBLElBQUksT0FBTztBQUNYLHdCQUF3QjtBQUN4QixjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLHdDQUF3QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QyxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQyx1Q0FBdUM7QUFDdkMsa0NBQWtDLGtCQUFrQjtBQUNwRCxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxPQUFPO0FBQ1AsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLE1BQU07QUFDTixnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1Qzs7QUFFdkMsd0JBQXdCOztBQUV4Qix3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEIsd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsbURBQW1EOztBQUVuRCxNQUFNO0FBQ047QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOERBQThELEdBQUc7QUFDakU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxlQUFlO0FBQ2YsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZCxhQUFhO0FBQ2IseUJBQXlCO0FBQ3pCLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsYUFBYTtBQUNiLGdCQUFnQjtBQUNoQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQix1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCLCtKQUFnRTtBQUNoRSxtQkFBbUI7QUFDbkIsdUJBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGFnZS1mb3JtLy4vbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL3RvdWdoLWNvb2tpZS9saWIvY29va2llLmpzPzkzOTciXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUsIFNhbGVzZm9yY2UuY29tLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXG4gKiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIFNhbGVzZm9yY2UuY29tIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXlcbiAqIGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXRcbiAqIHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAqIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkVcbiAqIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiAqIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4gKiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcbiAqIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4gKiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuICogQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAqIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG4ndXNlIHN0cmljdCc7XG52YXIgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG52YXIgdXJsUGFyc2UgPSByZXF1aXJlKCd1cmwnKS5wYXJzZTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIHB1YnN1ZmZpeCA9IHJlcXVpcmUoJy4vcHVic3VmZml4LXBzbCcpO1xudmFyIFN0b3JlID0gcmVxdWlyZSgnLi9zdG9yZScpLlN0b3JlO1xudmFyIE1lbW9yeUNvb2tpZVN0b3JlID0gcmVxdWlyZSgnLi9tZW1zdG9yZScpLk1lbW9yeUNvb2tpZVN0b3JlO1xudmFyIHBhdGhNYXRjaCA9IHJlcXVpcmUoJy4vcGF0aE1hdGNoJykucGF0aE1hdGNoO1xudmFyIFZFUlNJT04gPSByZXF1aXJlKCcuL3ZlcnNpb24nKTtcblxudmFyIHB1bnljb2RlO1xudHJ5IHtcbiAgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xufSBjYXRjaChlKSB7XG4gIGNvbnNvbGUud2FybihcInRvdWdoLWNvb2tpZTogY2FuJ3QgbG9hZCBwdW55Y29kZTsgd29uJ3QgdXNlIHB1bnljb2RlIGZvciBkb21haW4gbm9ybWFsaXphdGlvblwiKTtcbn1cblxuLy8gRnJvbSBSRkM2MjY1IFM0LjEuMVxuLy8gbm90ZSB0aGF0IGl0IGV4Y2x1ZGVzIFxceDNCIFwiO1wiXG52YXIgQ09PS0lFX09DVEVUUyA9IC9eW1xceDIxXFx4MjMtXFx4MkJcXHgyRC1cXHgzQVxceDNDLVxceDVCXFx4NUQtXFx4N0VdKyQvO1xuXG52YXIgQ09OVFJPTF9DSEFSUyA9IC9bXFx4MDAtXFx4MUZdLztcblxuLy8gRnJvbSBDaHJvbWl1bSAvLyAnXFxyJywgJ1xcbicgYW5kICdcXDAnIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgdGVybWluYXRvciBpblxuLy8gdGhlIFwicmVsYXhlZFwiIG1vZGUsIHNlZTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9DaHJvbWl1bVdlYkFwcHMvY2hyb21pdW0vYmxvYi9iM2QzYjRkYThiYjk0YzFiMmUwNjE2MDBkZjEwNmQ1OTBmZGEzNjIwL25ldC9jb29raWVzL3BhcnNlZF9jb29raWUuY2MjTDYwXG52YXIgVEVSTUlOQVRPUlMgPSBbJ1xcbicsICdcXHInLCAnXFwwJ107XG5cbi8vIFJGQzYyNjUgUzQuMS4xIGRlZmluZXMgcGF0aCB2YWx1ZSBhcyAnYW55IENIQVIgZXhjZXB0IENUTHMgb3IgXCI7XCInXG4vLyBOb3RlICc7JyBpcyBcXHgzQlxudmFyIFBBVEhfVkFMVUUgPSAvW1xceDIwLVxceDNBXFx4M0MtXFx4N0VdKy87XG5cbi8vIGRhdGUtdGltZSBwYXJzaW5nIGNvbnN0YW50cyAoUkZDNjI2NSBTNS4xLjEpXG5cbnZhciBEQVRFX0RFTElNID0gL1tcXHgwOVxceDIwLVxceDJGXFx4M0ItXFx4NDBcXHg1Qi1cXHg2MFxceDdCLVxceDdFXS87XG5cbnZhciBNT05USF9UT19OVU0gPSB7XG4gIGphbjowLCBmZWI6MSwgbWFyOjIsIGFwcjozLCBtYXk6NCwganVuOjUsXG4gIGp1bDo2LCBhdWc6Nywgc2VwOjgsIG9jdDo5LCBub3Y6MTAsIGRlYzoxMVxufTtcbnZhciBOVU1fVE9fTU9OVEggPSBbXG4gICdKYW4nLCdGZWInLCdNYXInLCdBcHInLCdNYXknLCdKdW4nLCdKdWwnLCdBdWcnLCdTZXAnLCdPY3QnLCdOb3YnLCdEZWMnXG5dO1xudmFyIE5VTV9UT19EQVkgPSBbXG4gICdTdW4nLCdNb24nLCdUdWUnLCdXZWQnLCdUaHUnLCdGcmknLCdTYXQnXG5dO1xuXG52YXIgTUFYX1RJTUUgPSAyMTQ3NDgzNjQ3MDAwOyAvLyAzMS1iaXQgbWF4XG52YXIgTUlOX1RJTUUgPSAwOyAvLyAzMS1iaXQgbWluXG5cbi8qXG4gKiBQYXJzZXMgYSBOYXR1cmFsIG51bWJlciAoaS5lLiwgbm9uLW5lZ2F0aXZlIGludGVnZXIpIHdpdGggZWl0aGVyIHRoZVxuICogICAgPG1pbj4qPG1heD5ESUdJVCAoIG5vbi1kaWdpdCAqT0NURVQgKVxuICogb3JcbiAqICAgIDxtaW4+KjxtYXg+RElHSVRcbiAqIGdyYW1tYXIgKFJGQzYyNjUgUzUuMS4xKS5cbiAqXG4gKiBUaGUgXCJ0cmFpbGluZ09LXCIgYm9vbGVhbiBjb250cm9scyBpZiB0aGUgZ3JhbW1hciBhY2NlcHRzIGFcbiAqIFwiKCBub24tZGlnaXQgKk9DVEVUIClcIiB0cmFpbGVyLlxuICovXG5mdW5jdGlvbiBwYXJzZURpZ2l0cyh0b2tlbiwgbWluRGlnaXRzLCBtYXhEaWdpdHMsIHRyYWlsaW5nT0spIHtcbiAgdmFyIGNvdW50ID0gMDtcbiAgd2hpbGUgKGNvdW50IDwgdG9rZW4ubGVuZ3RoKSB7XG4gICAgdmFyIGMgPSB0b2tlbi5jaGFyQ29kZUF0KGNvdW50KTtcbiAgICAvLyBcIm5vbi1kaWdpdCA9ICV4MDAtMkYgLyAleDNBLUZGXCJcbiAgICBpZiAoYyA8PSAweDJGIHx8IGMgPj0gMHgzQSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvdW50Kys7XG4gIH1cblxuICAvLyBjb25zdHJhaW4gdG8gYSBtaW5pbXVtIGFuZCBtYXhpbXVtIG51bWJlciBvZiBkaWdpdHMuXG4gIGlmIChjb3VudCA8IG1pbkRpZ2l0cyB8fCBjb3VudCA+IG1heERpZ2l0cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKCF0cmFpbGluZ09LICYmIGNvdW50ICE9IHRva2VuLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlSW50KHRva2VuLnN1YnN0cigwLGNvdW50KSwgMTApO1xufVxuXG5mdW5jdGlvbiBwYXJzZVRpbWUodG9rZW4pIHtcbiAgdmFyIHBhcnRzID0gdG9rZW4uc3BsaXQoJzonKTtcbiAgdmFyIHJlc3VsdCA9IFswLDAsMF07XG5cbiAgLyogUkY2MjU2IFM1LjEuMTpcbiAgICogICAgICB0aW1lICAgICAgICAgICAgPSBobXMtdGltZSAoIG5vbi1kaWdpdCAqT0NURVQgKVxuICAgKiAgICAgIGhtcy10aW1lICAgICAgICA9IHRpbWUtZmllbGQgXCI6XCIgdGltZS1maWVsZCBcIjpcIiB0aW1lLWZpZWxkXG4gICAqICAgICAgdGltZS1maWVsZCAgICAgID0gMSoyRElHSVRcbiAgICovXG5cbiAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAvLyBcInRpbWUtZmllbGRcIiBtdXN0IGJlIHN0cmljdGx5IFwiMSoyRElHSVRcIiwgSE9XRVZFUiwgXCJobXMtdGltZVwiIGNhbiBiZVxuICAgIC8vIGZvbGxvd2VkIGJ5IFwiKCBub24tZGlnaXQgKk9DVEVUIClcIiBzbyB0aGVyZWZvcmUgdGhlIGxhc3QgdGltZS1maWVsZCBjYW5cbiAgICAvLyBoYXZlIGEgdHJhaWxlclxuICAgIHZhciB0cmFpbGluZ09LID0gKGkgPT0gMik7XG4gICAgdmFyIG51bSA9IHBhcnNlRGlnaXRzKHBhcnRzW2ldLCAxLCAyLCB0cmFpbGluZ09LKTtcbiAgICBpZiAobnVtID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0W2ldID0gbnVtO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VNb250aCh0b2tlbikge1xuICB0b2tlbiA9IFN0cmluZyh0b2tlbikuc3Vic3RyKDAsMykudG9Mb3dlckNhc2UoKTtcbiAgdmFyIG51bSA9IE1PTlRIX1RPX05VTVt0b2tlbl07XG4gIHJldHVybiBudW0gPj0gMCA/IG51bSA6IG51bGw7XG59XG5cbi8qXG4gKiBSRkM2MjY1IFM1LjEuMSBkYXRlIHBhcnNlciAoc2VlIFJGQyBmb3IgZnVsbCBncmFtbWFyKVxuICovXG5mdW5jdGlvbiBwYXJzZURhdGUoc3RyKSB7XG4gIGlmICghc3RyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyogUkZDNjI2NSBTNS4xLjE6XG4gICAqIDIuIFByb2Nlc3MgZWFjaCBkYXRlLXRva2VuIHNlcXVlbnRpYWxseSBpbiB0aGUgb3JkZXIgdGhlIGRhdGUtdG9rZW5zXG4gICAqIGFwcGVhciBpbiB0aGUgY29va2llLWRhdGVcbiAgICovXG4gIHZhciB0b2tlbnMgPSBzdHIuc3BsaXQoREFURV9ERUxJTSk7XG4gIGlmICghdG9rZW5zKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGhvdXIgPSBudWxsO1xuICB2YXIgbWludXRlID0gbnVsbDtcbiAgdmFyIHNlY29uZCA9IG51bGw7XG4gIHZhciBkYXlPZk1vbnRoID0gbnVsbDtcbiAgdmFyIG1vbnRoID0gbnVsbDtcbiAgdmFyIHllYXIgPSBudWxsO1xuXG4gIGZvciAodmFyIGk9MDsgaTx0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV0udHJpbSgpO1xuICAgIGlmICghdG9rZW4ubGVuZ3RoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgLyogMi4xLiBJZiB0aGUgZm91bmQtdGltZSBmbGFnIGlzIG5vdCBzZXQgYW5kIHRoZSB0b2tlbiBtYXRjaGVzIHRoZSB0aW1lXG4gICAgICogcHJvZHVjdGlvbiwgc2V0IHRoZSBmb3VuZC10aW1lIGZsYWcgYW5kIHNldCB0aGUgaG91ci0gdmFsdWUsXG4gICAgICogbWludXRlLXZhbHVlLCBhbmQgc2Vjb25kLXZhbHVlIHRvIHRoZSBudW1iZXJzIGRlbm90ZWQgYnkgdGhlIGRpZ2l0cyBpblxuICAgICAqIHRoZSBkYXRlLXRva2VuLCByZXNwZWN0aXZlbHkuICBTa2lwIHRoZSByZW1haW5pbmcgc3ViLXN0ZXBzIGFuZCBjb250aW51ZVxuICAgICAqIHRvIHRoZSBuZXh0IGRhdGUtdG9rZW4uXG4gICAgICovXG4gICAgaWYgKHNlY29uZCA9PT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gcGFyc2VUaW1lKHRva2VuKTtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgaG91ciA9IHJlc3VsdFswXTtcbiAgICAgICAgbWludXRlID0gcmVzdWx0WzFdO1xuICAgICAgICBzZWNvbmQgPSByZXN1bHRbMl07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIDIuMi4gSWYgdGhlIGZvdW5kLWRheS1vZi1tb250aCBmbGFnIGlzIG5vdCBzZXQgYW5kIHRoZSBkYXRlLXRva2VuIG1hdGNoZXNcbiAgICAgKiB0aGUgZGF5LW9mLW1vbnRoIHByb2R1Y3Rpb24sIHNldCB0aGUgZm91bmQtZGF5LW9mLSBtb250aCBmbGFnIGFuZCBzZXRcbiAgICAgKiB0aGUgZGF5LW9mLW1vbnRoLXZhbHVlIHRvIHRoZSBudW1iZXIgZGVub3RlZCBieSB0aGUgZGF0ZS10b2tlbi4gIFNraXBcbiAgICAgKiB0aGUgcmVtYWluaW5nIHN1Yi1zdGVwcyBhbmQgY29udGludWUgdG8gdGhlIG5leHQgZGF0ZS10b2tlbi5cbiAgICAgKi9cbiAgICBpZiAoZGF5T2ZNb250aCA9PT0gbnVsbCkge1xuICAgICAgLy8gXCJkYXktb2YtbW9udGggPSAxKjJESUdJVCAoIG5vbi1kaWdpdCAqT0NURVQgKVwiXG4gICAgICByZXN1bHQgPSBwYXJzZURpZ2l0cyh0b2tlbiwgMSwgMiwgdHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgIGRheU9mTW9udGggPSByZXN1bHQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIDIuMy4gSWYgdGhlIGZvdW5kLW1vbnRoIGZsYWcgaXMgbm90IHNldCBhbmQgdGhlIGRhdGUtdG9rZW4gbWF0Y2hlcyB0aGVcbiAgICAgKiBtb250aCBwcm9kdWN0aW9uLCBzZXQgdGhlIGZvdW5kLW1vbnRoIGZsYWcgYW5kIHNldCB0aGUgbW9udGgtdmFsdWUgdG9cbiAgICAgKiB0aGUgbW9udGggZGVub3RlZCBieSB0aGUgZGF0ZS10b2tlbi4gIFNraXAgdGhlIHJlbWFpbmluZyBzdWItc3RlcHMgYW5kXG4gICAgICogY29udGludWUgdG8gdGhlIG5leHQgZGF0ZS10b2tlbi5cbiAgICAgKi9cbiAgICBpZiAobW9udGggPT09IG51bGwpIHtcbiAgICAgIHJlc3VsdCA9IHBhcnNlTW9udGgodG9rZW4pO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICBtb250aCA9IHJlc3VsdDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogMi40LiBJZiB0aGUgZm91bmQteWVhciBmbGFnIGlzIG5vdCBzZXQgYW5kIHRoZSBkYXRlLXRva2VuIG1hdGNoZXMgdGhlXG4gICAgICogeWVhciBwcm9kdWN0aW9uLCBzZXQgdGhlIGZvdW5kLXllYXIgZmxhZyBhbmQgc2V0IHRoZSB5ZWFyLXZhbHVlIHRvIHRoZVxuICAgICAqIG51bWJlciBkZW5vdGVkIGJ5IHRoZSBkYXRlLXRva2VuLiAgU2tpcCB0aGUgcmVtYWluaW5nIHN1Yi1zdGVwcyBhbmRcbiAgICAgKiBjb250aW51ZSB0byB0aGUgbmV4dCBkYXRlLXRva2VuLlxuICAgICAqL1xuICAgIGlmICh5ZWFyID09PSBudWxsKSB7XG4gICAgICAvLyBcInllYXIgPSAyKjRESUdJVCAoIG5vbi1kaWdpdCAqT0NURVQgKVwiXG4gICAgICByZXN1bHQgPSBwYXJzZURpZ2l0cyh0b2tlbiwgMiwgNCwgdHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgIHllYXIgPSByZXN1bHQ7XG4gICAgICAgIC8qIEZyb20gUzUuMS4xOlxuICAgICAgICAgKiAzLiAgSWYgdGhlIHllYXItdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDcwIGFuZCBsZXNzXG4gICAgICAgICAqIHRoYW4gb3IgZXF1YWwgdG8gOTksIGluY3JlbWVudCB0aGUgeWVhci12YWx1ZSBieSAxOTAwLlxuICAgICAgICAgKiA0LiAgSWYgdGhlIHllYXItdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAgYW5kIGxlc3NcbiAgICAgICAgICogdGhhbiBvciBlcXVhbCB0byA2OSwgaW5jcmVtZW50IHRoZSB5ZWFyLXZhbHVlIGJ5IDIwMDAuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoeWVhciA+PSA3MCAmJiB5ZWFyIDw9IDk5KSB7XG4gICAgICAgICAgeWVhciArPSAxOTAwO1xuICAgICAgICB9IGVsc2UgaWYgKHllYXIgPj0gMCAmJiB5ZWFyIDw9IDY5KSB7XG4gICAgICAgICAgeWVhciArPSAyMDAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogUkZDIDYyNjUgUzUuMS4xXG4gICAqIFwiNS4gQWJvcnQgdGhlc2Ugc3RlcHMgYW5kIGZhaWwgdG8gcGFyc2UgdGhlIGNvb2tpZS1kYXRlIGlmOlxuICAgKiAgICAgKiAgYXQgbGVhc3Qgb25lIG9mIHRoZSBmb3VuZC1kYXktb2YtbW9udGgsIGZvdW5kLW1vbnRoLCBmb3VuZC1cbiAgICogICAgICAgIHllYXIsIG9yIGZvdW5kLXRpbWUgZmxhZ3MgaXMgbm90IHNldCxcbiAgICogICAgICogIHRoZSBkYXktb2YtbW9udGgtdmFsdWUgaXMgbGVzcyB0aGFuIDEgb3IgZ3JlYXRlciB0aGFuIDMxLFxuICAgKiAgICAgKiAgdGhlIHllYXItdmFsdWUgaXMgbGVzcyB0aGFuIDE2MDEsXG4gICAqICAgICAqICB0aGUgaG91ci12YWx1ZSBpcyBncmVhdGVyIHRoYW4gMjMsXG4gICAqICAgICAqICB0aGUgbWludXRlLXZhbHVlIGlzIGdyZWF0ZXIgdGhhbiA1OSwgb3JcbiAgICogICAgICogIHRoZSBzZWNvbmQtdmFsdWUgaXMgZ3JlYXRlciB0aGFuIDU5LlxuICAgKiAgICAgKE5vdGUgdGhhdCBsZWFwIHNlY29uZHMgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIHRoaXMgc3ludGF4LilcIlxuICAgKlxuICAgKiBTbywgaW4gb3JkZXIgYXMgYWJvdmU6XG4gICAqL1xuICBpZiAoXG4gICAgZGF5T2ZNb250aCA9PT0gbnVsbCB8fCBtb250aCA9PT0gbnVsbCB8fCB5ZWFyID09PSBudWxsIHx8IHNlY29uZCA9PT0gbnVsbCB8fFxuICAgIGRheU9mTW9udGggPCAxIHx8IGRheU9mTW9udGggPiAzMSB8fFxuICAgIHllYXIgPCAxNjAxIHx8XG4gICAgaG91ciA+IDIzIHx8XG4gICAgbWludXRlID4gNTkgfHxcbiAgICBzZWNvbmQgPiA1OVxuICApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheU9mTW9udGgsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kKSk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSkge1xuICB2YXIgZCA9IGRhdGUuZ2V0VVRDRGF0ZSgpOyBkID0gZCA+PSAxMCA/IGQgOiAnMCcrZDtcbiAgdmFyIGggPSBkYXRlLmdldFVUQ0hvdXJzKCk7IGggPSBoID49IDEwID8gaCA6ICcwJytoO1xuICB2YXIgbSA9IGRhdGUuZ2V0VVRDTWludXRlcygpOyBtID0gbSA+PSAxMCA/IG0gOiAnMCcrbTtcbiAgdmFyIHMgPSBkYXRlLmdldFVUQ1NlY29uZHMoKTsgcyA9IHMgPj0gMTAgPyBzIDogJzAnK3M7XG4gIHJldHVybiBOVU1fVE9fREFZW2RhdGUuZ2V0VVRDRGF5KCldICsgJywgJyArXG4gICAgZCsnICcrIE5VTV9UT19NT05USFtkYXRlLmdldFVUQ01vbnRoKCldICsnICcrIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSArJyAnK1xuICAgIGgrJzonK20rJzonK3MrJyBHTVQnO1xufVxuXG4vLyBTNS4xLjIgQ2Fub25pY2FsaXplZCBIb3N0IE5hbWVzXG5mdW5jdGlvbiBjYW5vbmljYWxEb21haW4oc3RyKSB7XG4gIGlmIChzdHIgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZSgvXlxcLi8sJycpOyAvLyBTNC4xLjIuMyAmIFM1LjIuMzogaWdub3JlIGxlYWRpbmcgLlxuXG4gIC8vIGNvbnZlcnQgdG8gSUROIGlmIGFueSBub24tQVNDSUkgY2hhcmFjdGVyc1xuICBpZiAocHVueWNvZGUgJiYgL1teXFx1MDAwMS1cXHUwMDdmXS8udGVzdChzdHIpKSB7XG4gICAgc3RyID0gcHVueWNvZGUudG9BU0NJSShzdHIpO1xuICB9XG5cbiAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpO1xufVxuXG4vLyBTNS4xLjMgRG9tYWluIE1hdGNoaW5nXG5mdW5jdGlvbiBkb21haW5NYXRjaChzdHIsIGRvbVN0ciwgY2Fub25pY2FsaXplKSB7XG4gIGlmIChzdHIgPT0gbnVsbCB8fCBkb21TdHIgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChjYW5vbmljYWxpemUgIT09IGZhbHNlKSB7XG4gICAgc3RyID0gY2Fub25pY2FsRG9tYWluKHN0cik7XG4gICAgZG9tU3RyID0gY2Fub25pY2FsRG9tYWluKGRvbVN0cik7XG4gIH1cblxuICAvKlxuICAgKiBcIlRoZSBkb21haW4gc3RyaW5nIGFuZCB0aGUgc3RyaW5nIGFyZSBpZGVudGljYWwuIChOb3RlIHRoYXQgYm90aCB0aGVcbiAgICogZG9tYWluIHN0cmluZyBhbmQgdGhlIHN0cmluZyB3aWxsIGhhdmUgYmVlbiBjYW5vbmljYWxpemVkIHRvIGxvd2VyIGNhc2UgYXRcbiAgICogdGhpcyBwb2ludClcIlxuICAgKi9cbiAgaWYgKHN0ciA9PSBkb21TdHIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qIFwiQWxsIG9mIHRoZSBmb2xsb3dpbmcgW3RocmVlXSBjb25kaXRpb25zIGhvbGQ6XCIgKG9yZGVyIGFkanVzdGVkIGZyb20gdGhlIFJGQykgKi9cblxuICAvKiBcIiogVGhlIHN0cmluZyBpcyBhIGhvc3QgbmFtZSAoaS5lLiwgbm90IGFuIElQIGFkZHJlc3MpLlwiICovXG4gIGlmIChuZXQuaXNJUChzdHIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyogXCIqIFRoZSBkb21haW4gc3RyaW5nIGlzIGEgc3VmZml4IG9mIHRoZSBzdHJpbmdcIiAqL1xuICB2YXIgaWR4ID0gc3RyLmluZGV4T2YoZG9tU3RyKTtcbiAgaWYgKGlkeCA8PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBpdCdzIGEgbm9uLW1hdGNoICgtMSkgb3IgcHJlZml4ICgwKVxuICB9XG5cbiAgLy8gZS5nIFwiYS5iLmNcIi5pbmRleE9mKFwiYi5jXCIpID09PSAyXG4gIC8vIDUgPT09IDMrMlxuICBpZiAoc3RyLmxlbmd0aCAhPT0gZG9tU3RyLmxlbmd0aCArIGlkeCkgeyAvLyBpdCdzIG5vdCBhIHN1ZmZpeFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qIFwiKiBUaGUgbGFzdCBjaGFyYWN0ZXIgb2YgdGhlIHN0cmluZyB0aGF0IGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgZG9tYWluXG4gICogc3RyaW5nIGlzIGEgJXgyRSAoXCIuXCIpIGNoYXJhY3Rlci5cIiAqL1xuICBpZiAoc3RyLnN1YnN0cihpZHgtMSwxKSAhPT0gJy4nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cblxuLy8gUkZDNjI2NSBTNS4xLjQgUGF0aHMgYW5kIFBhdGgtTWF0Y2hcblxuLypcbiAqIFwiVGhlIHVzZXIgYWdlbnQgTVVTVCB1c2UgYW4gYWxnb3JpdGhtIGVxdWl2YWxlbnQgdG8gdGhlIGZvbGxvd2luZyBhbGdvcml0aG1cbiAqIHRvIGNvbXB1dGUgdGhlIGRlZmF1bHQtcGF0aCBvZiBhIGNvb2tpZTpcIlxuICpcbiAqIEFzc3VtcHRpb246IHRoZSBwYXRoIChhbmQgbm90IHF1ZXJ5IHBhcnQgb3IgYWJzb2x1dGUgdXJpKSBpcyBwYXNzZWQgaW4uXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRQYXRoKHBhdGgpIHtcbiAgLy8gXCIyLiBJZiB0aGUgdXJpLXBhdGggaXMgZW1wdHkgb3IgaWYgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgdXJpLXBhdGggaXMgbm90XG4gIC8vIGEgJXgyRiAoXCIvXCIpIGNoYXJhY3Rlciwgb3V0cHV0ICV4MkYgKFwiL1wiKSBhbmQgc2tpcCB0aGUgcmVtYWluaW5nIHN0ZXBzLlxuICBpZiAoIXBhdGggfHwgcGF0aC5zdWJzdHIoMCwxKSAhPT0gXCIvXCIpIHtcbiAgICByZXR1cm4gXCIvXCI7XG4gIH1cblxuICAvLyBcIjMuIElmIHRoZSB1cmktcGF0aCBjb250YWlucyBubyBtb3JlIHRoYW4gb25lICV4MkYgKFwiL1wiKSBjaGFyYWN0ZXIsIG91dHB1dFxuICAvLyAleDJGIChcIi9cIikgYW5kIHNraXAgdGhlIHJlbWFpbmluZyBzdGVwLlwiXG4gIGlmIChwYXRoID09PSBcIi9cIikge1xuICAgIHJldHVybiBwYXRoO1xuICB9XG5cbiAgdmFyIHJpZ2h0U2xhc2ggPSBwYXRoLmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgaWYgKHJpZ2h0U2xhc2ggPT09IDApIHtcbiAgICByZXR1cm4gXCIvXCI7XG4gIH1cblxuICAvLyBcIjQuIE91dHB1dCB0aGUgY2hhcmFjdGVycyBvZiB0aGUgdXJpLXBhdGggZnJvbSB0aGUgZmlyc3QgY2hhcmFjdGVyIHVwIHRvLFxuICAvLyBidXQgbm90IGluY2x1ZGluZywgdGhlIHJpZ2h0LW1vc3QgJXgyRiAoXCIvXCIpLlwiXG4gIHJldHVybiBwYXRoLnNsaWNlKDAsIHJpZ2h0U2xhc2gpO1xufVxuXG5mdW5jdGlvbiB0cmltVGVybWluYXRvcihzdHIpIHtcbiAgZm9yICh2YXIgdCA9IDA7IHQgPCBURVJNSU5BVE9SUy5sZW5ndGg7IHQrKykge1xuICAgIHZhciB0ZXJtaW5hdG9ySWR4ID0gc3RyLmluZGV4T2YoVEVSTUlOQVRPUlNbdF0pO1xuICAgIGlmICh0ZXJtaW5hdG9ySWR4ICE9PSAtMSkge1xuICAgICAgc3RyID0gc3RyLnN1YnN0cigwLHRlcm1pbmF0b3JJZHgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ29va2llUGFpcihjb29raWVQYWlyLCBsb29zZU1vZGUpIHtcbiAgY29va2llUGFpciA9IHRyaW1UZXJtaW5hdG9yKGNvb2tpZVBhaXIpO1xuXG4gIHZhciBmaXJzdEVxID0gY29va2llUGFpci5pbmRleE9mKCc9Jyk7XG4gIGlmIChsb29zZU1vZGUpIHtcbiAgICBpZiAoZmlyc3RFcSA9PT0gMCkgeyAvLyAnPScgaXMgaW1tZWRpYXRlbHkgYXQgc3RhcnRcbiAgICAgIGNvb2tpZVBhaXIgPSBjb29raWVQYWlyLnN1YnN0cigxKTtcbiAgICAgIGZpcnN0RXEgPSBjb29raWVQYWlyLmluZGV4T2YoJz0nKTsgLy8gbWlnaHQgc3RpbGwgbmVlZCB0byBzcGxpdCBvbiAnPSdcbiAgICB9XG4gIH0gZWxzZSB7IC8vIG5vbi1sb29zZSBtb2RlXG4gICAgaWYgKGZpcnN0RXEgPD0gMCkgeyAvLyBubyAnPScgb3IgaXMgYXQgc3RhcnRcbiAgICAgIHJldHVybjsgLy8gbmVlZHMgdG8gaGF2ZSBub24tZW1wdHkgXCJjb29raWUtbmFtZVwiXG4gICAgfVxuICB9XG5cbiAgdmFyIGNvb2tpZU5hbWUsIGNvb2tpZVZhbHVlO1xuICBpZiAoZmlyc3RFcSA8PSAwKSB7XG4gICAgY29va2llTmFtZSA9IFwiXCI7XG4gICAgY29va2llVmFsdWUgPSBjb29raWVQYWlyLnRyaW0oKTtcbiAgfSBlbHNlIHtcbiAgICBjb29raWVOYW1lID0gY29va2llUGFpci5zdWJzdHIoMCwgZmlyc3RFcSkudHJpbSgpO1xuICAgIGNvb2tpZVZhbHVlID0gY29va2llUGFpci5zdWJzdHIoZmlyc3RFcSsxKS50cmltKCk7XG4gIH1cblxuICBpZiAoQ09OVFJPTF9DSEFSUy50ZXN0KGNvb2tpZU5hbWUpIHx8IENPTlRST0xfQ0hBUlMudGVzdChjb29raWVWYWx1ZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYyA9IG5ldyBDb29raWUoKTtcbiAgYy5rZXkgPSBjb29raWVOYW1lO1xuICBjLnZhbHVlID0gY29va2llVmFsdWU7XG4gIHJldHVybiBjO1xufVxuXG5mdW5jdGlvbiBwYXJzZShzdHIsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBzdHIgPSBzdHIudHJpbSgpO1xuXG4gIC8vIFdlIHVzZSBhIHJlZ2V4IHRvIHBhcnNlIHRoZSBcIm5hbWUtdmFsdWUtcGFpclwiIHBhcnQgb2YgUzUuMlxuICB2YXIgZmlyc3RTZW1pID0gc3RyLmluZGV4T2YoJzsnKTsgLy8gUzUuMiBzdGVwIDFcbiAgdmFyIGNvb2tpZVBhaXIgPSAoZmlyc3RTZW1pID09PSAtMSkgPyBzdHIgOiBzdHIuc3Vic3RyKDAsIGZpcnN0U2VtaSk7XG4gIHZhciBjID0gcGFyc2VDb29raWVQYWlyKGNvb2tpZVBhaXIsICEhb3B0aW9ucy5sb29zZSk7XG4gIGlmICghYykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChmaXJzdFNlbWkgPT09IC0xKSB7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICAvLyBTNS4yLjMgXCJ1bnBhcnNlZC1hdHRyaWJ1dGVzIGNvbnNpc3Qgb2YgdGhlIHJlbWFpbmRlciBvZiB0aGUgc2V0LWNvb2tpZS1zdHJpbmdcbiAgLy8gKGluY2x1ZGluZyB0aGUgJXgzQiAoXCI7XCIpIGluIHF1ZXN0aW9uKS5cIiBwbHVzIGxhdGVyIG9uIGluIHRoZSBzYW1lIHNlY3Rpb25cbiAgLy8gXCJkaXNjYXJkIHRoZSBmaXJzdCBcIjtcIiBhbmQgdHJpbVwiLlxuICB2YXIgdW5wYXJzZWQgPSBzdHIuc2xpY2UoZmlyc3RTZW1pICsgMSkudHJpbSgpO1xuXG4gIC8vIFwiSWYgdGhlIHVucGFyc2VkLWF0dHJpYnV0ZXMgc3RyaW5nIGlzIGVtcHR5LCBza2lwIHRoZSByZXN0IG9mIHRoZXNlXG4gIC8vIHN0ZXBzLlwiXG4gIGlmICh1bnBhcnNlZC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIC8qXG4gICAqIFM1LjIgc2F5cyB0aGF0IHdoZW4gbG9vcGluZyBvdmVyIHRoZSBpdGVtcyBcIltwXXJvY2VzcyB0aGUgYXR0cmlidXRlLW5hbWVcbiAgICogYW5kIGF0dHJpYnV0ZS12YWx1ZSBhY2NvcmRpbmcgdG8gdGhlIHJlcXVpcmVtZW50cyBpbiB0aGUgZm9sbG93aW5nXG4gICAqIHN1YnNlY3Rpb25zXCIgZm9yIGV2ZXJ5IGl0ZW0uICBQbHVzLCBmb3IgbWFueSBvZiB0aGUgaW5kaXZpZHVhbCBhdHRyaWJ1dGVzXG4gICAqIGluIFM1LjMgaXQgc2F5cyB0byB1c2UgdGhlIFwiYXR0cmlidXRlLXZhbHVlIG9mIHRoZSBsYXN0IGF0dHJpYnV0ZSBpbiB0aGVcbiAgICogY29va2llLWF0dHJpYnV0ZS1saXN0XCIuICBUaGVyZWZvcmUsIGluIHRoaXMgaW1wbGVtZW50YXRpb24sIHdlIG92ZXJ3cml0ZVxuICAgKiB0aGUgcHJldmlvdXMgdmFsdWUuXG4gICAqL1xuICB2YXIgY29va2llX2F2cyA9IHVucGFyc2VkLnNwbGl0KCc7Jyk7XG4gIHdoaWxlIChjb29raWVfYXZzLmxlbmd0aCkge1xuICAgIHZhciBhdiA9IGNvb2tpZV9hdnMuc2hpZnQoKS50cmltKCk7XG4gICAgaWYgKGF2Lmxlbmd0aCA9PT0gMCkgeyAvLyBoYXBwZW5zIGlmIFwiOztcIiBhcHBlYXJzXG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGF2X3NlcCA9IGF2LmluZGV4T2YoJz0nKTtcbiAgICB2YXIgYXZfa2V5LCBhdl92YWx1ZTtcblxuICAgIGlmIChhdl9zZXAgPT09IC0xKSB7XG4gICAgICBhdl9rZXkgPSBhdjtcbiAgICAgIGF2X3ZhbHVlID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgYXZfa2V5ID0gYXYuc3Vic3RyKDAsYXZfc2VwKTtcbiAgICAgIGF2X3ZhbHVlID0gYXYuc3Vic3RyKGF2X3NlcCsxKTtcbiAgICB9XG5cbiAgICBhdl9rZXkgPSBhdl9rZXkudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAoYXZfdmFsdWUpIHtcbiAgICAgIGF2X3ZhbHVlID0gYXZfdmFsdWUudHJpbSgpO1xuICAgIH1cblxuICAgIHN3aXRjaChhdl9rZXkpIHtcbiAgICBjYXNlICdleHBpcmVzJzogLy8gUzUuMi4xXG4gICAgICBpZiAoYXZfdmFsdWUpIHtcbiAgICAgICAgdmFyIGV4cCA9IHBhcnNlRGF0ZShhdl92YWx1ZSk7XG4gICAgICAgIC8vIFwiSWYgdGhlIGF0dHJpYnV0ZS12YWx1ZSBmYWlsZWQgdG8gcGFyc2UgYXMgYSBjb29raWUgZGF0ZSwgaWdub3JlIHRoZVxuICAgICAgICAvLyBjb29raWUtYXYuXCJcbiAgICAgICAgaWYgKGV4cCkge1xuICAgICAgICAgIC8vIG92ZXIgYW5kIHVuZGVyZmxvdyBub3QgcmVhbGlzdGljYWxseSBhIGNvbmNlcm46IFY4J3MgZ2V0VGltZSgpIHNlZW1zIHRvXG4gICAgICAgICAgLy8gc3RvcmUgc29tZXRoaW5nIGxhcmdlciB0aGFuIGEgMzItYml0IHRpbWVfdCAoZXZlbiB3aXRoIDMyLWJpdCBub2RlKVxuICAgICAgICAgIGMuZXhwaXJlcyA9IGV4cDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdtYXgtYWdlJzogLy8gUzUuMi4yXG4gICAgICBpZiAoYXZfdmFsdWUpIHtcbiAgICAgICAgLy8gXCJJZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBhdHRyaWJ1dGUtdmFsdWUgaXMgbm90IGEgRElHSVQgb3IgYSBcIi1cIlxuICAgICAgICAvLyBjaGFyYWN0ZXIgLi4uW29yXS4uLiBJZiB0aGUgcmVtYWluZGVyIG9mIGF0dHJpYnV0ZS12YWx1ZSBjb250YWlucyBhXG4gICAgICAgIC8vIG5vbi1ESUdJVCBjaGFyYWN0ZXIsIGlnbm9yZSB0aGUgY29va2llLWF2LlwiXG4gICAgICAgIGlmICgvXi0/WzAtOV0rJC8udGVzdChhdl92YWx1ZSkpIHtcbiAgICAgICAgICB2YXIgZGVsdGEgPSBwYXJzZUludChhdl92YWx1ZSwgMTApO1xuICAgICAgICAgIC8vIFwiSWYgZGVsdGEtc2Vjb25kcyBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gemVybyAoMCksIGxldCBleHBpcnktdGltZVxuICAgICAgICAgIC8vIGJlIHRoZSBlYXJsaWVzdCByZXByZXNlbnRhYmxlIGRhdGUgYW5kIHRpbWUuXCJcbiAgICAgICAgICBjLnNldE1heEFnZShkZWx0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnZG9tYWluJzogLy8gUzUuMi4zXG4gICAgICAvLyBcIklmIHRoZSBhdHRyaWJ1dGUtdmFsdWUgaXMgZW1wdHksIHRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWQuICBIb3dldmVyLFxuICAgICAgLy8gdGhlIHVzZXIgYWdlbnQgU0hPVUxEIGlnbm9yZSB0aGUgY29va2llLWF2IGVudGlyZWx5LlwiXG4gICAgICBpZiAoYXZfdmFsdWUpIHtcbiAgICAgICAgLy8gUzUuMi4zIFwiTGV0IGNvb2tpZS1kb21haW4gYmUgdGhlIGF0dHJpYnV0ZS12YWx1ZSB3aXRob3V0IHRoZSBsZWFkaW5nICV4MkVcbiAgICAgICAgLy8gKFwiLlwiKSBjaGFyYWN0ZXIuXCJcbiAgICAgICAgdmFyIGRvbWFpbiA9IGF2X3ZhbHVlLnRyaW0oKS5yZXBsYWNlKC9eXFwuLywgJycpO1xuICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgLy8gXCJDb252ZXJ0IHRoZSBjb29raWUtZG9tYWluIHRvIGxvd2VyIGNhc2UuXCJcbiAgICAgICAgICBjLmRvbWFpbiA9IGRvbWFpbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BhdGgnOiAvLyBTNS4yLjRcbiAgICAgIC8qXG4gICAgICAgKiBcIklmIHRoZSBhdHRyaWJ1dGUtdmFsdWUgaXMgZW1wdHkgb3IgaWYgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGVcbiAgICAgICAqIGF0dHJpYnV0ZS12YWx1ZSBpcyBub3QgJXgyRiAoXCIvXCIpOlxuICAgICAgICogICBMZXQgY29va2llLXBhdGggYmUgdGhlIGRlZmF1bHQtcGF0aC5cbiAgICAgICAqIE90aGVyd2lzZTpcbiAgICAgICAqICAgTGV0IGNvb2tpZS1wYXRoIGJlIHRoZSBhdHRyaWJ1dGUtdmFsdWUuXCJcbiAgICAgICAqXG4gICAgICAgKiBXZSdsbCByZXByZXNlbnQgdGhlIGRlZmF1bHQtcGF0aCBhcyBudWxsIHNpbmNlIGl0IGRlcGVuZHMgb24gdGhlXG4gICAgICAgKiBjb250ZXh0IG9mIHRoZSBwYXJzaW5nLlxuICAgICAgICovXG4gICAgICBjLnBhdGggPSBhdl92YWx1ZSAmJiBhdl92YWx1ZVswXSA9PT0gXCIvXCIgPyBhdl92YWx1ZSA6IG51bGw7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NlY3VyZSc6IC8vIFM1LjIuNVxuICAgICAgLypcbiAgICAgICAqIFwiSWYgdGhlIGF0dHJpYnV0ZS1uYW1lIGNhc2UtaW5zZW5zaXRpdmVseSBtYXRjaGVzIHRoZSBzdHJpbmcgXCJTZWN1cmVcIixcbiAgICAgICAqIHRoZSB1c2VyIGFnZW50IE1VU1QgYXBwZW5kIGFuIGF0dHJpYnV0ZSB0byB0aGUgY29va2llLWF0dHJpYnV0ZS1saXN0XG4gICAgICAgKiB3aXRoIGFuIGF0dHJpYnV0ZS1uYW1lIG9mIFNlY3VyZSBhbmQgYW4gZW1wdHkgYXR0cmlidXRlLXZhbHVlLlwiXG4gICAgICAgKi9cbiAgICAgIGMuc2VjdXJlID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaHR0cG9ubHknOiAvLyBTNS4yLjYgLS0gZWZmZWN0aXZlbHkgdGhlIHNhbWUgYXMgJ3NlY3VyZSdcbiAgICAgIGMuaHR0cE9ubHkgPSB0cnVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgYy5leHRlbnNpb25zID0gYy5leHRlbnNpb25zIHx8IFtdO1xuICAgICAgYy5leHRlbnNpb25zLnB1c2goYXYpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGM7XG59XG5cbi8vIGF2b2lkIHRoZSBWOCBkZW9wdGltaXphdGlvbiBtb25zdGVyIVxuZnVuY3Rpb24ganNvblBhcnNlKHN0cikge1xuICB2YXIgb2JqO1xuICB0cnkge1xuICAgIG9iaiA9IEpTT04ucGFyc2Uoc3RyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGZyb21KU09OKHN0cikge1xuICBpZiAoIXN0cikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG9iajtcbiAgaWYgKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnKSB7XG4gICAgb2JqID0ganNvblBhcnNlKHN0cik7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gYXNzdW1lIGl0J3MgYW4gT2JqZWN0XG4gICAgb2JqID0gc3RyO1xuICB9XG5cbiAgdmFyIGMgPSBuZXcgQ29va2llKCk7XG4gIGZvciAodmFyIGk9MDsgaTxDb29raWUuc2VyaWFsaXphYmxlUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gQ29va2llLnNlcmlhbGl6YWJsZVByb3BlcnRpZXNbaV07XG4gICAgaWYgKG9ialtwcm9wXSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIG9ialtwcm9wXSA9PT0gQ29va2llLnByb3RvdHlwZVtwcm9wXSlcbiAgICB7XG4gICAgICBjb250aW51ZTsgLy8gbGVhdmUgYXMgcHJvdG90eXBlIGRlZmF1bHRcbiAgICB9XG5cbiAgICBpZiAocHJvcCA9PT0gJ2V4cGlyZXMnIHx8XG4gICAgICAgIHByb3AgPT09ICdjcmVhdGlvbicgfHxcbiAgICAgICAgcHJvcCA9PT0gJ2xhc3RBY2Nlc3NlZCcpXG4gICAge1xuICAgICAgaWYgKG9ialtwcm9wXSA9PT0gbnVsbCkge1xuICAgICAgICBjW3Byb3BdID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNbcHJvcF0gPSBvYmpbcHJvcF0gPT0gXCJJbmZpbml0eVwiID9cbiAgICAgICAgICBcIkluZmluaXR5XCIgOiBuZXcgRGF0ZShvYmpbcHJvcF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjW3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjO1xufVxuXG4vKiBTZWN0aW9uIDUuNCBwYXJ0IDI6XG4gKiBcIiogIENvb2tpZXMgd2l0aCBsb25nZXIgcGF0aHMgYXJlIGxpc3RlZCBiZWZvcmUgY29va2llcyB3aXRoXG4gKiAgICAgc2hvcnRlciBwYXRocy5cbiAqXG4gKiAgKiAgQW1vbmcgY29va2llcyB0aGF0IGhhdmUgZXF1YWwtbGVuZ3RoIHBhdGggZmllbGRzLCBjb29raWVzIHdpdGhcbiAqICAgICBlYXJsaWVyIGNyZWF0aW9uLXRpbWVzIGFyZSBsaXN0ZWQgYmVmb3JlIGNvb2tpZXMgd2l0aCBsYXRlclxuICogICAgIGNyZWF0aW9uLXRpbWVzLlwiXG4gKi9cblxuZnVuY3Rpb24gY29va2llQ29tcGFyZShhLGIpIHtcbiAgdmFyIGNtcCA9IDA7XG5cbiAgLy8gZGVzY2VuZGluZyBmb3IgbGVuZ3RoOiBiIENNUCBhXG4gIHZhciBhUGF0aExlbiA9IGEucGF0aCA/IGEucGF0aC5sZW5ndGggOiAwO1xuICB2YXIgYlBhdGhMZW4gPSBiLnBhdGggPyBiLnBhdGgubGVuZ3RoIDogMDtcbiAgY21wID0gYlBhdGhMZW4gLSBhUGF0aExlbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICAvLyBhc2NlbmRpbmcgZm9yIHRpbWU6IGEgQ01QIGJcbiAgdmFyIGFUaW1lID0gYS5jcmVhdGlvbiA/IGEuY3JlYXRpb24uZ2V0VGltZSgpIDogTUFYX1RJTUU7XG4gIHZhciBiVGltZSA9IGIuY3JlYXRpb24gPyBiLmNyZWF0aW9uLmdldFRpbWUoKSA6IE1BWF9USU1FO1xuICBjbXAgPSBhVGltZSAtIGJUaW1lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIC8vIGJyZWFrIHRpZXMgZm9yIHRoZSBzYW1lIG1pbGxpc2Vjb25kIChwcmVjaXNpb24gb2YgSmF2YVNjcmlwdCdzIGNsb2NrKVxuICBjbXAgPSBhLmNyZWF0aW9uSW5kZXggLSBiLmNyZWF0aW9uSW5kZXg7XG5cbiAgcmV0dXJuIGNtcDtcbn1cblxuLy8gR2l2ZXMgdGhlIHBlcm11dGF0aW9uIG9mIGFsbCBwb3NzaWJsZSBwYXRoTWF0Y2goKWVzIG9mIGEgZ2l2ZW4gcGF0aC4gVGhlXG4vLyBhcnJheSBpcyBpbiBsb25nZXN0LXRvLXNob3J0ZXN0IG9yZGVyLiAgSGFuZHkgZm9yIGluZGV4aW5nLlxuZnVuY3Rpb24gcGVybXV0ZVBhdGgocGF0aCkge1xuICBpZiAocGF0aCA9PT0gJy8nKSB7XG4gICAgcmV0dXJuIFsnLyddO1xuICB9XG4gIGlmIChwYXRoLmxhc3RJbmRleE9mKCcvJykgPT09IHBhdGgubGVuZ3RoLTEpIHtcbiAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCxwYXRoLmxlbmd0aC0xKTtcbiAgfVxuICB2YXIgcGVybXV0YXRpb25zID0gW3BhdGhdO1xuICB3aGlsZSAocGF0aC5sZW5ndGggPiAxKSB7XG4gICAgdmFyIGxpbmRleCA9IHBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICBpZiAobGluZGV4ID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsbGluZGV4KTtcbiAgICBwZXJtdXRhdGlvbnMucHVzaChwYXRoKTtcbiAgfVxuICBwZXJtdXRhdGlvbnMucHVzaCgnLycpO1xuICByZXR1cm4gcGVybXV0YXRpb25zO1xufVxuXG5mdW5jdGlvbiBnZXRDb29raWVDb250ZXh0KHVybCkge1xuICBpZiAodXJsIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICAvLyBOT1RFOiBkZWNvZGVVUkkgd2lsbCB0aHJvdyBvbiBtYWxmb3JtZWQgVVJJcyAoc2VlIEdILTMyKS5cbiAgLy8gVGhlcmVmb3JlLCB3ZSB3aWxsIGp1c3Qgc2tpcCBkZWNvZGluZyBmb3Igc3VjaCBVUklzLlxuICB0cnkge1xuICAgIHVybCA9IGRlY29kZVVSSSh1cmwpO1xuICB9XG4gIGNhdGNoKGVycikge1xuICAgIC8vIFNpbGVudGx5IHN3YWxsb3cgZXJyb3JcbiAgfVxuXG4gIHJldHVybiB1cmxQYXJzZSh1cmwpO1xufVxuXG5mdW5jdGlvbiBDb29raWUob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICBpZiAoQ29va2llLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJlxuICAgICAgICBDb29raWUucHJvdG90eXBlW3Byb3BdICE9PSBvcHRpb25zW3Byb3BdICYmXG4gICAgICAgIHByb3Auc3Vic3RyKDAsMSkgIT09ICdfJylcbiAgICB7XG4gICAgICB0aGlzW3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICB9XG4gIH0sIHRoaXMpO1xuXG4gIHRoaXMuY3JlYXRpb24gPSB0aGlzLmNyZWF0aW9uIHx8IG5ldyBEYXRlKCk7XG5cbiAgLy8gdXNlZCB0byBicmVhayBjcmVhdGlvbiB0aWVzIGluIGNvb2tpZUNvbXBhcmUoKTpcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjcmVhdGlvbkluZGV4Jywge1xuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsIC8vIGltcG9ydGFudCBmb3IgYXNzZXJ0LmRlZXBFcXVhbCBjaGVja3NcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogKytDb29raWUuY29va2llc0NyZWF0ZWRcbiAgfSk7XG59XG5cbkNvb2tpZS5jb29raWVzQ3JlYXRlZCA9IDA7IC8vIGluY3JlbWVudGVkIGVhY2ggdGltZSBhIGNvb2tpZSBpcyBjcmVhdGVkXG5cbkNvb2tpZS5wYXJzZSA9IHBhcnNlO1xuQ29va2llLmZyb21KU09OID0gZnJvbUpTT047XG5cbkNvb2tpZS5wcm90b3R5cGUua2V5ID0gXCJcIjtcbkNvb2tpZS5wcm90b3R5cGUudmFsdWUgPSBcIlwiO1xuXG4vLyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhlIFJGQyBoYXMgdGhlbTpcbkNvb2tpZS5wcm90b3R5cGUuZXhwaXJlcyA9IFwiSW5maW5pdHlcIjsgLy8gY29lcmNlcyB0byBsaXRlcmFsIEluZmluaXR5XG5Db29raWUucHJvdG90eXBlLm1heEFnZSA9IG51bGw7IC8vIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBleHBpcmVzIGZvciBUVExcbkNvb2tpZS5wcm90b3R5cGUuZG9tYWluID0gbnVsbDtcbkNvb2tpZS5wcm90b3R5cGUucGF0aCA9IG51bGw7XG5Db29raWUucHJvdG90eXBlLnNlY3VyZSA9IGZhbHNlO1xuQ29va2llLnByb3RvdHlwZS5odHRwT25seSA9IGZhbHNlO1xuQ29va2llLnByb3RvdHlwZS5leHRlbnNpb25zID0gbnVsbDtcblxuLy8gc2V0IGJ5IHRoZSBDb29raWVKYXI6XG5Db29raWUucHJvdG90eXBlLmhvc3RPbmx5ID0gbnVsbDsgLy8gYm9vbGVhbiB3aGVuIHNldFxuQ29va2llLnByb3RvdHlwZS5wYXRoSXNEZWZhdWx0ID0gbnVsbDsgLy8gYm9vbGVhbiB3aGVuIHNldFxuQ29va2llLnByb3RvdHlwZS5jcmVhdGlvbiA9IG51bGw7IC8vIERhdGUgd2hlbiBzZXQ7IGRlZmF1bHRlZCBieSBDb29raWUucGFyc2VcbkNvb2tpZS5wcm90b3R5cGUubGFzdEFjY2Vzc2VkID0gbnVsbDsgLy8gRGF0ZSB3aGVuIHNldFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENvb2tpZS5wcm90b3R5cGUsICdjcmVhdGlvbkluZGV4Jywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgdmFsdWU6IDBcbn0pO1xuXG5Db29raWUuc2VyaWFsaXphYmxlUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKENvb2tpZS5wcm90b3R5cGUpXG4gIC5maWx0ZXIoZnVuY3Rpb24ocHJvcCkge1xuICAgIHJldHVybiAhKFxuICAgICAgQ29va2llLnByb3RvdHlwZVtwcm9wXSBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8XG4gICAgICBwcm9wID09PSAnY3JlYXRpb25JbmRleCcgfHxcbiAgICAgIHByb3Auc3Vic3RyKDAsMSkgPT09ICdfJ1xuICAgICk7XG4gIH0pO1xuXG5Db29raWUucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgcmV0dXJuICdDb29raWU9XCInK3RoaXMudG9TdHJpbmcoKSArXG4gICAgJzsgaG9zdE9ubHk9JysodGhpcy5ob3N0T25seSAhPSBudWxsID8gdGhpcy5ob3N0T25seSA6ICc/JykgK1xuICAgICc7IGFBZ2U9JysodGhpcy5sYXN0QWNjZXNzZWQgPyAobm93LXRoaXMubGFzdEFjY2Vzc2VkLmdldFRpbWUoKSkrJ21zJyA6ICc/JykgK1xuICAgICc7IGNBZ2U9JysodGhpcy5jcmVhdGlvbiA/IChub3ctdGhpcy5jcmVhdGlvbi5nZXRUaW1lKCkpKydtcycgOiAnPycpICtcbiAgICAnXCInO1xufTtcblxuLy8gVXNlIHRoZSBuZXcgY3VzdG9tIGluc3BlY3Rpb24gc3ltYm9sIHRvIGFkZCB0aGUgY3VzdG9tIGluc3BlY3QgZnVuY3Rpb24gaWZcbi8vIGF2YWlsYWJsZS5cbmlmICh1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gIENvb2tpZS5wcm90b3R5cGVbdXRpbC5pbnNwZWN0LmN1c3RvbV0gPSBDb29raWUucHJvdG90eXBlLmluc3BlY3Q7XG59XG5cbkNvb2tpZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvYmogPSB7fTtcblxuICB2YXIgcHJvcHMgPSBDb29raWUuc2VyaWFsaXphYmxlUHJvcGVydGllcztcbiAgZm9yICh2YXIgaT0wOyBpPHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICBpZiAodGhpc1twcm9wXSA9PT0gQ29va2llLnByb3RvdHlwZVtwcm9wXSkge1xuICAgICAgY29udGludWU7IC8vIGxlYXZlIGFzIHByb3RvdHlwZSBkZWZhdWx0XG4gICAgfVxuXG4gICAgaWYgKHByb3AgPT09ICdleHBpcmVzJyB8fFxuICAgICAgICBwcm9wID09PSAnY3JlYXRpb24nIHx8XG4gICAgICAgIHByb3AgPT09ICdsYXN0QWNjZXNzZWQnKVxuICAgIHtcbiAgICAgIGlmICh0aGlzW3Byb3BdID09PSBudWxsKSB7XG4gICAgICAgIG9ialtwcm9wXSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmpbcHJvcF0gPSB0aGlzW3Byb3BdID09IFwiSW5maW5pdHlcIiA/IC8vIGludGVudGlvbmFsbHkgbm90ID09PVxuICAgICAgICAgIFwiSW5maW5pdHlcIiA6IHRoaXNbcHJvcF0udG9JU09TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3AgPT09ICdtYXhBZ2UnKSB7XG4gICAgICBpZiAodGhpc1twcm9wXSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBhZ2FpbiwgaW50ZW50aW9uYWxseSBub3QgPT09XG4gICAgICAgIG9ialtwcm9wXSA9ICh0aGlzW3Byb3BdID09IEluZmluaXR5IHx8IHRoaXNbcHJvcF0gPT0gLUluZmluaXR5KSA/XG4gICAgICAgICAgdGhpc1twcm9wXS50b1N0cmluZygpIDogdGhpc1twcm9wXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXNbcHJvcF0gIT09IENvb2tpZS5wcm90b3R5cGVbcHJvcF0pIHtcbiAgICAgICAgb2JqW3Byb3BdID0gdGhpc1twcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuQ29va2llLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZnJvbUpTT04odGhpcy50b0pTT04oKSk7XG59O1xuXG5Db29raWUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gIGlmICghQ09PS0lFX09DVEVUUy50ZXN0KHRoaXMudmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0aGlzLmV4cGlyZXMgIT0gSW5maW5pdHkgJiYgISh0aGlzLmV4cGlyZXMgaW5zdGFuY2VvZiBEYXRlKSAmJiAhcGFyc2VEYXRlKHRoaXMuZXhwaXJlcykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHRoaXMubWF4QWdlICE9IG51bGwgJiYgdGhpcy5tYXhBZ2UgPD0gMCkge1xuICAgIHJldHVybiBmYWxzZTsgLy8gXCJNYXgtQWdlPVwiIG5vbi16ZXJvLWRpZ2l0ICpESUdJVFxuICB9XG4gIGlmICh0aGlzLnBhdGggIT0gbnVsbCAmJiAhUEFUSF9WQUxVRS50ZXN0KHRoaXMucGF0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgY2RvbWFpbiA9IHRoaXMuY2RvbWFpbigpO1xuICBpZiAoY2RvbWFpbikge1xuICAgIGlmIChjZG9tYWluLm1hdGNoKC9cXC4kLykpIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gUzQuMS4yLjMgc3VnZ2VzdHMgdGhhdCB0aGlzIGlzIGJhZC4gZG9tYWluTWF0Y2goKSB0ZXN0cyBjb25maXJtIHRoaXNcbiAgICB9XG4gICAgdmFyIHN1ZmZpeCA9IHB1YnN1ZmZpeC5nZXRQdWJsaWNTdWZmaXgoY2RvbWFpbik7XG4gICAgaWYgKHN1ZmZpeCA9PSBudWxsKSB7IC8vIGl0J3MgYSBwdWJsaWMgc3VmZml4XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuQ29va2llLnByb3RvdHlwZS5zZXRFeHBpcmVzID0gZnVuY3Rpb24gc2V0RXhwaXJlcyhleHApIHtcbiAgaWYgKGV4cCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICB0aGlzLmV4cGlyZXMgPSBleHA7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5leHBpcmVzID0gcGFyc2VEYXRlKGV4cCkgfHwgXCJJbmZpbml0eVwiO1xuICB9XG59O1xuXG5Db29raWUucHJvdG90eXBlLnNldE1heEFnZSA9IGZ1bmN0aW9uIHNldE1heEFnZShhZ2UpIHtcbiAgaWYgKGFnZSA9PT0gSW5maW5pdHkgfHwgYWdlID09PSAtSW5maW5pdHkpIHtcbiAgICB0aGlzLm1heEFnZSA9IGFnZS50b1N0cmluZygpOyAvLyBzbyBKU09OLnN0cmluZ2lmeSgpIHdvcmtzXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tYXhBZ2UgPSBhZ2U7XG4gIH1cbn07XG5cbi8vIGdpdmVzIENvb2tpZSBoZWFkZXIgZm9ybWF0XG5Db29raWUucHJvdG90eXBlLmNvb2tpZVN0cmluZyA9IGZ1bmN0aW9uIGNvb2tpZVN0cmluZygpIHtcbiAgdmFyIHZhbCA9IHRoaXMudmFsdWU7XG4gIGlmICh2YWwgPT0gbnVsbCkge1xuICAgIHZhbCA9ICcnO1xuICB9XG4gIGlmICh0aGlzLmtleSA9PT0gJycpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHJldHVybiB0aGlzLmtleSsnPScrdmFsO1xufTtcblxuLy8gZ2l2ZXMgU2V0LUNvb2tpZSBoZWFkZXIgZm9ybWF0XG5Db29raWUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHZhciBzdHIgPSB0aGlzLmNvb2tpZVN0cmluZygpO1xuXG4gIGlmICh0aGlzLmV4cGlyZXMgIT0gSW5maW5pdHkpIHtcbiAgICBpZiAodGhpcy5leHBpcmVzIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgc3RyICs9ICc7IEV4cGlyZXM9Jytmb3JtYXREYXRlKHRoaXMuZXhwaXJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnOyBFeHBpcmVzPScrdGhpcy5leHBpcmVzO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLm1heEFnZSAhPSBudWxsICYmIHRoaXMubWF4QWdlICE9IEluZmluaXR5KSB7XG4gICAgc3RyICs9ICc7IE1heC1BZ2U9Jyt0aGlzLm1heEFnZTtcbiAgfVxuXG4gIGlmICh0aGlzLmRvbWFpbiAmJiAhdGhpcy5ob3N0T25seSkge1xuICAgIHN0ciArPSAnOyBEb21haW49Jyt0aGlzLmRvbWFpbjtcbiAgfVxuICBpZiAodGhpcy5wYXRoKSB7XG4gICAgc3RyICs9ICc7IFBhdGg9Jyt0aGlzLnBhdGg7XG4gIH1cblxuICBpZiAodGhpcy5zZWN1cmUpIHtcbiAgICBzdHIgKz0gJzsgU2VjdXJlJztcbiAgfVxuICBpZiAodGhpcy5odHRwT25seSkge1xuICAgIHN0ciArPSAnOyBIdHRwT25seSc7XG4gIH1cbiAgaWYgKHRoaXMuZXh0ZW5zaW9ucykge1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgc3RyICs9ICc7ICcrZXh0O1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8vIFRUTCgpIHBhcnRpYWxseSByZXBsYWNlcyB0aGUgXCJleHBpcnktdGltZVwiIHBhcnRzIG9mIFM1LjMgc3RlcCAzIChzZXRDb29raWUoKVxuLy8gZWxzZXdoZXJlKVxuLy8gUzUuMyBzYXlzIHRvIGdpdmUgdGhlIFwibGF0ZXN0IHJlcHJlc2VudGFibGUgZGF0ZVwiIGZvciB3aGljaCB3ZSB1c2UgSW5maW5pdHlcbi8vIEZvciBcImV4cGlyZWRcIiB3ZSB1c2UgMFxuQ29va2llLnByb3RvdHlwZS5UVEwgPSBmdW5jdGlvbiBUVEwobm93KSB7XG4gIC8qIFJGQzYyNjUgUzQuMS4yLjIgSWYgYSBjb29raWUgaGFzIGJvdGggdGhlIE1heC1BZ2UgYW5kIHRoZSBFeHBpcmVzXG4gICAqIGF0dHJpYnV0ZSwgdGhlIE1heC1BZ2UgYXR0cmlidXRlIGhhcyBwcmVjZWRlbmNlIGFuZCBjb250cm9scyB0aGVcbiAgICogZXhwaXJhdGlvbiBkYXRlIG9mIHRoZSBjb29raWUuXG4gICAqIChDb25jdXJzIHdpdGggUzUuMyBzdGVwIDMpXG4gICAqL1xuICBpZiAodGhpcy5tYXhBZ2UgIT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLm1heEFnZTw9MCA/IDAgOiB0aGlzLm1heEFnZSoxMDAwO1xuICB9XG5cbiAgdmFyIGV4cGlyZXMgPSB0aGlzLmV4cGlyZXM7XG4gIGlmIChleHBpcmVzICE9IEluZmluaXR5KSB7XG4gICAgaWYgKCEoZXhwaXJlcyBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICBleHBpcmVzID0gcGFyc2VEYXRlKGV4cGlyZXMpIHx8IEluZmluaXR5O1xuICAgIH1cblxuICAgIGlmIChleHBpcmVzID09IEluZmluaXR5KSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cGlyZXMuZ2V0VGltZSgpIC0gKG5vdyB8fCBEYXRlLm5vdygpKTtcbiAgfVxuXG4gIHJldHVybiBJbmZpbml0eTtcbn07XG5cbi8vIGV4cGlyeVRpbWUoKSByZXBsYWNlcyB0aGUgXCJleHBpcnktdGltZVwiIHBhcnRzIG9mIFM1LjMgc3RlcCAzIChzZXRDb29raWUoKVxuLy8gZWxzZXdoZXJlKVxuQ29va2llLnByb3RvdHlwZS5leHBpcnlUaW1lID0gZnVuY3Rpb24gZXhwaXJ5VGltZShub3cpIHtcbiAgaWYgKHRoaXMubWF4QWdlICE9IG51bGwpIHtcbiAgICB2YXIgcmVsYXRpdmVUbyA9IG5vdyB8fCB0aGlzLmNyZWF0aW9uIHx8IG5ldyBEYXRlKCk7XG4gICAgdmFyIGFnZSA9ICh0aGlzLm1heEFnZSA8PSAwKSA/IC1JbmZpbml0eSA6IHRoaXMubWF4QWdlKjEwMDA7XG4gICAgcmV0dXJuIHJlbGF0aXZlVG8uZ2V0VGltZSgpICsgYWdlO1xuICB9XG5cbiAgaWYgKHRoaXMuZXhwaXJlcyA9PSBJbmZpbml0eSkge1xuICAgIHJldHVybiBJbmZpbml0eTtcbiAgfVxuICByZXR1cm4gdGhpcy5leHBpcmVzLmdldFRpbWUoKTtcbn07XG5cbi8vIGV4cGlyeURhdGUoKSByZXBsYWNlcyB0aGUgXCJleHBpcnktdGltZVwiIHBhcnRzIG9mIFM1LjMgc3RlcCAzIChzZXRDb29raWUoKVxuLy8gZWxzZXdoZXJlKSwgZXhjZXB0IGl0IHJldHVybnMgYSBEYXRlXG5Db29raWUucHJvdG90eXBlLmV4cGlyeURhdGUgPSBmdW5jdGlvbiBleHBpcnlEYXRlKG5vdykge1xuICB2YXIgbWlsbGlzZWMgPSB0aGlzLmV4cGlyeVRpbWUobm93KTtcbiAgaWYgKG1pbGxpc2VjID09IEluZmluaXR5KSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE1BWF9USU1FKTtcbiAgfSBlbHNlIGlmIChtaWxsaXNlYyA9PSAtSW5maW5pdHkpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoTUlOX1RJTUUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgRGF0ZShtaWxsaXNlYyk7XG4gIH1cbn07XG5cbi8vIFRoaXMgcmVwbGFjZXMgdGhlIFwicGVyc2lzdGVudC1mbGFnXCIgcGFydHMgb2YgUzUuMyBzdGVwIDNcbkNvb2tpZS5wcm90b3R5cGUuaXNQZXJzaXN0ZW50ID0gZnVuY3Rpb24gaXNQZXJzaXN0ZW50KCkge1xuICByZXR1cm4gKHRoaXMubWF4QWdlICE9IG51bGwgfHwgdGhpcy5leHBpcmVzICE9IEluZmluaXR5KTtcbn07XG5cbi8vIE1vc3RseSBTNS4xLjIgYW5kIFM1LjIuMzpcbkNvb2tpZS5wcm90b3R5cGUuY2RvbWFpbiA9XG5Db29raWUucHJvdG90eXBlLmNhbm9uaWNhbGl6ZWREb21haW4gPSBmdW5jdGlvbiBjYW5vbmljYWxpemVkRG9tYWluKCkge1xuICBpZiAodGhpcy5kb21haW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjYW5vbmljYWxEb21haW4odGhpcy5kb21haW4pO1xufTtcblxuZnVuY3Rpb24gQ29va2llSmFyKHN0b3JlLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICBvcHRpb25zID0ge3JlamVjdFB1YmxpY1N1ZmZpeGVzOiBvcHRpb25zfTtcbiAgfSBlbHNlIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgaWYgKG9wdGlvbnMucmVqZWN0UHVibGljU3VmZml4ZXMgIT0gbnVsbCkge1xuICAgIHRoaXMucmVqZWN0UHVibGljU3VmZml4ZXMgPSBvcHRpb25zLnJlamVjdFB1YmxpY1N1ZmZpeGVzO1xuICB9XG4gIGlmIChvcHRpb25zLmxvb3NlTW9kZSAhPSBudWxsKSB7XG4gICAgdGhpcy5lbmFibGVMb29zZU1vZGUgPSBvcHRpb25zLmxvb3NlTW9kZTtcbiAgfVxuXG4gIGlmICghc3RvcmUpIHtcbiAgICBzdG9yZSA9IG5ldyBNZW1vcnlDb29raWVTdG9yZSgpO1xuICB9XG4gIHRoaXMuc3RvcmUgPSBzdG9yZTtcbn1cbkNvb2tpZUphci5wcm90b3R5cGUuc3RvcmUgPSBudWxsO1xuQ29va2llSmFyLnByb3RvdHlwZS5yZWplY3RQdWJsaWNTdWZmaXhlcyA9IHRydWU7XG5Db29raWVKYXIucHJvdG90eXBlLmVuYWJsZUxvb3NlTW9kZSA9IGZhbHNlO1xudmFyIENBTl9CRV9TWU5DID0gW107XG5cbkNBTl9CRV9TWU5DLnB1c2goJ3NldENvb2tpZScpO1xuQ29va2llSmFyLnByb3RvdHlwZS5zZXRDb29raWUgPSBmdW5jdGlvbihjb29raWUsIHVybCwgb3B0aW9ucywgY2IpIHtcbiAgdmFyIGVycjtcbiAgdmFyIGNvbnRleHQgPSBnZXRDb29raWVDb250ZXh0KHVybCk7XG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICBjYiA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIGhvc3QgPSBjYW5vbmljYWxEb21haW4oY29udGV4dC5ob3N0bmFtZSk7XG4gIHZhciBsb29zZSA9IHRoaXMuZW5hYmxlTG9vc2VNb2RlO1xuICBpZiAob3B0aW9ucy5sb29zZSAhPSBudWxsKSB7XG4gICAgbG9vc2UgPSBvcHRpb25zLmxvb3NlO1xuICB9XG5cbiAgLy8gUzUuMyBzdGVwIDFcbiAgaWYgKCEoY29va2llIGluc3RhbmNlb2YgQ29va2llKSkge1xuICAgIGNvb2tpZSA9IENvb2tpZS5wYXJzZShjb29raWUsIHsgbG9vc2U6IGxvb3NlIH0pO1xuICB9XG4gIGlmICghY29va2llKSB7XG4gICAgZXJyID0gbmV3IEVycm9yKFwiQ29va2llIGZhaWxlZCB0byBwYXJzZVwiKTtcbiAgICByZXR1cm4gY2Iob3B0aW9ucy5pZ25vcmVFcnJvciA/IG51bGwgOiBlcnIpO1xuICB9XG5cbiAgLy8gUzUuMyBzdGVwIDJcbiAgdmFyIG5vdyA9IG9wdGlvbnMubm93IHx8IG5ldyBEYXRlKCk7IC8vIHdpbGwgYXNzaWduIGxhdGVyIHRvIHNhdmUgZWZmb3J0IGluIHRoZSBmYWNlIG9mIGVycm9yc1xuXG4gIC8vIFM1LjMgc3RlcCAzOiBOT09QOyBwZXJzaXN0ZW50LWZsYWcgYW5kIGV4cGlyeS10aW1lIGlzIGhhbmRsZWQgYnkgZ2V0Q29va2llKClcblxuICAvLyBTNS4zIHN0ZXAgNDogTk9PUDsgZG9tYWluIGlzIG51bGwgYnkgZGVmYXVsdFxuXG4gIC8vIFM1LjMgc3RlcCA1OiBwdWJsaWMgc3VmZml4ZXNcbiAgaWYgKHRoaXMucmVqZWN0UHVibGljU3VmZml4ZXMgJiYgY29va2llLmRvbWFpbikge1xuICAgIHZhciBzdWZmaXggPSBwdWJzdWZmaXguZ2V0UHVibGljU3VmZml4KGNvb2tpZS5jZG9tYWluKCkpO1xuICAgIGlmIChzdWZmaXggPT0gbnVsbCkgeyAvLyBlLmcuIFwiY29tXCJcbiAgICAgIGVyciA9IG5ldyBFcnJvcihcIkNvb2tpZSBoYXMgZG9tYWluIHNldCB0byBhIHB1YmxpYyBzdWZmaXhcIik7XG4gICAgICByZXR1cm4gY2Iob3B0aW9ucy5pZ25vcmVFcnJvciA/IG51bGwgOiBlcnIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFM1LjMgc3RlcCA2OlxuICBpZiAoY29va2llLmRvbWFpbikge1xuICAgIGlmICghZG9tYWluTWF0Y2goaG9zdCwgY29va2llLmNkb21haW4oKSwgZmFsc2UpKSB7XG4gICAgICBlcnIgPSBuZXcgRXJyb3IoXCJDb29raWUgbm90IGluIHRoaXMgaG9zdCdzIGRvbWFpbi4gQ29va2llOlwiK2Nvb2tpZS5jZG9tYWluKCkrXCIgUmVxdWVzdDpcIitob3N0KTtcbiAgICAgIHJldHVybiBjYihvcHRpb25zLmlnbm9yZUVycm9yID8gbnVsbCA6IGVycik7XG4gICAgfVxuXG4gICAgaWYgKGNvb2tpZS5ob3N0T25seSA9PSBudWxsKSB7IC8vIGRvbid0IHJlc2V0IGlmIGFscmVhZHkgc2V0XG4gICAgICBjb29raWUuaG9zdE9ubHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgfSBlbHNlIHtcbiAgICBjb29raWUuaG9zdE9ubHkgPSB0cnVlO1xuICAgIGNvb2tpZS5kb21haW4gPSBob3N0O1xuICB9XG5cbiAgLy9TNS4yLjQgSWYgdGhlIGF0dHJpYnV0ZS12YWx1ZSBpcyBlbXB0eSBvciBpZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZVxuICAvL2F0dHJpYnV0ZS12YWx1ZSBpcyBub3QgJXgyRiAoXCIvXCIpOlxuICAvL0xldCBjb29raWUtcGF0aCBiZSB0aGUgZGVmYXVsdC1wYXRoLlxuICBpZiAoIWNvb2tpZS5wYXRoIHx8IGNvb2tpZS5wYXRoWzBdICE9PSAnLycpIHtcbiAgICBjb29raWUucGF0aCA9IGRlZmF1bHRQYXRoKGNvbnRleHQucGF0aG5hbWUpO1xuICAgIGNvb2tpZS5wYXRoSXNEZWZhdWx0ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIFM1LjMgc3RlcCA4OiBOT09QOyBzZWN1cmUgYXR0cmlidXRlXG4gIC8vIFM1LjMgc3RlcCA5OiBOT09QOyBodHRwT25seSBhdHRyaWJ1dGVcblxuICAvLyBTNS4zIHN0ZXAgMTBcbiAgaWYgKG9wdGlvbnMuaHR0cCA9PT0gZmFsc2UgJiYgY29va2llLmh0dHBPbmx5KSB7XG4gICAgZXJyID0gbmV3IEVycm9yKFwiQ29va2llIGlzIEh0dHBPbmx5IGFuZCB0aGlzIGlzbid0IGFuIEhUVFAgQVBJXCIpO1xuICAgIHJldHVybiBjYihvcHRpb25zLmlnbm9yZUVycm9yID8gbnVsbCA6IGVycik7XG4gIH1cblxuICB2YXIgc3RvcmUgPSB0aGlzLnN0b3JlO1xuXG4gIGlmICghc3RvcmUudXBkYXRlQ29va2llKSB7XG4gICAgc3RvcmUudXBkYXRlQ29va2llID0gZnVuY3Rpb24ob2xkQ29va2llLCBuZXdDb29raWUsIGNiKSB7XG4gICAgICB0aGlzLnB1dENvb2tpZShuZXdDb29raWUsIGNiKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd2l0aENvb2tpZShlcnIsIG9sZENvb2tpZSkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYihlcnIpO1xuICAgIH1cblxuICAgIHZhciBuZXh0ID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IobnVsbCwgY29va2llKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKG9sZENvb2tpZSkge1xuICAgICAgLy8gUzUuMyBzdGVwIDExIC0gXCJJZiB0aGUgY29va2llIHN0b3JlIGNvbnRhaW5zIGEgY29va2llIHdpdGggdGhlIHNhbWUgbmFtZSxcbiAgICAgIC8vIGRvbWFpbiwgYW5kIHBhdGggYXMgdGhlIG5ld2x5IGNyZWF0ZWQgY29va2llOlwiXG4gICAgICBpZiAob3B0aW9ucy5odHRwID09PSBmYWxzZSAmJiBvbGRDb29raWUuaHR0cE9ubHkpIHsgLy8gc3RlcCAxMS4yXG4gICAgICAgIGVyciA9IG5ldyBFcnJvcihcIm9sZCBDb29raWUgaXMgSHR0cE9ubHkgYW5kIHRoaXMgaXNuJ3QgYW4gSFRUUCBBUElcIik7XG4gICAgICAgIHJldHVybiBjYihvcHRpb25zLmlnbm9yZUVycm9yID8gbnVsbCA6IGVycik7XG4gICAgICB9XG4gICAgICBjb29raWUuY3JlYXRpb24gPSBvbGRDb29raWUuY3JlYXRpb247IC8vIHN0ZXAgMTEuM1xuICAgICAgY29va2llLmNyZWF0aW9uSW5kZXggPSBvbGRDb29raWUuY3JlYXRpb25JbmRleDsgLy8gcHJlc2VydmUgdGllLWJyZWFrZXJcbiAgICAgIGNvb2tpZS5sYXN0QWNjZXNzZWQgPSBub3c7XG4gICAgICAvLyBTdGVwIDExLjQgKGRlbGV0ZSBjb29raWUpIGlzIGltcGxpZWQgYnkganVzdCBzZXR0aW5nIHRoZSBuZXcgb25lOlxuICAgICAgc3RvcmUudXBkYXRlQ29va2llKG9sZENvb2tpZSwgY29va2llLCBuZXh0KTsgLy8gc3RlcCAxMlxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvb2tpZS5jcmVhdGlvbiA9IGNvb2tpZS5sYXN0QWNjZXNzZWQgPSBub3c7XG4gICAgICBzdG9yZS5wdXRDb29raWUoY29va2llLCBuZXh0KTsgLy8gc3RlcCAxMlxuICAgIH1cbiAgfVxuXG4gIHN0b3JlLmZpbmRDb29raWUoY29va2llLmRvbWFpbiwgY29va2llLnBhdGgsIGNvb2tpZS5rZXksIHdpdGhDb29raWUpO1xufTtcblxuLy8gUkZDNjM2NSBTNS40XG5DQU5fQkVfU1lOQy5wdXNoKCdnZXRDb29raWVzJyk7XG5Db29raWVKYXIucHJvdG90eXBlLmdldENvb2tpZXMgPSBmdW5jdGlvbih1cmwsIG9wdGlvbnMsIGNiKSB7XG4gIHZhciBjb250ZXh0ID0gZ2V0Q29va2llQ29udGV4dCh1cmwpO1xuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgY2IgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBob3N0ID0gY2Fub25pY2FsRG9tYWluKGNvbnRleHQuaG9zdG5hbWUpO1xuICB2YXIgcGF0aCA9IGNvbnRleHQucGF0aG5hbWUgfHwgJy8nO1xuXG4gIHZhciBzZWN1cmUgPSBvcHRpb25zLnNlY3VyZTtcbiAgaWYgKHNlY3VyZSA9PSBudWxsICYmIGNvbnRleHQucHJvdG9jb2wgJiZcbiAgICAgIChjb250ZXh0LnByb3RvY29sID09ICdodHRwczonIHx8IGNvbnRleHQucHJvdG9jb2wgPT0gJ3dzczonKSlcbiAge1xuICAgIHNlY3VyZSA9IHRydWU7XG4gIH1cblxuICB2YXIgaHR0cCA9IG9wdGlvbnMuaHR0cDtcbiAgaWYgKGh0dHAgPT0gbnVsbCkge1xuICAgIGh0dHAgPSB0cnVlO1xuICB9XG5cbiAgdmFyIG5vdyA9IG9wdGlvbnMubm93IHx8IERhdGUubm93KCk7XG4gIHZhciBleHBpcmVDaGVjayA9IG9wdGlvbnMuZXhwaXJlICE9PSBmYWxzZTtcbiAgdmFyIGFsbFBhdGhzID0gISFvcHRpb25zLmFsbFBhdGhzO1xuICB2YXIgc3RvcmUgPSB0aGlzLnN0b3JlO1xuXG4gIGZ1bmN0aW9uIG1hdGNoaW5nQ29va2llKGMpIHtcbiAgICAvLyBcIkVpdGhlcjpcbiAgICAvLyAgIFRoZSBjb29raWUncyBob3N0LW9ubHktZmxhZyBpcyB0cnVlIGFuZCB0aGUgY2Fub25pY2FsaXplZFxuICAgIC8vICAgcmVxdWVzdC1ob3N0IGlzIGlkZW50aWNhbCB0byB0aGUgY29va2llJ3MgZG9tYWluLlxuICAgIC8vIE9yOlxuICAgIC8vICAgVGhlIGNvb2tpZSdzIGhvc3Qtb25seS1mbGFnIGlzIGZhbHNlIGFuZCB0aGUgY2Fub25pY2FsaXplZFxuICAgIC8vICAgcmVxdWVzdC1ob3N0IGRvbWFpbi1tYXRjaGVzIHRoZSBjb29raWUncyBkb21haW4uXCJcbiAgICBpZiAoYy5ob3N0T25seSkge1xuICAgICAgaWYgKGMuZG9tYWluICE9IGhvc3QpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWRvbWFpbk1hdGNoKGhvc3QsIGMuZG9tYWluLCBmYWxzZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFwiVGhlIHJlcXVlc3QtdXJpJ3MgcGF0aCBwYXRoLW1hdGNoZXMgdGhlIGNvb2tpZSdzIHBhdGguXCJcbiAgICBpZiAoIWFsbFBhdGhzICYmICFwYXRoTWF0Y2gocGF0aCwgYy5wYXRoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFwiSWYgdGhlIGNvb2tpZSdzIHNlY3VyZS1vbmx5LWZsYWcgaXMgdHJ1ZSwgdGhlbiB0aGUgcmVxdWVzdC11cmknc1xuICAgIC8vIHNjaGVtZSBtdXN0IGRlbm90ZSBhIFwic2VjdXJlXCIgcHJvdG9jb2xcIlxuICAgIGlmIChjLnNlY3VyZSAmJiAhc2VjdXJlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gXCJJZiB0aGUgY29va2llJ3MgaHR0cC1vbmx5LWZsYWcgaXMgdHJ1ZSwgdGhlbiBleGNsdWRlIHRoZSBjb29raWUgaWYgdGhlXG4gICAgLy8gY29va2llLXN0cmluZyBpcyBiZWluZyBnZW5lcmF0ZWQgZm9yIGEgXCJub24tSFRUUFwiIEFQSVwiXG4gICAgaWYgKGMuaHR0cE9ubHkgJiYgIWh0dHApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBkZWZlcnJlZCBmcm9tIFM1LjNcbiAgICAvLyBub24tUkZDOiBhbGxvdyByZXRlbnRpb24gb2YgZXhwaXJlZCBjb29raWVzIGJ5IGNob2ljZVxuICAgIGlmIChleHBpcmVDaGVjayAmJiBjLmV4cGlyeVRpbWUoKSA8PSBub3cpIHtcbiAgICAgIHN0b3JlLnJlbW92ZUNvb2tpZShjLmRvbWFpbiwgYy5wYXRoLCBjLmtleSwgZnVuY3Rpb24oKXt9KTsgLy8gcmVzdWx0IGlnbm9yZWRcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0b3JlLmZpbmRDb29raWVzKGhvc3QsIGFsbFBhdGhzID8gbnVsbCA6IHBhdGgsIGZ1bmN0aW9uKGVycixjb29raWVzKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgfVxuXG4gICAgY29va2llcyA9IGNvb2tpZXMuZmlsdGVyKG1hdGNoaW5nQ29va2llKTtcblxuICAgIC8vIHNvcnRpbmcgb2YgUzUuNCBwYXJ0IDJcbiAgICBpZiAob3B0aW9ucy5zb3J0ICE9PSBmYWxzZSkge1xuICAgICAgY29va2llcyA9IGNvb2tpZXMuc29ydChjb29raWVDb21wYXJlKTtcbiAgICB9XG5cbiAgICAvLyBTNS40IHBhcnQgM1xuICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIGNvb2tpZXMuZm9yRWFjaChmdW5jdGlvbihjKSB7XG4gICAgICBjLmxhc3RBY2Nlc3NlZCA9IG5vdztcbiAgICB9KTtcbiAgICAvLyBUT0RPIHBlcnNpc3QgbGFzdEFjY2Vzc2VkXG5cbiAgICBjYihudWxsLGNvb2tpZXMpO1xuICB9KTtcbn07XG5cbkNBTl9CRV9TWU5DLnB1c2goJ2dldENvb2tpZVN0cmluZycpO1xuQ29va2llSmFyLnByb3RvdHlwZS5nZXRDb29raWVTdHJpbmcgPSBmdW5jdGlvbigvKi4uLiwgY2IqLykge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywwKTtcbiAgdmFyIGNiID0gYXJncy5wb3AoKTtcbiAgdmFyIG5leHQgPSBmdW5jdGlvbihlcnIsY29va2llcykge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKG51bGwsIGNvb2tpZXNcbiAgICAgICAgLnNvcnQoY29va2llQ29tcGFyZSlcbiAgICAgICAgLm1hcChmdW5jdGlvbihjKXtcbiAgICAgICAgICByZXR1cm4gYy5jb29raWVTdHJpbmcoKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oJzsgJykpO1xuICAgIH1cbiAgfTtcbiAgYXJncy5wdXNoKG5leHQpO1xuICB0aGlzLmdldENvb2tpZXMuYXBwbHkodGhpcyxhcmdzKTtcbn07XG5cbkNBTl9CRV9TWU5DLnB1c2goJ2dldFNldENvb2tpZVN0cmluZ3MnKTtcbkNvb2tpZUphci5wcm90b3R5cGUuZ2V0U2V0Q29va2llU3RyaW5ncyA9IGZ1bmN0aW9uKC8qLi4uLCBjYiovKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDApO1xuICB2YXIgY2IgPSBhcmdzLnBvcCgpO1xuICB2YXIgbmV4dCA9IGZ1bmN0aW9uKGVycixjb29raWVzKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2IobnVsbCwgY29va2llcy5tYXAoZnVuY3Rpb24oYyl7XG4gICAgICAgIHJldHVybiBjLnRvU3RyaW5nKCk7XG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuICBhcmdzLnB1c2gobmV4dCk7XG4gIHRoaXMuZ2V0Q29va2llcy5hcHBseSh0aGlzLGFyZ3MpO1xufTtcblxuQ0FOX0JFX1NZTkMucHVzaCgnc2VyaWFsaXplJyk7XG5Db29raWVKYXIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGNiKSB7XG4gIHZhciB0eXBlID0gdGhpcy5zdG9yZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAodHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICB0eXBlID0gbnVsbDtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBSRUFETUUubWQgXCJTZXJpYWxpemF0aW9uIEZvcm1hdFwiIGlmIHlvdSBjaGFuZ2UgdGhpcywgcGxlYXNlIVxuICB2YXIgc2VyaWFsaXplZCA9IHtcbiAgICAvLyBUaGUgdmVyc2lvbiBvZiB0b3VnaC1jb29raWUgdGhhdCBzZXJpYWxpemVkIHRoaXMgamFyLiBHZW5lcmFsbHkgYSBnb29kXG4gICAgLy8gcHJhY3RpY2Ugc2luY2UgZnV0dXJlIHZlcnNpb25zIGNhbiBtYWtlIGRhdGEgaW1wb3J0IGRlY2lzaW9ucyBiYXNlZCBvblxuICAgIC8vIGtub3duIHBhc3QgYmVoYXZpb3IuIFdoZW4vaWYgdGhpcyBtYXR0ZXJzLCB1c2UgYHNlbXZlcmAuXG4gICAgdmVyc2lvbjogJ3RvdWdoLWNvb2tpZUAnK1ZFUlNJT04sXG5cbiAgICAvLyBhZGQgdGhlIHN0b3JlIHR5cGUsIHRvIG1ha2UgaHVtYW5zIGhhcHB5OlxuICAgIHN0b3JlVHlwZTogdHlwZSxcblxuICAgIC8vIENvb2tpZUphciBjb25maWd1cmF0aW9uOlxuICAgIHJlamVjdFB1YmxpY1N1ZmZpeGVzOiAhIXRoaXMucmVqZWN0UHVibGljU3VmZml4ZXMsXG5cbiAgICAvLyB0aGlzIGdldHMgZmlsbGVkIGZyb20gZ2V0QWxsQ29va2llczpcbiAgICBjb29raWVzOiBbXVxuICB9O1xuXG4gIGlmICghKHRoaXMuc3RvcmUuZ2V0QWxsQ29va2llcyAmJlxuICAgICAgICB0eXBlb2YgdGhpcy5zdG9yZS5nZXRBbGxDb29raWVzID09PSAnZnVuY3Rpb24nKSlcbiAge1xuICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ3N0b3JlIGRvZXMgbm90IHN1cHBvcnQgZ2V0QWxsQ29va2llcyBhbmQgY2Fubm90IGJlIHNlcmlhbGl6ZWQnKSk7XG4gIH1cblxuICB0aGlzLnN0b3JlLmdldEFsbENvb2tpZXMoZnVuY3Rpb24oZXJyLGNvb2tpZXMpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICB9XG5cbiAgICBzZXJpYWxpemVkLmNvb2tpZXMgPSBjb29raWVzLm1hcChmdW5jdGlvbihjb29raWUpIHtcbiAgICAgIC8vIGNvbnZlcnQgdG8gc2VyaWFsaXplZCAncmF3JyBjb29raWVzXG4gICAgICBjb29raWUgPSAoY29va2llIGluc3RhbmNlb2YgQ29va2llKSA/IGNvb2tpZS50b0pTT04oKSA6IGNvb2tpZTtcblxuICAgICAgLy8gUmVtb3ZlIHRoZSBpbmRleCBzbyBuZXcgb25lcyBnZXQgYXNzaWduZWQgZHVyaW5nIGRlc2VyaWFsaXphdGlvblxuICAgICAgZGVsZXRlIGNvb2tpZS5jcmVhdGlvbkluZGV4O1xuXG4gICAgICByZXR1cm4gY29va2llO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNiKG51bGwsIHNlcmlhbGl6ZWQpO1xuICB9KTtcbn07XG5cbi8vIHdlbGwta25vd24gbmFtZSB0aGF0IEpTT04uc3RyaW5naWZ5IGNhbGxzXG5Db29raWVKYXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zZXJpYWxpemVTeW5jKCk7XG59O1xuXG4vLyB1c2UgdGhlIGNsYXNzIG1ldGhvZCBDb29raWVKYXIuZGVzZXJpYWxpemUgaW5zdGVhZCBvZiBjYWxsaW5nIHRoaXMgZGlyZWN0bHlcbkNBTl9CRV9TWU5DLnB1c2goJ19pbXBvcnRDb29raWVzJyk7XG5Db29raWVKYXIucHJvdG90eXBlLl9pbXBvcnRDb29raWVzID0gZnVuY3Rpb24oc2VyaWFsaXplZCwgY2IpIHtcbiAgdmFyIGphciA9IHRoaXM7XG4gIHZhciBjb29raWVzID0gc2VyaWFsaXplZC5jb29raWVzO1xuICBpZiAoIWNvb2tpZXMgfHwgIUFycmF5LmlzQXJyYXkoY29va2llcykpIHtcbiAgICByZXR1cm4gY2IobmV3IEVycm9yKCdzZXJpYWxpemVkIGphciBoYXMgbm8gY29va2llcyBhcnJheScpKTtcbiAgfVxuICBjb29raWVzID0gY29va2llcy5zbGljZSgpOyAvLyBkbyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbFxuXG4gIGZ1bmN0aW9uIHB1dE5leHQoZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgfVxuXG4gICAgaWYgKCFjb29raWVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGNiKGVyciwgamFyKTtcbiAgICB9XG5cbiAgICB2YXIgY29va2llO1xuICAgIHRyeSB7XG4gICAgICBjb29raWUgPSBmcm9tSlNPTihjb29raWVzLnNoaWZ0KCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBjYihlKTtcbiAgICB9XG5cbiAgICBpZiAoY29va2llID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gcHV0TmV4dChudWxsKTsgLy8gc2tpcCB0aGlzIGNvb2tpZVxuICAgIH1cblxuICAgIGphci5zdG9yZS5wdXRDb29raWUoY29va2llLCBwdXROZXh0KTtcbiAgfVxuXG4gIHB1dE5leHQoKTtcbn07XG5cbkNvb2tpZUphci5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uKHN0ck9yT2JqLCBzdG9yZSwgY2IpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDMpIHtcbiAgICAvLyBzdG9yZSBpcyBvcHRpb25hbFxuICAgIGNiID0gc3RvcmU7XG4gICAgc3RvcmUgPSBudWxsO1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZWQ7XG4gIGlmICh0eXBlb2Ygc3RyT3JPYmogPT09ICdzdHJpbmcnKSB7XG4gICAgc2VyaWFsaXplZCA9IGpzb25QYXJzZShzdHJPck9iaik7XG4gICAgaWYgKHNlcmlhbGl6ZWQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmV0dXJuIGNiKHNlcmlhbGl6ZWQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZXJpYWxpemVkID0gc3RyT3JPYmo7XG4gIH1cblxuICB2YXIgamFyID0gbmV3IENvb2tpZUphcihzdG9yZSwgc2VyaWFsaXplZC5yZWplY3RQdWJsaWNTdWZmaXhlcyk7XG4gIGphci5faW1wb3J0Q29va2llcyhzZXJpYWxpemVkLCBmdW5jdGlvbihlcnIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICB9XG4gICAgY2IobnVsbCwgamFyKTtcbiAgfSk7XG59O1xuXG5Db29raWVKYXIuZGVzZXJpYWxpemVTeW5jID0gZnVuY3Rpb24oc3RyT3JPYmosIHN0b3JlKSB7XG4gIHZhciBzZXJpYWxpemVkID0gdHlwZW9mIHN0ck9yT2JqID09PSAnc3RyaW5nJyA/XG4gICAgSlNPTi5wYXJzZShzdHJPck9iaikgOiBzdHJPck9iajtcbiAgdmFyIGphciA9IG5ldyBDb29raWVKYXIoc3RvcmUsIHNlcmlhbGl6ZWQucmVqZWN0UHVibGljU3VmZml4ZXMpO1xuXG4gIC8vIGNhdGNoIHRoaXMgbWlzdGFrZSBlYXJseTpcbiAgaWYgKCFqYXIuc3RvcmUuc3luY2hyb25vdXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nvb2tpZUphciBzdG9yZSBpcyBub3Qgc3luY2hyb25vdXM7IHVzZSBhc3luYyBBUEkgaW5zdGVhZC4nKTtcbiAgfVxuXG4gIGphci5faW1wb3J0Q29va2llc1N5bmMoc2VyaWFsaXplZCk7XG4gIHJldHVybiBqYXI7XG59O1xuQ29va2llSmFyLmZyb21KU09OID0gQ29va2llSmFyLmRlc2VyaWFsaXplU3luYztcblxuQ29va2llSmFyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKG5ld1N0b3JlLCBjYikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNiID0gbmV3U3RvcmU7XG4gICAgbmV3U3RvcmUgPSBudWxsO1xuICB9XG5cbiAgdGhpcy5zZXJpYWxpemUoZnVuY3Rpb24oZXJyLHNlcmlhbGl6ZWQpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICB9XG4gICAgQ29va2llSmFyLmRlc2VyaWFsaXplKHNlcmlhbGl6ZWQsIG5ld1N0b3JlLCBjYik7XG4gIH0pO1xufTtcblxuQ0FOX0JFX1NZTkMucHVzaCgncmVtb3ZlQWxsQ29va2llcycpO1xuQ29va2llSmFyLnByb3RvdHlwZS5yZW1vdmVBbGxDb29raWVzID0gZnVuY3Rpb24oY2IpIHtcbiAgdmFyIHN0b3JlID0gdGhpcy5zdG9yZTtcblxuICAvLyBDaGVjayB0aGF0IHRoZSBzdG9yZSBpbXBsZW1lbnRzIGl0cyBvd24gcmVtb3ZlQWxsQ29va2llcygpLiBUaGUgZGVmYXVsdFxuICAvLyBpbXBsZW1lbnRhdGlvbiBpbiBTdG9yZSB3aWxsIGltbWVkaWF0ZWx5IGNhbGwgdGhlIGNhbGxiYWNrIHdpdGggYSBcIm5vdFxuICAvLyBpbXBsZW1lbnRlZFwiIEVycm9yLlxuICBpZiAoc3RvcmUucmVtb3ZlQWxsQ29va2llcyBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmXG4gICAgICBzdG9yZS5yZW1vdmVBbGxDb29raWVzICE9PSBTdG9yZS5wcm90b3R5cGUucmVtb3ZlQWxsQ29va2llcylcbiAge1xuICAgIHJldHVybiBzdG9yZS5yZW1vdmVBbGxDb29raWVzKGNiKTtcbiAgfVxuXG4gIHN0b3JlLmdldEFsbENvb2tpZXMoZnVuY3Rpb24oZXJyLCBjb29raWVzKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgfVxuXG4gICAgaWYgKGNvb2tpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY2IobnVsbCk7XG4gICAgfVxuXG4gICAgdmFyIGNvbXBsZXRlZENvdW50ID0gMDtcbiAgICB2YXIgcmVtb3ZlRXJyb3JzID0gW107XG5cbiAgICBmdW5jdGlvbiByZW1vdmVDb29raWVDYihyZW1vdmVFcnIpIHtcbiAgICAgIGlmIChyZW1vdmVFcnIpIHtcbiAgICAgICAgcmVtb3ZlRXJyb3JzLnB1c2gocmVtb3ZlRXJyKTtcbiAgICAgIH1cblxuICAgICAgY29tcGxldGVkQ291bnQrKztcblxuICAgICAgaWYgKGNvbXBsZXRlZENvdW50ID09PSBjb29raWVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY2IocmVtb3ZlRXJyb3JzLmxlbmd0aCA/IHJlbW92ZUVycm9yc1swXSA6IG51bGwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvb2tpZXMuZm9yRWFjaChmdW5jdGlvbihjb29raWUpIHtcbiAgICAgIHN0b3JlLnJlbW92ZUNvb2tpZShjb29raWUuZG9tYWluLCBjb29raWUucGF0aCwgY29va2llLmtleSwgcmVtb3ZlQ29va2llQ2IpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbkNvb2tpZUphci5wcm90b3R5cGUuX2Nsb25lU3luYyA9IHN5bmNXcmFwKCdjbG9uZScpO1xuQ29va2llSmFyLnByb3RvdHlwZS5jbG9uZVN5bmMgPSBmdW5jdGlvbihuZXdTdG9yZSkge1xuICBpZiAoIW5ld1N0b3JlLnN5bmNocm9ub3VzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb29raWVKYXIgY2xvbmUgZGVzdGluYXRpb24gc3RvcmUgaXMgbm90IHN5bmNocm9ub3VzOyB1c2UgYXN5bmMgQVBJIGluc3RlYWQuJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2Nsb25lU3luYyhuZXdTdG9yZSk7XG59O1xuXG4vLyBVc2UgYSBjbG9zdXJlIHRvIHByb3ZpZGUgYSB0cnVlIGltcGVyYXRpdmUgQVBJIGZvciBzeW5jaHJvbm91cyBzdG9yZXMuXG5mdW5jdGlvbiBzeW5jV3JhcChtZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5zdG9yZS5zeW5jaHJvbm91cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb29raWVKYXIgc3RvcmUgaXMgbm90IHN5bmNocm9ub3VzOyB1c2UgYXN5bmMgQVBJIGluc3RlYWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciBzeW5jRXJyLCBzeW5jUmVzdWx0O1xuICAgIGFyZ3MucHVzaChmdW5jdGlvbiBzeW5jQ2IoZXJyLCByZXN1bHQpIHtcbiAgICAgIHN5bmNFcnIgPSBlcnI7XG4gICAgICBzeW5jUmVzdWx0ID0gcmVzdWx0O1xuICAgIH0pO1xuICAgIHRoaXNbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgIGlmIChzeW5jRXJyKSB7XG4gICAgICB0aHJvdyBzeW5jRXJyO1xuICAgIH1cbiAgICByZXR1cm4gc3luY1Jlc3VsdDtcbiAgfTtcbn1cblxuLy8gd3JhcCBhbGwgZGVjbGFyZWQgQ0FOX0JFX1NZTkMgbWV0aG9kcyBpbiB0aGUgc3luYyB3cmFwcGVyXG5DQU5fQkVfU1lOQy5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICBDb29raWVKYXIucHJvdG90eXBlW21ldGhvZCsnU3luYyddID0gc3luY1dyYXAobWV0aG9kKTtcbn0pO1xuXG5leHBvcnRzLnZlcnNpb24gPSBWRVJTSU9OO1xuZXhwb3J0cy5Db29raWVKYXIgPSBDb29raWVKYXI7XG5leHBvcnRzLkNvb2tpZSA9IENvb2tpZTtcbmV4cG9ydHMuU3RvcmUgPSBTdG9yZTtcbmV4cG9ydHMuTWVtb3J5Q29va2llU3RvcmUgPSBNZW1vcnlDb29raWVTdG9yZTtcbmV4cG9ydHMucGFyc2VEYXRlID0gcGFyc2VEYXRlO1xuZXhwb3J0cy5mb3JtYXREYXRlID0gZm9ybWF0RGF0ZTtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmV4cG9ydHMuZnJvbUpTT04gPSBmcm9tSlNPTjtcbmV4cG9ydHMuZG9tYWluTWF0Y2ggPSBkb21haW5NYXRjaDtcbmV4cG9ydHMuZGVmYXVsdFBhdGggPSBkZWZhdWx0UGF0aDtcbmV4cG9ydHMucGF0aE1hdGNoID0gcGF0aE1hdGNoO1xuZXhwb3J0cy5nZXRQdWJsaWNTdWZmaXggPSBwdWJzdWZmaXguZ2V0UHVibGljU3VmZml4O1xuZXhwb3J0cy5jb29raWVDb21wYXJlID0gY29va2llQ29tcGFyZTtcbmV4cG9ydHMucGVybXV0ZURvbWFpbiA9IHJlcXVpcmUoJy4vcGVybXV0ZURvbWFpbicpLnBlcm11dGVEb21haW47XG5leHBvcnRzLnBlcm11dGVQYXRoID0gcGVybXV0ZVBhdGg7XG5leHBvcnRzLmNhbm9uaWNhbERvbWFpbiA9IGNhbm9uaWNhbERvbWFpbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/request/node_modules/tough-cookie/lib/cookie.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/request/node_modules/tough-cookie/lib/memstore.js":
/*!************************************************************************!*\
  !*** ./node_modules/request/node_modules/tough-cookie/lib/memstore.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2015, Salesforce.com, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar Store = (__webpack_require__(/*! ./store */ \"(rsc)/./node_modules/request/node_modules/tough-cookie/lib/store.js\").Store);\nvar permuteDomain = (__webpack_require__(/*! ./permuteDomain */ \"(rsc)/./node_modules/request/node_modules/tough-cookie/lib/permuteDomain.js\").permuteDomain);\nvar pathMatch = (__webpack_require__(/*! ./pathMatch */ \"(rsc)/./node_modules/request/node_modules/tough-cookie/lib/pathMatch.js\").pathMatch);\nvar util = __webpack_require__(/*! util */ \"util\");\n\nfunction MemoryCookieStore() {\n  Store.call(this);\n  this.idx = {};\n}\nutil.inherits(MemoryCookieStore, Store);\nexports.MemoryCookieStore = MemoryCookieStore;\nMemoryCookieStore.prototype.idx = null;\n\n// Since it's just a struct in RAM, this Store is synchronous\nMemoryCookieStore.prototype.synchronous = true;\n\n// force a default depth:\nMemoryCookieStore.prototype.inspect = function() {\n  return \"{ idx: \"+util.inspect(this.idx, false, 2)+' }';\n};\n\n// Use the new custom inspection symbol to add the custom inspect function if\n// available.\nif (util.inspect.custom) {\n  MemoryCookieStore.prototype[util.inspect.custom] = MemoryCookieStore.prototype.inspect;\n}\n\nMemoryCookieStore.prototype.findCookie = function(domain, path, key, cb) {\n  if (!this.idx[domain]) {\n    return cb(null,undefined);\n  }\n  if (!this.idx[domain][path]) {\n    return cb(null,undefined);\n  }\n  return cb(null,this.idx[domain][path][key]||null);\n};\n\nMemoryCookieStore.prototype.findCookies = function(domain, path, cb) {\n  var results = [];\n  if (!domain) {\n    return cb(null,[]);\n  }\n\n  var pathMatcher;\n  if (!path) {\n    // null means \"all paths\"\n    pathMatcher = function matchAll(domainIndex) {\n      for (var curPath in domainIndex) {\n        var pathIndex = domainIndex[curPath];\n        for (var key in pathIndex) {\n          results.push(pathIndex[key]);\n        }\n      }\n    };\n\n  } else {\n    pathMatcher = function matchRFC(domainIndex) {\n       //NOTE: we should use path-match algorithm from S5.1.4 here\n       //(see : https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/canonical_cookie.cc#L299)\n       Object.keys(domainIndex).forEach(function (cookiePath) {\n         if (pathMatch(path, cookiePath)) {\n           var pathIndex = domainIndex[cookiePath];\n\n           for (var key in pathIndex) {\n             results.push(pathIndex[key]);\n           }\n         }\n       });\n     };\n  }\n\n  var domains = permuteDomain(domain) || [domain];\n  var idx = this.idx;\n  domains.forEach(function(curDomain) {\n    var domainIndex = idx[curDomain];\n    if (!domainIndex) {\n      return;\n    }\n    pathMatcher(domainIndex);\n  });\n\n  cb(null,results);\n};\n\nMemoryCookieStore.prototype.putCookie = function(cookie, cb) {\n  if (!this.idx[cookie.domain]) {\n    this.idx[cookie.domain] = {};\n  }\n  if (!this.idx[cookie.domain][cookie.path]) {\n    this.idx[cookie.domain][cookie.path] = {};\n  }\n  this.idx[cookie.domain][cookie.path][cookie.key] = cookie;\n  cb(null);\n};\n\nMemoryCookieStore.prototype.updateCookie = function(oldCookie, newCookie, cb) {\n  // updateCookie() may avoid updating cookies that are identical.  For example,\n  // lastAccessed may not be important to some stores and an equality\n  // comparison could exclude that field.\n  this.putCookie(newCookie,cb);\n};\n\nMemoryCookieStore.prototype.removeCookie = function(domain, path, key, cb) {\n  if (this.idx[domain] && this.idx[domain][path] && this.idx[domain][path][key]) {\n    delete this.idx[domain][path][key];\n  }\n  cb(null);\n};\n\nMemoryCookieStore.prototype.removeCookies = function(domain, path, cb) {\n  if (this.idx[domain]) {\n    if (path) {\n      delete this.idx[domain][path];\n    } else {\n      delete this.idx[domain];\n    }\n  }\n  return cb(null);\n};\n\nMemoryCookieStore.prototype.removeAllCookies = function(cb) {\n  this.idx = {};\n  return cb(null);\n}\n\nMemoryCookieStore.prototype.getAllCookies = function(cb) {\n  var cookies = [];\n  var idx = this.idx;\n\n  var domains = Object.keys(idx);\n  domains.forEach(function(domain) {\n    var paths = Object.keys(idx[domain]);\n    paths.forEach(function(path) {\n      var keys = Object.keys(idx[domain][path]);\n      keys.forEach(function(key) {\n        if (key !== null) {\n          cookies.push(idx[domain][path][key]);\n        }\n      });\n    });\n  });\n\n  // Sort by creationIndex so deserializing retains the creation order.\n  // When implementing your own store, this SHOULD retain the order too\n  cookies.sort(function(a,b) {\n    return (a.creationIndex||0) - (b.creationIndex||0);\n  });\n\n  cb(null, cookies);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL2xpYi9tZW1zdG9yZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsK0JBQStCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiLFlBQVksaUhBQXdCO0FBQ3BDLG9CQUFvQix5SUFBd0M7QUFDNUQsZ0JBQWdCLDZIQUFnQztBQUNoRCxXQUFXLG1CQUFPLENBQUMsa0JBQU07O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSwyQ0FBMkM7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGFnZS1mb3JtLy4vbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL3RvdWdoLWNvb2tpZS9saWIvbWVtc3RvcmUuanM/NjZlMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgU2FsZXNmb3JjZS5jb20sIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAqIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgU2FsZXNmb3JjZS5jb20gbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heVxuICogYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dFxuICogc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuICogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiAqIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuICogSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiAqIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciBTdG9yZSA9IHJlcXVpcmUoJy4vc3RvcmUnKS5TdG9yZTtcbnZhciBwZXJtdXRlRG9tYWluID0gcmVxdWlyZSgnLi9wZXJtdXRlRG9tYWluJykucGVybXV0ZURvbWFpbjtcbnZhciBwYXRoTWF0Y2ggPSByZXF1aXJlKCcuL3BhdGhNYXRjaCcpLnBhdGhNYXRjaDtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5mdW5jdGlvbiBNZW1vcnlDb29raWVTdG9yZSgpIHtcbiAgU3RvcmUuY2FsbCh0aGlzKTtcbiAgdGhpcy5pZHggPSB7fTtcbn1cbnV0aWwuaW5oZXJpdHMoTWVtb3J5Q29va2llU3RvcmUsIFN0b3JlKTtcbmV4cG9ydHMuTWVtb3J5Q29va2llU3RvcmUgPSBNZW1vcnlDb29raWVTdG9yZTtcbk1lbW9yeUNvb2tpZVN0b3JlLnByb3RvdHlwZS5pZHggPSBudWxsO1xuXG4vLyBTaW5jZSBpdCdzIGp1c3QgYSBzdHJ1Y3QgaW4gUkFNLCB0aGlzIFN0b3JlIGlzIHN5bmNocm9ub3VzXG5NZW1vcnlDb29raWVTdG9yZS5wcm90b3R5cGUuc3luY2hyb25vdXMgPSB0cnVlO1xuXG4vLyBmb3JjZSBhIGRlZmF1bHQgZGVwdGg6XG5NZW1vcnlDb29raWVTdG9yZS5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXCJ7IGlkeDogXCIrdXRpbC5pbnNwZWN0KHRoaXMuaWR4LCBmYWxzZSwgMikrJyB9Jztcbn07XG5cbi8vIFVzZSB0aGUgbmV3IGN1c3RvbSBpbnNwZWN0aW9uIHN5bWJvbCB0byBhZGQgdGhlIGN1c3RvbSBpbnNwZWN0IGZ1bmN0aW9uIGlmXG4vLyBhdmFpbGFibGUuXG5pZiAodXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICBNZW1vcnlDb29raWVTdG9yZS5wcm90b3R5cGVbdXRpbC5pbnNwZWN0LmN1c3RvbV0gPSBNZW1vcnlDb29raWVTdG9yZS5wcm90b3R5cGUuaW5zcGVjdDtcbn1cblxuTWVtb3J5Q29va2llU3RvcmUucHJvdG90eXBlLmZpbmRDb29raWUgPSBmdW5jdGlvbihkb21haW4sIHBhdGgsIGtleSwgY2IpIHtcbiAgaWYgKCF0aGlzLmlkeFtkb21haW5dKSB7XG4gICAgcmV0dXJuIGNiKG51bGwsdW5kZWZpbmVkKTtcbiAgfVxuICBpZiAoIXRoaXMuaWR4W2RvbWFpbl1bcGF0aF0pIHtcbiAgICByZXR1cm4gY2IobnVsbCx1bmRlZmluZWQpO1xuICB9XG4gIHJldHVybiBjYihudWxsLHRoaXMuaWR4W2RvbWFpbl1bcGF0aF1ba2V5XXx8bnVsbCk7XG59O1xuXG5NZW1vcnlDb29raWVTdG9yZS5wcm90b3R5cGUuZmluZENvb2tpZXMgPSBmdW5jdGlvbihkb21haW4sIHBhdGgsIGNiKSB7XG4gIHZhciByZXN1bHRzID0gW107XG4gIGlmICghZG9tYWluKSB7XG4gICAgcmV0dXJuIGNiKG51bGwsW10pO1xuICB9XG5cbiAgdmFyIHBhdGhNYXRjaGVyO1xuICBpZiAoIXBhdGgpIHtcbiAgICAvLyBudWxsIG1lYW5zIFwiYWxsIHBhdGhzXCJcbiAgICBwYXRoTWF0Y2hlciA9IGZ1bmN0aW9uIG1hdGNoQWxsKGRvbWFpbkluZGV4KSB7XG4gICAgICBmb3IgKHZhciBjdXJQYXRoIGluIGRvbWFpbkluZGV4KSB7XG4gICAgICAgIHZhciBwYXRoSW5kZXggPSBkb21haW5JbmRleFtjdXJQYXRoXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHBhdGhJbmRleCkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChwYXRoSW5kZXhba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gIH0gZWxzZSB7XG4gICAgcGF0aE1hdGNoZXIgPSBmdW5jdGlvbiBtYXRjaFJGQyhkb21haW5JbmRleCkge1xuICAgICAgIC8vTk9URTogd2Ugc2hvdWxkIHVzZSBwYXRoLW1hdGNoIGFsZ29yaXRobSBmcm9tIFM1LjEuNCBoZXJlXG4gICAgICAgLy8oc2VlIDogaHR0cHM6Ly9naXRodWIuY29tL0Nocm9taXVtV2ViQXBwcy9jaHJvbWl1bS9ibG9iL2IzZDNiNGRhOGJiOTRjMWIyZTA2MTYwMGRmMTA2ZDU5MGZkYTM2MjAvbmV0L2Nvb2tpZXMvY2Fub25pY2FsX2Nvb2tpZS5jYyNMMjk5KVxuICAgICAgIE9iamVjdC5rZXlzKGRvbWFpbkluZGV4KS5mb3JFYWNoKGZ1bmN0aW9uIChjb29raWVQYXRoKSB7XG4gICAgICAgICBpZiAocGF0aE1hdGNoKHBhdGgsIGNvb2tpZVBhdGgpKSB7XG4gICAgICAgICAgIHZhciBwYXRoSW5kZXggPSBkb21haW5JbmRleFtjb29raWVQYXRoXTtcblxuICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcGF0aEluZGV4KSB7XG4gICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHBhdGhJbmRleFtrZXldKTtcbiAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgIH0pO1xuICAgICB9O1xuICB9XG5cbiAgdmFyIGRvbWFpbnMgPSBwZXJtdXRlRG9tYWluKGRvbWFpbikgfHwgW2RvbWFpbl07XG4gIHZhciBpZHggPSB0aGlzLmlkeDtcbiAgZG9tYWlucy5mb3JFYWNoKGZ1bmN0aW9uKGN1ckRvbWFpbikge1xuICAgIHZhciBkb21haW5JbmRleCA9IGlkeFtjdXJEb21haW5dO1xuICAgIGlmICghZG9tYWluSW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGF0aE1hdGNoZXIoZG9tYWluSW5kZXgpO1xuICB9KTtcblxuICBjYihudWxsLHJlc3VsdHMpO1xufTtcblxuTWVtb3J5Q29va2llU3RvcmUucHJvdG90eXBlLnB1dENvb2tpZSA9IGZ1bmN0aW9uKGNvb2tpZSwgY2IpIHtcbiAgaWYgKCF0aGlzLmlkeFtjb29raWUuZG9tYWluXSkge1xuICAgIHRoaXMuaWR4W2Nvb2tpZS5kb21haW5dID0ge307XG4gIH1cbiAgaWYgKCF0aGlzLmlkeFtjb29raWUuZG9tYWluXVtjb29raWUucGF0aF0pIHtcbiAgICB0aGlzLmlkeFtjb29raWUuZG9tYWluXVtjb29raWUucGF0aF0gPSB7fTtcbiAgfVxuICB0aGlzLmlkeFtjb29raWUuZG9tYWluXVtjb29raWUucGF0aF1bY29va2llLmtleV0gPSBjb29raWU7XG4gIGNiKG51bGwpO1xufTtcblxuTWVtb3J5Q29va2llU3RvcmUucHJvdG90eXBlLnVwZGF0ZUNvb2tpZSA9IGZ1bmN0aW9uKG9sZENvb2tpZSwgbmV3Q29va2llLCBjYikge1xuICAvLyB1cGRhdGVDb29raWUoKSBtYXkgYXZvaWQgdXBkYXRpbmcgY29va2llcyB0aGF0IGFyZSBpZGVudGljYWwuICBGb3IgZXhhbXBsZSxcbiAgLy8gbGFzdEFjY2Vzc2VkIG1heSBub3QgYmUgaW1wb3J0YW50IHRvIHNvbWUgc3RvcmVzIGFuZCBhbiBlcXVhbGl0eVxuICAvLyBjb21wYXJpc29uIGNvdWxkIGV4Y2x1ZGUgdGhhdCBmaWVsZC5cbiAgdGhpcy5wdXRDb29raWUobmV3Q29va2llLGNiKTtcbn07XG5cbk1lbW9yeUNvb2tpZVN0b3JlLnByb3RvdHlwZS5yZW1vdmVDb29raWUgPSBmdW5jdGlvbihkb21haW4sIHBhdGgsIGtleSwgY2IpIHtcbiAgaWYgKHRoaXMuaWR4W2RvbWFpbl0gJiYgdGhpcy5pZHhbZG9tYWluXVtwYXRoXSAmJiB0aGlzLmlkeFtkb21haW5dW3BhdGhdW2tleV0pIHtcbiAgICBkZWxldGUgdGhpcy5pZHhbZG9tYWluXVtwYXRoXVtrZXldO1xuICB9XG4gIGNiKG51bGwpO1xufTtcblxuTWVtb3J5Q29va2llU3RvcmUucHJvdG90eXBlLnJlbW92ZUNvb2tpZXMgPSBmdW5jdGlvbihkb21haW4sIHBhdGgsIGNiKSB7XG4gIGlmICh0aGlzLmlkeFtkb21haW5dKSB7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmlkeFtkb21haW5dW3BhdGhdO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5pZHhbZG9tYWluXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNiKG51bGwpO1xufTtcblxuTWVtb3J5Q29va2llU3RvcmUucHJvdG90eXBlLnJlbW92ZUFsbENvb2tpZXMgPSBmdW5jdGlvbihjYikge1xuICB0aGlzLmlkeCA9IHt9O1xuICByZXR1cm4gY2IobnVsbCk7XG59XG5cbk1lbW9yeUNvb2tpZVN0b3JlLnByb3RvdHlwZS5nZXRBbGxDb29raWVzID0gZnVuY3Rpb24oY2IpIHtcbiAgdmFyIGNvb2tpZXMgPSBbXTtcbiAgdmFyIGlkeCA9IHRoaXMuaWR4O1xuXG4gIHZhciBkb21haW5zID0gT2JqZWN0LmtleXMoaWR4KTtcbiAgZG9tYWlucy5mb3JFYWNoKGZ1bmN0aW9uKGRvbWFpbikge1xuICAgIHZhciBwYXRocyA9IE9iamVjdC5rZXlzKGlkeFtkb21haW5dKTtcbiAgICBwYXRocy5mb3JFYWNoKGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoaWR4W2RvbWFpbl1bcGF0aF0pO1xuICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29va2llcy5wdXNoKGlkeFtkb21haW5dW3BhdGhdW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gU29ydCBieSBjcmVhdGlvbkluZGV4IHNvIGRlc2VyaWFsaXppbmcgcmV0YWlucyB0aGUgY3JlYXRpb24gb3JkZXIuXG4gIC8vIFdoZW4gaW1wbGVtZW50aW5nIHlvdXIgb3duIHN0b3JlLCB0aGlzIFNIT1VMRCByZXRhaW4gdGhlIG9yZGVyIHRvb1xuICBjb29raWVzLnNvcnQoZnVuY3Rpb24oYSxiKSB7XG4gICAgcmV0dXJuIChhLmNyZWF0aW9uSW5kZXh8fDApIC0gKGIuY3JlYXRpb25JbmRleHx8MCk7XG4gIH0pO1xuXG4gIGNiKG51bGwsIGNvb2tpZXMpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/request/node_modules/tough-cookie/lib/memstore.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/request/node_modules/tough-cookie/lib/pathMatch.js":
/*!*************************************************************************!*\
  !*** ./node_modules/request/node_modules/tough-cookie/lib/pathMatch.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/*!\n * Copyright (c) 2015, Salesforce.com, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * \"A request-path path-matches a given cookie-path if at least one of the\n * following conditions holds:\"\n */\nfunction pathMatch (reqPath, cookiePath) {\n  // \"o  The cookie-path and the request-path are identical.\"\n  if (cookiePath === reqPath) {\n    return true;\n  }\n\n  var idx = reqPath.indexOf(cookiePath);\n  if (idx === 0) {\n    // \"o  The cookie-path is a prefix of the request-path, and the last\n    // character of the cookie-path is %x2F (\"/\").\"\n    if (cookiePath.substr(-1) === \"/\") {\n      return true;\n    }\n\n    // \" o  The cookie-path is a prefix of the request-path, and the first\n    // character of the request-path that is not included in the cookie- path\n    // is a %x2F (\"/\") character.\"\n    if (reqPath.substr(cookiePath.length, 1) === \"/\") {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexports.pathMatch = pathMatch;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL2xpYi9wYXRoTWF0Y2guanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLCtCQUErQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYWdlLWZvcm0vLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL2xpYi9wYXRoTWF0Y2guanM/ZjE4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgU2FsZXNmb3JjZS5jb20sIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAqIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgU2FsZXNmb3JjZS5jb20gbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heVxuICogYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dFxuICogc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuICogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiAqIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuICogSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiAqIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuLypcbiAqIFwiQSByZXF1ZXN0LXBhdGggcGF0aC1tYXRjaGVzIGEgZ2l2ZW4gY29va2llLXBhdGggaWYgYXQgbGVhc3Qgb25lIG9mIHRoZVxuICogZm9sbG93aW5nIGNvbmRpdGlvbnMgaG9sZHM6XCJcbiAqL1xuZnVuY3Rpb24gcGF0aE1hdGNoIChyZXFQYXRoLCBjb29raWVQYXRoKSB7XG4gIC8vIFwibyAgVGhlIGNvb2tpZS1wYXRoIGFuZCB0aGUgcmVxdWVzdC1wYXRoIGFyZSBpZGVudGljYWwuXCJcbiAgaWYgKGNvb2tpZVBhdGggPT09IHJlcVBhdGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBpZHggPSByZXFQYXRoLmluZGV4T2YoY29va2llUGF0aCk7XG4gIGlmIChpZHggPT09IDApIHtcbiAgICAvLyBcIm8gIFRoZSBjb29raWUtcGF0aCBpcyBhIHByZWZpeCBvZiB0aGUgcmVxdWVzdC1wYXRoLCBhbmQgdGhlIGxhc3RcbiAgICAvLyBjaGFyYWN0ZXIgb2YgdGhlIGNvb2tpZS1wYXRoIGlzICV4MkYgKFwiL1wiKS5cIlxuICAgIGlmIChjb29raWVQYXRoLnN1YnN0cigtMSkgPT09IFwiL1wiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBcIiBvICBUaGUgY29va2llLXBhdGggaXMgYSBwcmVmaXggb2YgdGhlIHJlcXVlc3QtcGF0aCwgYW5kIHRoZSBmaXJzdFxuICAgIC8vIGNoYXJhY3RlciBvZiB0aGUgcmVxdWVzdC1wYXRoIHRoYXQgaXMgbm90IGluY2x1ZGVkIGluIHRoZSBjb29raWUtIHBhdGhcbiAgICAvLyBpcyBhICV4MkYgKFwiL1wiKSBjaGFyYWN0ZXIuXCJcbiAgICBpZiAocmVxUGF0aC5zdWJzdHIoY29va2llUGF0aC5sZW5ndGgsIDEpID09PSBcIi9cIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnRzLnBhdGhNYXRjaCA9IHBhdGhNYXRjaDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/request/node_modules/tough-cookie/lib/pathMatch.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/request/node_modules/tough-cookie/lib/permuteDomain.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/request/node_modules/tough-cookie/lib/permuteDomain.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2015, Salesforce.com, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar pubsuffix = __webpack_require__(/*! ./pubsuffix-psl */ \"(rsc)/./node_modules/request/node_modules/tough-cookie/lib/pubsuffix-psl.js\");\n\n// Gives the permutation of all possible domainMatch()es of a given domain. The\n// array is in shortest-to-longest order.  Handy for indexing.\nfunction permuteDomain (domain) {\n  var pubSuf = pubsuffix.getPublicSuffix(domain);\n  if (!pubSuf) {\n    return null;\n  }\n  if (pubSuf == domain) {\n    return [domain];\n  }\n\n  var prefix = domain.slice(0, -(pubSuf.length + 1)); // \".example.com\"\n  var parts = prefix.split('.').reverse();\n  var cur = pubSuf;\n  var permutations = [cur];\n  while (parts.length) {\n    cur = parts.shift() + '.' + cur;\n    permutations.push(cur);\n  }\n  return permutations;\n}\n\nexports.permuteDomain = permuteDomain;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL2xpYi9wZXJtdXRlRG9tYWluLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywrQkFBK0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsZ0JBQWdCLG1CQUFPLENBQUMsb0dBQWlCOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BhZ2UtZm9ybS8uL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvbGliL3Blcm11dGVEb21haW4uanM/NDY3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgU2FsZXNmb3JjZS5jb20sIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAqIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgU2FsZXNmb3JjZS5jb20gbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heVxuICogYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dFxuICogc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuICogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiAqIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuICogSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiAqIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIHB1YnN1ZmZpeCA9IHJlcXVpcmUoJy4vcHVic3VmZml4LXBzbCcpO1xuXG4vLyBHaXZlcyB0aGUgcGVybXV0YXRpb24gb2YgYWxsIHBvc3NpYmxlIGRvbWFpbk1hdGNoKCllcyBvZiBhIGdpdmVuIGRvbWFpbi4gVGhlXG4vLyBhcnJheSBpcyBpbiBzaG9ydGVzdC10by1sb25nZXN0IG9yZGVyLiAgSGFuZHkgZm9yIGluZGV4aW5nLlxuZnVuY3Rpb24gcGVybXV0ZURvbWFpbiAoZG9tYWluKSB7XG4gIHZhciBwdWJTdWYgPSBwdWJzdWZmaXguZ2V0UHVibGljU3VmZml4KGRvbWFpbik7XG4gIGlmICghcHViU3VmKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHB1YlN1ZiA9PSBkb21haW4pIHtcbiAgICByZXR1cm4gW2RvbWFpbl07XG4gIH1cblxuICB2YXIgcHJlZml4ID0gZG9tYWluLnNsaWNlKDAsIC0ocHViU3VmLmxlbmd0aCArIDEpKTsgLy8gXCIuZXhhbXBsZS5jb21cIlxuICB2YXIgcGFydHMgPSBwcmVmaXguc3BsaXQoJy4nKS5yZXZlcnNlKCk7XG4gIHZhciBjdXIgPSBwdWJTdWY7XG4gIHZhciBwZXJtdXRhdGlvbnMgPSBbY3VyXTtcbiAgd2hpbGUgKHBhcnRzLmxlbmd0aCkge1xuICAgIGN1ciA9IHBhcnRzLnNoaWZ0KCkgKyAnLicgKyBjdXI7XG4gICAgcGVybXV0YXRpb25zLnB1c2goY3VyKTtcbiAgfVxuICByZXR1cm4gcGVybXV0YXRpb25zO1xufVxuXG5leHBvcnRzLnBlcm11dGVEb21haW4gPSBwZXJtdXRlRG9tYWluO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/request/node_modules/tough-cookie/lib/permuteDomain.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/request/node_modules/tough-cookie/lib/pubsuffix-psl.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/request/node_modules/tough-cookie/lib/pubsuffix-psl.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2018, Salesforce.com, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar psl = __webpack_require__(/*! psl */ \"(rsc)/./node_modules/psl/index.js\");\n\nfunction getPublicSuffix(domain) {\n  return psl.get(domain);\n}\n\nexports.getPublicSuffix = getPublicSuffix;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL2xpYi9wdWJzdWZmaXgtcHNsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywrQkFBK0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsVUFBVSxtQkFBTyxDQUFDLDhDQUFLOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGFnZS1mb3JtLy4vbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL3RvdWdoLWNvb2tpZS9saWIvcHVic3VmZml4LXBzbC5qcz9kODUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE4LCBTYWxlc2ZvcmNlLmNvbSwgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICogYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogMy4gTmVpdGhlciB0aGUgbmFtZSBvZiBTYWxlc2ZvcmNlLmNvbSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5XG4gKiBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0XG4gKiBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAqIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4gKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4gKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuICogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAqIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIHBzbCA9IHJlcXVpcmUoJ3BzbCcpO1xuXG5mdW5jdGlvbiBnZXRQdWJsaWNTdWZmaXgoZG9tYWluKSB7XG4gIHJldHVybiBwc2wuZ2V0KGRvbWFpbik7XG59XG5cbmV4cG9ydHMuZ2V0UHVibGljU3VmZml4ID0gZ2V0UHVibGljU3VmZml4O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/request/node_modules/tough-cookie/lib/pubsuffix-psl.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/request/node_modules/tough-cookie/lib/store.js":
/*!*********************************************************************!*\
  !*** ./node_modules/request/node_modules/tough-cookie/lib/store.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/*!\n * Copyright (c) 2015, Salesforce.com, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*jshint unused:false */\n\nfunction Store() {\n}\nexports.Store = Store;\n\n// Stores may be synchronous, but are still required to use a\n// Continuation-Passing Style API.  The CookieJar itself will expose a \"*Sync\"\n// API that converts from synchronous-callbacks to imperative style.\nStore.prototype.synchronous = false;\n\nStore.prototype.findCookie = function(domain, path, key, cb) {\n  throw new Error('findCookie is not implemented');\n};\n\nStore.prototype.findCookies = function(domain, path, cb) {\n  throw new Error('findCookies is not implemented');\n};\n\nStore.prototype.putCookie = function(cookie, cb) {\n  throw new Error('putCookie is not implemented');\n};\n\nStore.prototype.updateCookie = function(oldCookie, newCookie, cb) {\n  // recommended default implementation:\n  // return this.putCookie(newCookie, cb);\n  throw new Error('updateCookie is not implemented');\n};\n\nStore.prototype.removeCookie = function(domain, path, key, cb) {\n  throw new Error('removeCookie is not implemented');\n};\n\nStore.prototype.removeCookies = function(domain, path, cb) {\n  throw new Error('removeCookies is not implemented');\n};\n\nStore.prototype.removeAllCookies = function(cb) {\n  throw new Error('removeAllCookies is not implemented');\n}\n\nStore.prototype.getAllCookies = function(cb) {\n  throw new Error('getAllCookies is not implemented (therefore jar cannot be serialized)');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL2xpYi9zdG9yZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsK0JBQStCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGFnZS1mb3JtLy4vbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL3RvdWdoLWNvb2tpZS9saWIvc3RvcmUuanM/OGFiZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgU2FsZXNmb3JjZS5jb20sIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAqIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgU2FsZXNmb3JjZS5jb20gbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heVxuICogYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dFxuICogc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuICogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiAqIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuICogSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiAqIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cbid1c2Ugc3RyaWN0Jztcbi8qanNoaW50IHVudXNlZDpmYWxzZSAqL1xuXG5mdW5jdGlvbiBTdG9yZSgpIHtcbn1cbmV4cG9ydHMuU3RvcmUgPSBTdG9yZTtcblxuLy8gU3RvcmVzIG1heSBiZSBzeW5jaHJvbm91cywgYnV0IGFyZSBzdGlsbCByZXF1aXJlZCB0byB1c2UgYVxuLy8gQ29udGludWF0aW9uLVBhc3NpbmcgU3R5bGUgQVBJLiAgVGhlIENvb2tpZUphciBpdHNlbGYgd2lsbCBleHBvc2UgYSBcIipTeW5jXCJcbi8vIEFQSSB0aGF0IGNvbnZlcnRzIGZyb20gc3luY2hyb25vdXMtY2FsbGJhY2tzIHRvIGltcGVyYXRpdmUgc3R5bGUuXG5TdG9yZS5wcm90b3R5cGUuc3luY2hyb25vdXMgPSBmYWxzZTtcblxuU3RvcmUucHJvdG90eXBlLmZpbmRDb29raWUgPSBmdW5jdGlvbihkb21haW4sIHBhdGgsIGtleSwgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdmaW5kQ29va2llIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuU3RvcmUucHJvdG90eXBlLmZpbmRDb29raWVzID0gZnVuY3Rpb24oZG9tYWluLCBwYXRoLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbmRDb29raWVzIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuU3RvcmUucHJvdG90eXBlLnB1dENvb2tpZSA9IGZ1bmN0aW9uKGNvb2tpZSwgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdwdXRDb29raWUgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUudXBkYXRlQ29va2llID0gZnVuY3Rpb24ob2xkQ29va2llLCBuZXdDb29raWUsIGNiKSB7XG4gIC8vIHJlY29tbWVuZGVkIGRlZmF1bHQgaW1wbGVtZW50YXRpb246XG4gIC8vIHJldHVybiB0aGlzLnB1dENvb2tpZShuZXdDb29raWUsIGNiKTtcbiAgdGhyb3cgbmV3IEVycm9yKCd1cGRhdGVDb29raWUgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUucmVtb3ZlQ29va2llID0gZnVuY3Rpb24oZG9tYWluLCBwYXRoLCBrZXksIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcigncmVtb3ZlQ29va2llIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuU3RvcmUucHJvdG90eXBlLnJlbW92ZUNvb2tpZXMgPSBmdW5jdGlvbihkb21haW4sIHBhdGgsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcigncmVtb3ZlQ29va2llcyBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS5yZW1vdmVBbGxDb29raWVzID0gZnVuY3Rpb24oY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVBbGxDb29raWVzIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufVxuXG5TdG9yZS5wcm90b3R5cGUuZ2V0QWxsQ29va2llcyA9IGZ1bmN0aW9uKGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignZ2V0QWxsQ29va2llcyBpcyBub3QgaW1wbGVtZW50ZWQgKHRoZXJlZm9yZSBqYXIgY2Fubm90IGJlIHNlcmlhbGl6ZWQpJyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/request/node_modules/tough-cookie/lib/store.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/request/node_modules/tough-cookie/lib/version.js":
/*!***********************************************************************!*\
  !*** ./node_modules/request/node_modules/tough-cookie/lib/version.js ***!
  \***********************************************************************/
/***/ ((module) => {

eval("// generated by genversion\nmodule.exports = '2.5.0'\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL2xpYi92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYWdlLWZvcm0vLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL2xpYi92ZXJzaW9uLmpzP2JkZTUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZ2VuZXJhdGVkIGJ5IGdlbnZlcnNpb25cbm1vZHVsZS5leHBvcnRzID0gJzIuNS4wJ1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/request/node_modules/tough-cookie/lib/version.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/request/node_modules/uuid/lib/bytesToUuid.js":
/*!*******************************************************************!*\
  !*** ./node_modules/request/node_modules/uuid/lib/bytesToUuid.js ***!
  \*******************************************************************/
/***/ ((module) => {

eval("/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]]\n  ]).join('');\n}\n\nmodule.exports = bytesToUuid;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvdXVpZC9saWIvYnl0ZXNUb1V1aWQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGFnZS1mb3JtLy4vbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL3V1aWQvbGliL2J5dGVzVG9VdWlkLmpzP2I5MzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG52YXIgYnl0ZVRvSGV4ID0gW107XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG59XG5cbmZ1bmN0aW9uIGJ5dGVzVG9VdWlkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBidGggPSBieXRlVG9IZXg7XG4gIC8vIGpvaW4gdXNlZCB0byBmaXggbWVtb3J5IGlzc3VlIGNhdXNlZCBieSBjb25jYXRlbmF0aW9uOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMTc1I2M0XG4gIHJldHVybiAoW1xuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dXG4gIF0pLmpvaW4oJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ5dGVzVG9VdWlkO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/request/node_modules/uuid/lib/bytesToUuid.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/request/node_modules/uuid/lib/rng.js":
/*!***********************************************************!*\
  !*** ./node_modules/request/node_modules/uuid/lib/rng.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Unique ID creation requires a high quality random # generator.  In node.js\n// this is pretty straight-forward - we use the crypto API.\n\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nmodule.exports = function nodeRNG() {\n  return crypto.randomBytes(16);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvdXVpZC9saWIvcm5nLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLHNCQUFROztBQUU3QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYWdlLWZvcm0vLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvdXVpZC9saWIvcm5nLmpzPzJiMzUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gIEluIG5vZGUuanNcbi8vIHRoaXMgaXMgcHJldHR5IHN0cmFpZ2h0LWZvcndhcmQgLSB3ZSB1c2UgdGhlIGNyeXB0byBBUEkuXG5cbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub2RlUk5HKCkge1xuICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/request/node_modules/uuid/lib/rng.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/request/node_modules/uuid/v4.js":
/*!******************************************************!*\
  !*** ./node_modules/request/node_modules/uuid/v4.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var rng = __webpack_require__(/*! ./lib/rng */ \"(rsc)/./node_modules/request/node_modules/uuid/lib/rng.js\");\nvar bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ \"(rsc)/./node_modules/request/node_modules/uuid/lib/bytesToUuid.js\");\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvdXVpZC92NC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsNEVBQVc7QUFDN0Isa0JBQWtCLG1CQUFPLENBQUMsNEZBQW1COztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BhZ2UtZm9ybS8uL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy91dWlkL3Y0LmpzP2Q2MWIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHJuZyA9IHJlcXVpcmUoJy4vbGliL3JuZycpO1xudmFyIGJ5dGVzVG9VdWlkID0gcmVxdWlyZSgnLi9saWIvYnl0ZXNUb1V1aWQnKTtcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG5cbiAgaWYgKHR5cGVvZihvcHRpb25zKSA9PSAnc3RyaW5nJykge1xuICAgIGJ1ZiA9IG9wdGlvbnMgPT09ICdiaW5hcnknID8gbmV3IEFycmF5KDE2KSA6IG51bGw7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpO1xuXG4gIC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcbiAgcm5kc1s2XSA9IChybmRzWzZdICYgMHgwZikgfCAweDQwO1xuICBybmRzWzhdID0gKHJuZHNbOF0gJiAweDNmKSB8IDB4ODA7XG5cbiAgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG4gIGlmIChidWYpIHtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgMTY7ICsraWkpIHtcbiAgICAgIGJ1ZltpICsgaWldID0gcm5kc1tpaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZiB8fCBieXRlc1RvVXVpZChybmRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2NDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/request/node_modules/uuid/v4.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/request/request.js":
/*!*****************************************!*\
  !*** ./node_modules/request/request.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar http = __webpack_require__(/*! http */ \"http\")\nvar https = __webpack_require__(/*! https */ \"https\")\nvar url = __webpack_require__(/*! url */ \"url\")\nvar util = __webpack_require__(/*! util */ \"util\")\nvar stream = __webpack_require__(/*! stream */ \"stream\")\nvar zlib = __webpack_require__(/*! zlib */ \"zlib\")\nvar aws2 = __webpack_require__(/*! aws-sign2 */ \"(rsc)/./node_modules/aws-sign2/index.js\")\nvar aws4 = __webpack_require__(/*! aws4 */ \"(rsc)/./node_modules/aws4/aws4.js\")\nvar httpSignature = __webpack_require__(/*! http-signature */ \"(rsc)/./node_modules/http-signature/lib/index.js\")\nvar mime = __webpack_require__(/*! mime-types */ \"(rsc)/./node_modules/mime-types/index.js\")\nvar caseless = __webpack_require__(/*! caseless */ \"(rsc)/./node_modules/caseless/index.js\")\nvar ForeverAgent = __webpack_require__(/*! forever-agent */ \"(rsc)/./node_modules/forever-agent/index.js\")\nvar FormData = __webpack_require__(/*! form-data */ \"(rsc)/./node_modules/request/node_modules/form-data/lib/form_data.js\")\nvar extend = __webpack_require__(/*! extend */ \"(rsc)/./node_modules/extend/index.js\")\nvar isstream = __webpack_require__(/*! isstream */ \"(rsc)/./node_modules/isstream/isstream.js\")\nvar isTypedArray = (__webpack_require__(/*! is-typedarray */ \"(rsc)/./node_modules/is-typedarray/index.js\").strict)\nvar helpers = __webpack_require__(/*! ./lib/helpers */ \"(rsc)/./node_modules/request/lib/helpers.js\")\nvar cookies = __webpack_require__(/*! ./lib/cookies */ \"(rsc)/./node_modules/request/lib/cookies.js\")\nvar getProxyFromURI = __webpack_require__(/*! ./lib/getProxyFromURI */ \"(rsc)/./node_modules/request/lib/getProxyFromURI.js\")\nvar Querystring = (__webpack_require__(/*! ./lib/querystring */ \"(rsc)/./node_modules/request/lib/querystring.js\").Querystring)\nvar Har = (__webpack_require__(/*! ./lib/har */ \"(rsc)/./node_modules/request/lib/har.js\").Har)\nvar Auth = (__webpack_require__(/*! ./lib/auth */ \"(rsc)/./node_modules/request/lib/auth.js\").Auth)\nvar OAuth = (__webpack_require__(/*! ./lib/oauth */ \"(rsc)/./node_modules/request/lib/oauth.js\").OAuth)\nvar hawk = __webpack_require__(/*! ./lib/hawk */ \"(rsc)/./node_modules/request/lib/hawk.js\")\nvar Multipart = (__webpack_require__(/*! ./lib/multipart */ \"(rsc)/./node_modules/request/lib/multipart.js\").Multipart)\nvar Redirect = (__webpack_require__(/*! ./lib/redirect */ \"(rsc)/./node_modules/request/lib/redirect.js\").Redirect)\nvar Tunnel = (__webpack_require__(/*! ./lib/tunnel */ \"(rsc)/./node_modules/request/lib/tunnel.js\").Tunnel)\nvar now = __webpack_require__(/*! performance-now */ \"(rsc)/./node_modules/performance-now/lib/performance-now.js\")\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"(rsc)/./node_modules/safe-buffer/index.js\").Buffer)\n\nvar safeStringify = helpers.safeStringify\nvar isReadStream = helpers.isReadStream\nvar toBase64 = helpers.toBase64\nvar defer = helpers.defer\nvar copy = helpers.copy\nvar version = helpers.version\nvar globalCookieJar = cookies.jar()\n\nvar globalPool = {}\n\nfunction filterForNonReserved (reserved, options) {\n  // Filter out properties that are not reserved.\n  // Reserved values are passed in at call site.\n\n  var object = {}\n  for (var i in options) {\n    var notReserved = (reserved.indexOf(i) === -1)\n    if (notReserved) {\n      object[i] = options[i]\n    }\n  }\n  return object\n}\n\nfunction filterOutReservedFunctions (reserved, options) {\n  // Filter out properties that are functions and are reserved.\n  // Reserved values are passed in at call site.\n\n  var object = {}\n  for (var i in options) {\n    var isReserved = !(reserved.indexOf(i) === -1)\n    var isFunction = (typeof options[i] === 'function')\n    if (!(isReserved && isFunction)) {\n      object[i] = options[i]\n    }\n  }\n  return object\n}\n\n// Return a simpler request object to allow serialization\nfunction requestToJSON () {\n  var self = this\n  return {\n    uri: self.uri,\n    method: self.method,\n    headers: self.headers\n  }\n}\n\n// Return a simpler response object to allow serialization\nfunction responseToJSON () {\n  var self = this\n  return {\n    statusCode: self.statusCode,\n    body: self.body,\n    headers: self.headers,\n    request: requestToJSON.call(self.request)\n  }\n}\n\nfunction Request (options) {\n  // if given the method property in options, set property explicitMethod to true\n\n  // extend the Request instance with any non-reserved properties\n  // remove any reserved functions from the options object\n  // set Request instance to be readable and writable\n  // call init\n\n  var self = this\n\n  // start with HAR, then override with additional options\n  if (options.har) {\n    self._har = new Har(self)\n    options = self._har.options(options)\n  }\n\n  stream.Stream.call(self)\n  var reserved = Object.keys(Request.prototype)\n  var nonReserved = filterForNonReserved(reserved, options)\n\n  extend(self, nonReserved)\n  options = filterOutReservedFunctions(reserved, options)\n\n  self.readable = true\n  self.writable = true\n  if (options.method) {\n    self.explicitMethod = true\n  }\n  self._qs = new Querystring(self)\n  self._auth = new Auth(self)\n  self._oauth = new OAuth(self)\n  self._multipart = new Multipart(self)\n  self._redirect = new Redirect(self)\n  self._tunnel = new Tunnel(self)\n  self.init(options)\n}\n\nutil.inherits(Request, stream.Stream)\n\n// Debugging\nRequest.debug = process.env.NODE_DEBUG && /\\brequest\\b/.test(process.env.NODE_DEBUG)\nfunction debug () {\n  if (Request.debug) {\n    console.error('REQUEST %s', util.format.apply(util, arguments))\n  }\n}\nRequest.prototype.debug = debug\n\nRequest.prototype.init = function (options) {\n  // init() contains all the code to setup the request object.\n  // the actual outgoing request is not started until start() is called\n  // this function is called from both the constructor and on redirect.\n  var self = this\n  if (!options) {\n    options = {}\n  }\n  self.headers = self.headers ? copy(self.headers) : {}\n\n  // Delete headers with value undefined since they break\n  // ClientRequest.OutgoingMessage.setHeader in node 0.12\n  for (var headerName in self.headers) {\n    if (typeof self.headers[headerName] === 'undefined') {\n      delete self.headers[headerName]\n    }\n  }\n\n  caseless.httpify(self, self.headers)\n\n  if (!self.method) {\n    self.method = options.method || 'GET'\n  }\n  if (!self.localAddress) {\n    self.localAddress = options.localAddress\n  }\n\n  self._qs.init(options)\n\n  debug(options)\n  if (!self.pool && self.pool !== false) {\n    self.pool = globalPool\n  }\n  self.dests = self.dests || []\n  self.__isRequestRequest = true\n\n  // Protect against double callback\n  if (!self._callback && self.callback) {\n    self._callback = self.callback\n    self.callback = function () {\n      if (self._callbackCalled) {\n        return // Print a warning maybe?\n      }\n      self._callbackCalled = true\n      self._callback.apply(self, arguments)\n    }\n    self.on('error', self.callback.bind())\n    self.on('complete', self.callback.bind(self, null))\n  }\n\n  // People use this property instead all the time, so support it\n  if (!self.uri && self.url) {\n    self.uri = self.url\n    delete self.url\n  }\n\n  // If there's a baseUrl, then use it as the base URL (i.e. uri must be\n  // specified as a relative path and is appended to baseUrl).\n  if (self.baseUrl) {\n    if (typeof self.baseUrl !== 'string') {\n      return self.emit('error', new Error('options.baseUrl must be a string'))\n    }\n\n    if (typeof self.uri !== 'string') {\n      return self.emit('error', new Error('options.uri must be a string when using options.baseUrl'))\n    }\n\n    if (self.uri.indexOf('//') === 0 || self.uri.indexOf('://') !== -1) {\n      return self.emit('error', new Error('options.uri must be a path when using options.baseUrl'))\n    }\n\n    // Handle all cases to make sure that there's only one slash between\n    // baseUrl and uri.\n    var baseUrlEndsWithSlash = self.baseUrl.lastIndexOf('/') === self.baseUrl.length - 1\n    var uriStartsWithSlash = self.uri.indexOf('/') === 0\n\n    if (baseUrlEndsWithSlash && uriStartsWithSlash) {\n      self.uri = self.baseUrl + self.uri.slice(1)\n    } else if (baseUrlEndsWithSlash || uriStartsWithSlash) {\n      self.uri = self.baseUrl + self.uri\n    } else if (self.uri === '') {\n      self.uri = self.baseUrl\n    } else {\n      self.uri = self.baseUrl + '/' + self.uri\n    }\n    delete self.baseUrl\n  }\n\n  // A URI is needed by this point, emit error if we haven't been able to get one\n  if (!self.uri) {\n    return self.emit('error', new Error('options.uri is a required argument'))\n  }\n\n  // If a string URI/URL was given, parse it into a URL object\n  if (typeof self.uri === 'string') {\n    self.uri = url.parse(self.uri)\n  }\n\n  // Some URL objects are not from a URL parsed string and need href added\n  if (!self.uri.href) {\n    self.uri.href = url.format(self.uri)\n  }\n\n  // DEPRECATED: Warning for users of the old Unix Sockets URL Scheme\n  if (self.uri.protocol === 'unix:') {\n    return self.emit('error', new Error('`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`'))\n  }\n\n  // Support Unix Sockets\n  if (self.uri.host === 'unix') {\n    self.enableUnixSocket()\n  }\n\n  if (self.strictSSL === false) {\n    self.rejectUnauthorized = false\n  }\n\n  if (!self.uri.pathname) { self.uri.pathname = '/' }\n\n  if (!(self.uri.host || (self.uri.hostname && self.uri.port)) && !self.uri.isUnix) {\n    // Invalid URI: it may generate lot of bad errors, like 'TypeError: Cannot call method `indexOf` of undefined' in CookieJar\n    // Detect and reject it as soon as possible\n    var faultyUri = url.format(self.uri)\n    var message = 'Invalid URI \"' + faultyUri + '\"'\n    if (Object.keys(options).length === 0) {\n      // No option ? This can be the sign of a redirect\n      // As this is a case where the user cannot do anything (they didn't call request directly with this URL)\n      // they should be warned that it can be caused by a redirection (can save some hair)\n      message += '. This can be caused by a crappy redirection.'\n    }\n    // This error was fatal\n    self.abort()\n    return self.emit('error', new Error(message))\n  }\n\n  if (!self.hasOwnProperty('proxy')) {\n    self.proxy = getProxyFromURI(self.uri)\n  }\n\n  self.tunnel = self._tunnel.isEnabled()\n  if (self.proxy) {\n    self._tunnel.setup(options)\n  }\n\n  self._redirect.onRequest(options)\n\n  self.setHost = false\n  if (!self.hasHeader('host')) {\n    var hostHeaderName = self.originalHostHeaderName || 'host'\n    self.setHeader(hostHeaderName, self.uri.host)\n    // Drop :port suffix from Host header if known protocol.\n    if (self.uri.port) {\n      if ((self.uri.port === '80' && self.uri.protocol === 'http:') ||\n          (self.uri.port === '443' && self.uri.protocol === 'https:')) {\n        self.setHeader(hostHeaderName, self.uri.hostname)\n      }\n    }\n    self.setHost = true\n  }\n\n  self.jar(self._jar || options.jar)\n\n  if (!self.uri.port) {\n    if (self.uri.protocol === 'http:') { self.uri.port = 80 } else if (self.uri.protocol === 'https:') { self.uri.port = 443 }\n  }\n\n  if (self.proxy && !self.tunnel) {\n    self.port = self.proxy.port\n    self.host = self.proxy.hostname\n  } else {\n    self.port = self.uri.port\n    self.host = self.uri.hostname\n  }\n\n  if (options.form) {\n    self.form(options.form)\n  }\n\n  if (options.formData) {\n    var formData = options.formData\n    var requestForm = self.form()\n    var appendFormValue = function (key, value) {\n      if (value && value.hasOwnProperty('value') && value.hasOwnProperty('options')) {\n        requestForm.append(key, value.value, value.options)\n      } else {\n        requestForm.append(key, value)\n      }\n    }\n    for (var formKey in formData) {\n      if (formData.hasOwnProperty(formKey)) {\n        var formValue = formData[formKey]\n        if (formValue instanceof Array) {\n          for (var j = 0; j < formValue.length; j++) {\n            appendFormValue(formKey, formValue[j])\n          }\n        } else {\n          appendFormValue(formKey, formValue)\n        }\n      }\n    }\n  }\n\n  if (options.qs) {\n    self.qs(options.qs)\n  }\n\n  if (self.uri.path) {\n    self.path = self.uri.path\n  } else {\n    self.path = self.uri.pathname + (self.uri.search || '')\n  }\n\n  if (self.path.length === 0) {\n    self.path = '/'\n  }\n\n  // Auth must happen last in case signing is dependent on other headers\n  if (options.aws) {\n    self.aws(options.aws)\n  }\n\n  if (options.hawk) {\n    self.hawk(options.hawk)\n  }\n\n  if (options.httpSignature) {\n    self.httpSignature(options.httpSignature)\n  }\n\n  if (options.auth) {\n    if (Object.prototype.hasOwnProperty.call(options.auth, 'username')) {\n      options.auth.user = options.auth.username\n    }\n    if (Object.prototype.hasOwnProperty.call(options.auth, 'password')) {\n      options.auth.pass = options.auth.password\n    }\n\n    self.auth(\n      options.auth.user,\n      options.auth.pass,\n      options.auth.sendImmediately,\n      options.auth.bearer\n    )\n  }\n\n  if (self.gzip && !self.hasHeader('accept-encoding')) {\n    self.setHeader('accept-encoding', 'gzip, deflate')\n  }\n\n  if (self.uri.auth && !self.hasHeader('authorization')) {\n    var uriAuthPieces = self.uri.auth.split(':').map(function (item) { return self._qs.unescape(item) })\n    self.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(':'), true)\n  }\n\n  if (!self.tunnel && self.proxy && self.proxy.auth && !self.hasHeader('proxy-authorization')) {\n    var proxyAuthPieces = self.proxy.auth.split(':').map(function (item) { return self._qs.unescape(item) })\n    var authHeader = 'Basic ' + toBase64(proxyAuthPieces.join(':'))\n    self.setHeader('proxy-authorization', authHeader)\n  }\n\n  if (self.proxy && !self.tunnel) {\n    self.path = (self.uri.protocol + '//' + self.uri.host + self.path)\n  }\n\n  if (options.json) {\n    self.json(options.json)\n  }\n  if (options.multipart) {\n    self.multipart(options.multipart)\n  }\n\n  if (options.time) {\n    self.timing = true\n\n    // NOTE: elapsedTime is deprecated in favor of .timings\n    self.elapsedTime = self.elapsedTime || 0\n  }\n\n  function setContentLength () {\n    if (isTypedArray(self.body)) {\n      self.body = Buffer.from(self.body)\n    }\n\n    if (!self.hasHeader('content-length')) {\n      var length\n      if (typeof self.body === 'string') {\n        length = Buffer.byteLength(self.body)\n      } else if (Array.isArray(self.body)) {\n        length = self.body.reduce(function (a, b) { return a + b.length }, 0)\n      } else {\n        length = self.body.length\n      }\n\n      if (length) {\n        self.setHeader('content-length', length)\n      } else {\n        self.emit('error', new Error('Argument error, options.body.'))\n      }\n    }\n  }\n  if (self.body && !isstream(self.body)) {\n    setContentLength()\n  }\n\n  if (options.oauth) {\n    self.oauth(options.oauth)\n  } else if (self._oauth.params && self.hasHeader('authorization')) {\n    self.oauth(self._oauth.params)\n  }\n\n  var protocol = self.proxy && !self.tunnel ? self.proxy.protocol : self.uri.protocol\n  var defaultModules = {'http:': http, 'https:': https}\n  var httpModules = self.httpModules || {}\n\n  self.httpModule = httpModules[protocol] || defaultModules[protocol]\n\n  if (!self.httpModule) {\n    return self.emit('error', new Error('Invalid protocol: ' + protocol))\n  }\n\n  if (options.ca) {\n    self.ca = options.ca\n  }\n\n  if (!self.agent) {\n    if (options.agentOptions) {\n      self.agentOptions = options.agentOptions\n    }\n\n    if (options.agentClass) {\n      self.agentClass = options.agentClass\n    } else if (options.forever) {\n      var v = version()\n      // use ForeverAgent in node 0.10- only\n      if (v.major === 0 && v.minor <= 10) {\n        self.agentClass = protocol === 'http:' ? ForeverAgent : ForeverAgent.SSL\n      } else {\n        self.agentClass = self.httpModule.Agent\n        self.agentOptions = self.agentOptions || {}\n        self.agentOptions.keepAlive = true\n      }\n    } else {\n      self.agentClass = self.httpModule.Agent\n    }\n  }\n\n  if (self.pool === false) {\n    self.agent = false\n  } else {\n    self.agent = self.agent || self.getNewAgent()\n  }\n\n  self.on('pipe', function (src) {\n    if (self.ntick && self._started) {\n      self.emit('error', new Error('You cannot pipe to this stream after the outbound request has started.'))\n    }\n    self.src = src\n    if (isReadStream(src)) {\n      if (!self.hasHeader('content-type')) {\n        self.setHeader('content-type', mime.lookup(src.path))\n      }\n    } else {\n      if (src.headers) {\n        for (var i in src.headers) {\n          if (!self.hasHeader(i)) {\n            self.setHeader(i, src.headers[i])\n          }\n        }\n      }\n      if (self._json && !self.hasHeader('content-type')) {\n        self.setHeader('content-type', 'application/json')\n      }\n      if (src.method && !self.explicitMethod) {\n        self.method = src.method\n      }\n    }\n\n  // self.on('pipe', function () {\n  //   console.error('You have already piped to this stream. Pipeing twice is likely to break the request.')\n  // })\n  })\n\n  defer(function () {\n    if (self._aborted) {\n      return\n    }\n\n    var end = function () {\n      if (self._form) {\n        if (!self._auth.hasAuth) {\n          self._form.pipe(self)\n        } else if (self._auth.hasAuth && self._auth.sentAuth) {\n          self._form.pipe(self)\n        }\n      }\n      if (self._multipart && self._multipart.chunked) {\n        self._multipart.body.pipe(self)\n      }\n      if (self.body) {\n        if (isstream(self.body)) {\n          self.body.pipe(self)\n        } else {\n          setContentLength()\n          if (Array.isArray(self.body)) {\n            self.body.forEach(function (part) {\n              self.write(part)\n            })\n          } else {\n            self.write(self.body)\n          }\n          self.end()\n        }\n      } else if (self.requestBodyStream) {\n        console.warn('options.requestBodyStream is deprecated, please pass the request object to stream.pipe.')\n        self.requestBodyStream.pipe(self)\n      } else if (!self.src) {\n        if (self._auth.hasAuth && !self._auth.sentAuth) {\n          self.end()\n          return\n        }\n        if (self.method !== 'GET' && typeof self.method !== 'undefined') {\n          self.setHeader('content-length', 0)\n        }\n        self.end()\n      }\n    }\n\n    if (self._form && !self.hasHeader('content-length')) {\n      // Before ending the request, we had to compute the length of the whole form, asyncly\n      self.setHeader(self._form.getHeaders(), true)\n      self._form.getLength(function (err, length) {\n        if (!err && !isNaN(length)) {\n          self.setHeader('content-length', length)\n        }\n        end()\n      })\n    } else {\n      end()\n    }\n\n    self.ntick = true\n  })\n}\n\nRequest.prototype.getNewAgent = function () {\n  var self = this\n  var Agent = self.agentClass\n  var options = {}\n  if (self.agentOptions) {\n    for (var i in self.agentOptions) {\n      options[i] = self.agentOptions[i]\n    }\n  }\n  if (self.ca) {\n    options.ca = self.ca\n  }\n  if (self.ciphers) {\n    options.ciphers = self.ciphers\n  }\n  if (self.secureProtocol) {\n    options.secureProtocol = self.secureProtocol\n  }\n  if (self.secureOptions) {\n    options.secureOptions = self.secureOptions\n  }\n  if (typeof self.rejectUnauthorized !== 'undefined') {\n    options.rejectUnauthorized = self.rejectUnauthorized\n  }\n\n  if (self.cert && self.key) {\n    options.key = self.key\n    options.cert = self.cert\n  }\n\n  if (self.pfx) {\n    options.pfx = self.pfx\n  }\n\n  if (self.passphrase) {\n    options.passphrase = self.passphrase\n  }\n\n  var poolKey = ''\n\n  // different types of agents are in different pools\n  if (Agent !== self.httpModule.Agent) {\n    poolKey += Agent.name\n  }\n\n  // ca option is only relevant if proxy or destination are https\n  var proxy = self.proxy\n  if (typeof proxy === 'string') {\n    proxy = url.parse(proxy)\n  }\n  var isHttps = (proxy && proxy.protocol === 'https:') || this.uri.protocol === 'https:'\n\n  if (isHttps) {\n    if (options.ca) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.ca\n    }\n\n    if (typeof options.rejectUnauthorized !== 'undefined') {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.rejectUnauthorized\n    }\n\n    if (options.cert) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.cert.toString('ascii') + options.key.toString('ascii')\n    }\n\n    if (options.pfx) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.pfx.toString('ascii')\n    }\n\n    if (options.ciphers) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.ciphers\n    }\n\n    if (options.secureProtocol) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.secureProtocol\n    }\n\n    if (options.secureOptions) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.secureOptions\n    }\n  }\n\n  if (self.pool === globalPool && !poolKey && Object.keys(options).length === 0 && self.httpModule.globalAgent) {\n    // not doing anything special.  Use the globalAgent\n    return self.httpModule.globalAgent\n  }\n\n  // we're using a stored agent.  Make sure it's protocol-specific\n  poolKey = self.uri.protocol + poolKey\n\n  // generate a new agent for this setting if none yet exists\n  if (!self.pool[poolKey]) {\n    self.pool[poolKey] = new Agent(options)\n    // properly set maxSockets on new agents\n    if (self.pool.maxSockets) {\n      self.pool[poolKey].maxSockets = self.pool.maxSockets\n    }\n  }\n\n  return self.pool[poolKey]\n}\n\nRequest.prototype.start = function () {\n  // start() is called once we are ready to send the outgoing HTTP request.\n  // this is usually called on the first write(), end() or on nextTick()\n  var self = this\n\n  if (self.timing) {\n    // All timings will be relative to this request's startTime.  In order to do this,\n    // we need to capture the wall-clock start time (via Date), immediately followed\n    // by the high-resolution timer (via now()).  While these two won't be set\n    // at the _exact_ same time, they should be close enough to be able to calculate\n    // high-resolution, monotonically non-decreasing timestamps relative to startTime.\n    var startTime = new Date().getTime()\n    var startTimeNow = now()\n  }\n\n  if (self._aborted) {\n    return\n  }\n\n  self._started = true\n  self.method = self.method || 'GET'\n  self.href = self.uri.href\n\n  if (self.src && self.src.stat && self.src.stat.size && !self.hasHeader('content-length')) {\n    self.setHeader('content-length', self.src.stat.size)\n  }\n  if (self._aws) {\n    self.aws(self._aws, true)\n  }\n\n  // We have a method named auth, which is completely different from the http.request\n  // auth option.  If we don't remove it, we're gonna have a bad time.\n  var reqOptions = copy(self)\n  delete reqOptions.auth\n\n  debug('make request', self.uri.href)\n\n  // node v6.8.0 now supports a `timeout` value in `http.request()`, but we\n  // should delete it for now since we handle timeouts manually for better\n  // consistency with node versions before v6.8.0\n  delete reqOptions.timeout\n\n  try {\n    self.req = self.httpModule.request(reqOptions)\n  } catch (err) {\n    self.emit('error', err)\n    return\n  }\n\n  if (self.timing) {\n    self.startTime = startTime\n    self.startTimeNow = startTimeNow\n\n    // Timing values will all be relative to startTime (by comparing to startTimeNow\n    // so we have an accurate clock)\n    self.timings = {}\n  }\n\n  var timeout\n  if (self.timeout && !self.timeoutTimer) {\n    if (self.timeout < 0) {\n      timeout = 0\n    } else if (typeof self.timeout === 'number' && isFinite(self.timeout)) {\n      timeout = self.timeout\n    }\n  }\n\n  self.req.on('response', self.onRequestResponse.bind(self))\n  self.req.on('error', self.onRequestError.bind(self))\n  self.req.on('drain', function () {\n    self.emit('drain')\n  })\n\n  self.req.on('socket', function (socket) {\n    // `._connecting` was the old property which was made public in node v6.1.0\n    var isConnecting = socket._connecting || socket.connecting\n    if (self.timing) {\n      self.timings.socket = now() - self.startTimeNow\n\n      if (isConnecting) {\n        var onLookupTiming = function () {\n          self.timings.lookup = now() - self.startTimeNow\n        }\n\n        var onConnectTiming = function () {\n          self.timings.connect = now() - self.startTimeNow\n        }\n\n        socket.once('lookup', onLookupTiming)\n        socket.once('connect', onConnectTiming)\n\n        // clean up timing event listeners if needed on error\n        self.req.once('error', function () {\n          socket.removeListener('lookup', onLookupTiming)\n          socket.removeListener('connect', onConnectTiming)\n        })\n      }\n    }\n\n    var setReqTimeout = function () {\n      // This timeout sets the amount of time to wait *between* bytes sent\n      // from the server once connected.\n      //\n      // In particular, it's useful for erroring if the server fails to send\n      // data halfway through streaming a response.\n      self.req.setTimeout(timeout, function () {\n        if (self.req) {\n          self.abort()\n          var e = new Error('ESOCKETTIMEDOUT')\n          e.code = 'ESOCKETTIMEDOUT'\n          e.connect = false\n          self.emit('error', e)\n        }\n      })\n    }\n    if (timeout !== undefined) {\n      // Only start the connection timer if we're actually connecting a new\n      // socket, otherwise if we're already connected (because this is a\n      // keep-alive connection) do not bother. This is important since we won't\n      // get a 'connect' event for an already connected socket.\n      if (isConnecting) {\n        var onReqSockConnect = function () {\n          socket.removeListener('connect', onReqSockConnect)\n          self.clearTimeout()\n          setReqTimeout()\n        }\n\n        socket.on('connect', onReqSockConnect)\n\n        self.req.on('error', function (err) { // eslint-disable-line handle-callback-err\n          socket.removeListener('connect', onReqSockConnect)\n        })\n\n        // Set a timeout in memory - this block will throw if the server takes more\n        // than `timeout` to write the HTTP status and headers (corresponding to\n        // the on('response') event on the client). NB: this measures wall-clock\n        // time, not the time between bytes sent by the server.\n        self.timeoutTimer = setTimeout(function () {\n          socket.removeListener('connect', onReqSockConnect)\n          self.abort()\n          var e = new Error('ETIMEDOUT')\n          e.code = 'ETIMEDOUT'\n          e.connect = true\n          self.emit('error', e)\n        }, timeout)\n      } else {\n        // We're already connected\n        setReqTimeout()\n      }\n    }\n    self.emit('socket', socket)\n  })\n\n  self.emit('request', self.req)\n}\n\nRequest.prototype.onRequestError = function (error) {\n  var self = this\n  if (self._aborted) {\n    return\n  }\n  if (self.req && self.req._reusedSocket && error.code === 'ECONNRESET' &&\n    self.agent.addRequestNoreuse) {\n    self.agent = { addRequest: self.agent.addRequestNoreuse.bind(self.agent) }\n    self.start()\n    self.req.end()\n    return\n  }\n  self.clearTimeout()\n  self.emit('error', error)\n}\n\nRequest.prototype.onRequestResponse = function (response) {\n  var self = this\n\n  if (self.timing) {\n    self.timings.response = now() - self.startTimeNow\n  }\n\n  debug('onRequestResponse', self.uri.href, response.statusCode, response.headers)\n  response.on('end', function () {\n    if (self.timing) {\n      self.timings.end = now() - self.startTimeNow\n      response.timingStart = self.startTime\n\n      // fill in the blanks for any periods that didn't trigger, such as\n      // no lookup or connect due to keep alive\n      if (!self.timings.socket) {\n        self.timings.socket = 0\n      }\n      if (!self.timings.lookup) {\n        self.timings.lookup = self.timings.socket\n      }\n      if (!self.timings.connect) {\n        self.timings.connect = self.timings.lookup\n      }\n      if (!self.timings.response) {\n        self.timings.response = self.timings.connect\n      }\n\n      debug('elapsed time', self.timings.end)\n\n      // elapsedTime includes all redirects\n      self.elapsedTime += Math.round(self.timings.end)\n\n      // NOTE: elapsedTime is deprecated in favor of .timings\n      response.elapsedTime = self.elapsedTime\n\n      // timings is just for the final fetch\n      response.timings = self.timings\n\n      // pre-calculate phase timings as well\n      response.timingPhases = {\n        wait: self.timings.socket,\n        dns: self.timings.lookup - self.timings.socket,\n        tcp: self.timings.connect - self.timings.lookup,\n        firstByte: self.timings.response - self.timings.connect,\n        download: self.timings.end - self.timings.response,\n        total: self.timings.end\n      }\n    }\n    debug('response end', self.uri.href, response.statusCode, response.headers)\n  })\n\n  if (self._aborted) {\n    debug('aborted', self.uri.href)\n    response.resume()\n    return\n  }\n\n  self.response = response\n  response.request = self\n  response.toJSON = responseToJSON\n\n  // XXX This is different on 0.10, because SSL is strict by default\n  if (self.httpModule === https &&\n    self.strictSSL && (!response.hasOwnProperty('socket') ||\n    !response.socket.authorized)) {\n    debug('strict ssl error', self.uri.href)\n    var sslErr = response.hasOwnProperty('socket') ? response.socket.authorizationError : self.uri.href + ' does not support SSL'\n    self.emit('error', new Error('SSL Error: ' + sslErr))\n    return\n  }\n\n  // Save the original host before any redirect (if it changes, we need to\n  // remove any authorization headers).  Also remember the case of the header\n  // name because lots of broken servers expect Host instead of host and we\n  // want the caller to be able to specify this.\n  self.originalHost = self.getHeader('host')\n  if (!self.originalHostHeaderName) {\n    self.originalHostHeaderName = self.hasHeader('host')\n  }\n  if (self.setHost) {\n    self.removeHeader('host')\n  }\n  self.clearTimeout()\n\n  var targetCookieJar = (self._jar && self._jar.setCookie) ? self._jar : globalCookieJar\n  var addCookie = function (cookie) {\n    // set the cookie if it's domain in the href's domain.\n    try {\n      targetCookieJar.setCookie(cookie, self.uri.href, {ignoreError: true})\n    } catch (e) {\n      self.emit('error', e)\n    }\n  }\n\n  response.caseless = caseless(response.headers)\n\n  if (response.caseless.has('set-cookie') && (!self._disableCookies)) {\n    var headerName = response.caseless.has('set-cookie')\n    if (Array.isArray(response.headers[headerName])) {\n      response.headers[headerName].forEach(addCookie)\n    } else {\n      addCookie(response.headers[headerName])\n    }\n  }\n\n  if (self._redirect.onResponse(response)) {\n    return // Ignore the rest of the response\n  } else {\n    // Be a good stream and emit end when the response is finished.\n    // Hack to emit end on close because of a core bug that never fires end\n    response.on('close', function () {\n      if (!self._ended) {\n        self.response.emit('end')\n      }\n    })\n\n    response.once('end', function () {\n      self._ended = true\n    })\n\n    var noBody = function (code) {\n      return (\n        self.method === 'HEAD' ||\n        // Informational\n        (code >= 100 && code < 200) ||\n        // No Content\n        code === 204 ||\n        // Not Modified\n        code === 304\n      )\n    }\n\n    var responseContent\n    if (self.gzip && !noBody(response.statusCode)) {\n      var contentEncoding = response.headers['content-encoding'] || 'identity'\n      contentEncoding = contentEncoding.trim().toLowerCase()\n\n      // Be more lenient with decoding compressed responses, since (very rarely)\n      // servers send slightly invalid gzip responses that are still accepted\n      // by common browsers.\n      // Always using Z_SYNC_FLUSH is what cURL does.\n      var zlibOptions = {\n        flush: zlib.Z_SYNC_FLUSH,\n        finishFlush: zlib.Z_SYNC_FLUSH\n      }\n\n      if (contentEncoding === 'gzip') {\n        responseContent = zlib.createGunzip(zlibOptions)\n        response.pipe(responseContent)\n      } else if (contentEncoding === 'deflate') {\n        responseContent = zlib.createInflate(zlibOptions)\n        response.pipe(responseContent)\n      } else {\n        // Since previous versions didn't check for Content-Encoding header,\n        // ignore any invalid values to preserve backwards-compatibility\n        if (contentEncoding !== 'identity') {\n          debug('ignoring unrecognized Content-Encoding ' + contentEncoding)\n        }\n        responseContent = response\n      }\n    } else {\n      responseContent = response\n    }\n\n    if (self.encoding) {\n      if (self.dests.length !== 0) {\n        console.error('Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.')\n      } else {\n        responseContent.setEncoding(self.encoding)\n      }\n    }\n\n    if (self._paused) {\n      responseContent.pause()\n    }\n\n    self.responseContent = responseContent\n\n    self.emit('response', response)\n\n    self.dests.forEach(function (dest) {\n      self.pipeDest(dest)\n    })\n\n    responseContent.on('data', function (chunk) {\n      if (self.timing && !self.responseStarted) {\n        self.responseStartTime = (new Date()).getTime()\n\n        // NOTE: responseStartTime is deprecated in favor of .timings\n        response.responseStartTime = self.responseStartTime\n      }\n      self._destdata = true\n      self.emit('data', chunk)\n    })\n    responseContent.once('end', function (chunk) {\n      self.emit('end', chunk)\n    })\n    responseContent.on('error', function (error) {\n      self.emit('error', error)\n    })\n    responseContent.on('close', function () { self.emit('close') })\n\n    if (self.callback) {\n      self.readResponseBody(response)\n    } else { // if no callback\n      self.on('end', function () {\n        if (self._aborted) {\n          debug('aborted', self.uri.href)\n          return\n        }\n        self.emit('complete', response)\n      })\n    }\n  }\n  debug('finish init function', self.uri.href)\n}\n\nRequest.prototype.readResponseBody = function (response) {\n  var self = this\n  debug(\"reading response's body\")\n  var buffers = []\n  var bufferLength = 0\n  var strings = []\n\n  self.on('data', function (chunk) {\n    if (!Buffer.isBuffer(chunk)) {\n      strings.push(chunk)\n    } else if (chunk.length) {\n      bufferLength += chunk.length\n      buffers.push(chunk)\n    }\n  })\n  self.on('end', function () {\n    debug('end event', self.uri.href)\n    if (self._aborted) {\n      debug('aborted', self.uri.href)\n      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the request.\n      // This can lead to leaky behavior if the user retains a reference to the request object.\n      buffers = []\n      bufferLength = 0\n      return\n    }\n\n    if (bufferLength) {\n      debug('has body', self.uri.href, bufferLength)\n      response.body = Buffer.concat(buffers, bufferLength)\n      if (self.encoding !== null) {\n        response.body = response.body.toString(self.encoding)\n      }\n      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the Request.\n      // This can lead to leaky behavior if the user retains a reference to the request object.\n      buffers = []\n      bufferLength = 0\n    } else if (strings.length) {\n      // The UTF8 BOM [0xEF,0xBB,0xBF] is converted to [0xFE,0xFF] in the JS UTC16/UCS2 representation.\n      // Strip this value out when the encoding is set to 'utf8', as upstream consumers won't expect it and it breaks JSON.parse().\n      if (self.encoding === 'utf8' && strings[0].length > 0 && strings[0][0] === '\\uFEFF') {\n        strings[0] = strings[0].substring(1)\n      }\n      response.body = strings.join('')\n    }\n\n    if (self._json) {\n      try {\n        response.body = JSON.parse(response.body, self._jsonReviver)\n      } catch (e) {\n        debug('invalid JSON received', self.uri.href)\n      }\n    }\n    debug('emitting complete', self.uri.href)\n    if (typeof response.body === 'undefined' && !self._json) {\n      response.body = self.encoding === null ? Buffer.alloc(0) : ''\n    }\n    self.emit('complete', response, response.body)\n  })\n}\n\nRequest.prototype.abort = function () {\n  var self = this\n  self._aborted = true\n\n  if (self.req) {\n    self.req.abort()\n  } else if (self.response) {\n    self.response.destroy()\n  }\n\n  self.clearTimeout()\n  self.emit('abort')\n}\n\nRequest.prototype.pipeDest = function (dest) {\n  var self = this\n  var response = self.response\n  // Called after the response is received\n  if (dest.headers && !dest.headersSent) {\n    if (response.caseless.has('content-type')) {\n      var ctname = response.caseless.has('content-type')\n      if (dest.setHeader) {\n        dest.setHeader(ctname, response.headers[ctname])\n      } else {\n        dest.headers[ctname] = response.headers[ctname]\n      }\n    }\n\n    if (response.caseless.has('content-length')) {\n      var clname = response.caseless.has('content-length')\n      if (dest.setHeader) {\n        dest.setHeader(clname, response.headers[clname])\n      } else {\n        dest.headers[clname] = response.headers[clname]\n      }\n    }\n  }\n  if (dest.setHeader && !dest.headersSent) {\n    for (var i in response.headers) {\n      // If the response content is being decoded, the Content-Encoding header\n      // of the response doesn't represent the piped content, so don't pass it.\n      if (!self.gzip || i !== 'content-encoding') {\n        dest.setHeader(i, response.headers[i])\n      }\n    }\n    dest.statusCode = response.statusCode\n  }\n  if (self.pipefilter) {\n    self.pipefilter(response, dest)\n  }\n}\n\nRequest.prototype.qs = function (q, clobber) {\n  var self = this\n  var base\n  if (!clobber && self.uri.query) {\n    base = self._qs.parse(self.uri.query)\n  } else {\n    base = {}\n  }\n\n  for (var i in q) {\n    base[i] = q[i]\n  }\n\n  var qs = self._qs.stringify(base)\n\n  if (qs === '') {\n    return self\n  }\n\n  self.uri = url.parse(self.uri.href.split('?')[0] + '?' + qs)\n  self.url = self.uri\n  self.path = self.uri.path\n\n  if (self.uri.host === 'unix') {\n    self.enableUnixSocket()\n  }\n\n  return self\n}\nRequest.prototype.form = function (form) {\n  var self = this\n  if (form) {\n    if (!/^application\\/x-www-form-urlencoded\\b/.test(self.getHeader('content-type'))) {\n      self.setHeader('content-type', 'application/x-www-form-urlencoded')\n    }\n    self.body = (typeof form === 'string')\n      ? self._qs.rfc3986(form.toString('utf8'))\n      : self._qs.stringify(form).toString('utf8')\n    return self\n  }\n  // create form-data object\n  self._form = new FormData()\n  self._form.on('error', function (err) {\n    err.message = 'form-data: ' + err.message\n    self.emit('error', err)\n    self.abort()\n  })\n  return self._form\n}\nRequest.prototype.multipart = function (multipart) {\n  var self = this\n\n  self._multipart.onRequest(multipart)\n\n  if (!self._multipart.chunked) {\n    self.body = self._multipart.body\n  }\n\n  return self\n}\nRequest.prototype.json = function (val) {\n  var self = this\n\n  if (!self.hasHeader('accept')) {\n    self.setHeader('accept', 'application/json')\n  }\n\n  if (typeof self.jsonReplacer === 'function') {\n    self._jsonReplacer = self.jsonReplacer\n  }\n\n  self._json = true\n  if (typeof val === 'boolean') {\n    if (self.body !== undefined) {\n      if (!/^application\\/x-www-form-urlencoded\\b/.test(self.getHeader('content-type'))) {\n        self.body = safeStringify(self.body, self._jsonReplacer)\n      } else {\n        self.body = self._qs.rfc3986(self.body)\n      }\n      if (!self.hasHeader('content-type')) {\n        self.setHeader('content-type', 'application/json')\n      }\n    }\n  } else {\n    self.body = safeStringify(val, self._jsonReplacer)\n    if (!self.hasHeader('content-type')) {\n      self.setHeader('content-type', 'application/json')\n    }\n  }\n\n  if (typeof self.jsonReviver === 'function') {\n    self._jsonReviver = self.jsonReviver\n  }\n\n  return self\n}\nRequest.prototype.getHeader = function (name, headers) {\n  var self = this\n  var result, re, match\n  if (!headers) {\n    headers = self.headers\n  }\n  Object.keys(headers).forEach(function (key) {\n    if (key.length !== name.length) {\n      return\n    }\n    re = new RegExp(name, 'i')\n    match = key.match(re)\n    if (match) {\n      result = headers[key]\n    }\n  })\n  return result\n}\nRequest.prototype.enableUnixSocket = function () {\n  // Get the socket & request paths from the URL\n  var unixParts = this.uri.path.split(':')\n  var host = unixParts[0]\n  var path = unixParts[1]\n  // Apply unix properties to request\n  this.socketPath = host\n  this.uri.pathname = path\n  this.uri.path = path\n  this.uri.host = host\n  this.uri.hostname = host\n  this.uri.isUnix = true\n}\n\nRequest.prototype.auth = function (user, pass, sendImmediately, bearer) {\n  var self = this\n\n  self._auth.onRequest(user, pass, sendImmediately, bearer)\n\n  return self\n}\nRequest.prototype.aws = function (opts, now) {\n  var self = this\n\n  if (!now) {\n    self._aws = opts\n    return self\n  }\n\n  if (opts.sign_version === 4 || opts.sign_version === '4') {\n    // use aws4\n    var options = {\n      host: self.uri.host,\n      path: self.uri.path,\n      method: self.method,\n      headers: self.headers,\n      body: self.body\n    }\n    if (opts.service) {\n      options.service = opts.service\n    }\n    var signRes = aws4.sign(options, {\n      accessKeyId: opts.key,\n      secretAccessKey: opts.secret,\n      sessionToken: opts.session\n    })\n    self.setHeader('authorization', signRes.headers.Authorization)\n    self.setHeader('x-amz-date', signRes.headers['X-Amz-Date'])\n    if (signRes.headers['X-Amz-Security-Token']) {\n      self.setHeader('x-amz-security-token', signRes.headers['X-Amz-Security-Token'])\n    }\n  } else {\n    // default: use aws-sign2\n    var date = new Date()\n    self.setHeader('date', date.toUTCString())\n    var auth = {\n      key: opts.key,\n      secret: opts.secret,\n      verb: self.method.toUpperCase(),\n      date: date,\n      contentType: self.getHeader('content-type') || '',\n      md5: self.getHeader('content-md5') || '',\n      amazonHeaders: aws2.canonicalizeHeaders(self.headers)\n    }\n    var path = self.uri.path\n    if (opts.bucket && path) {\n      auth.resource = '/' + opts.bucket + path\n    } else if (opts.bucket && !path) {\n      auth.resource = '/' + opts.bucket\n    } else if (!opts.bucket && path) {\n      auth.resource = path\n    } else if (!opts.bucket && !path) {\n      auth.resource = '/'\n    }\n    auth.resource = aws2.canonicalizeResource(auth.resource)\n    self.setHeader('authorization', aws2.authorization(auth))\n  }\n\n  return self\n}\nRequest.prototype.httpSignature = function (opts) {\n  var self = this\n  httpSignature.signRequest({\n    getHeader: function (header) {\n      return self.getHeader(header, self.headers)\n    },\n    setHeader: function (header, value) {\n      self.setHeader(header, value)\n    },\n    method: self.method,\n    path: self.path\n  }, opts)\n  debug('httpSignature authorization', self.getHeader('authorization'))\n\n  return self\n}\nRequest.prototype.hawk = function (opts) {\n  var self = this\n  self.setHeader('Authorization', hawk.header(self.uri, self.method, opts))\n}\nRequest.prototype.oauth = function (_oauth) {\n  var self = this\n\n  self._oauth.onRequest(_oauth)\n\n  return self\n}\n\nRequest.prototype.jar = function (jar) {\n  var self = this\n  var cookies\n\n  if (self._redirect.redirectsFollowed === 0) {\n    self.originalCookieHeader = self.getHeader('cookie')\n  }\n\n  if (!jar) {\n    // disable cookies\n    cookies = false\n    self._disableCookies = true\n  } else {\n    var targetCookieJar = jar.getCookieString ? jar : globalCookieJar\n    var urihref = self.uri.href\n    // fetch cookie in the Specified host\n    if (targetCookieJar) {\n      cookies = targetCookieJar.getCookieString(urihref)\n    }\n  }\n\n  // if need cookie and cookie is not empty\n  if (cookies && cookies.length) {\n    if (self.originalCookieHeader) {\n      // Don't overwrite existing Cookie header\n      self.setHeader('cookie', self.originalCookieHeader + '; ' + cookies)\n    } else {\n      self.setHeader('cookie', cookies)\n    }\n  }\n  self._jar = jar\n  return self\n}\n\n// Stream API\nRequest.prototype.pipe = function (dest, opts) {\n  var self = this\n\n  if (self.response) {\n    if (self._destdata) {\n      self.emit('error', new Error('You cannot pipe after data has been emitted from the response.'))\n    } else if (self._ended) {\n      self.emit('error', new Error('You cannot pipe after the response has been ended.'))\n    } else {\n      stream.Stream.prototype.pipe.call(self, dest, opts)\n      self.pipeDest(dest)\n      return dest\n    }\n  } else {\n    self.dests.push(dest)\n    stream.Stream.prototype.pipe.call(self, dest, opts)\n    return dest\n  }\n}\nRequest.prototype.write = function () {\n  var self = this\n  if (self._aborted) { return }\n\n  if (!self._started) {\n    self.start()\n  }\n  if (self.req) {\n    return self.req.write.apply(self.req, arguments)\n  }\n}\nRequest.prototype.end = function (chunk) {\n  var self = this\n  if (self._aborted) { return }\n\n  if (chunk) {\n    self.write(chunk)\n  }\n  if (!self._started) {\n    self.start()\n  }\n  if (self.req) {\n    self.req.end()\n  }\n}\nRequest.prototype.pause = function () {\n  var self = this\n  if (!self.responseContent) {\n    self._paused = true\n  } else {\n    self.responseContent.pause.apply(self.responseContent, arguments)\n  }\n}\nRequest.prototype.resume = function () {\n  var self = this\n  if (!self.responseContent) {\n    self._paused = false\n  } else {\n    self.responseContent.resume.apply(self.responseContent, arguments)\n  }\n}\nRequest.prototype.destroy = function () {\n  var self = this\n  this.clearTimeout()\n  if (!self._ended) {\n    self.end()\n  } else if (self.response) {\n    self.response.destroy()\n  }\n}\n\nRequest.prototype.clearTimeout = function () {\n  if (this.timeoutTimer) {\n    clearTimeout(this.timeoutTimer)\n    this.timeoutTimer = null\n  }\n}\n\nRequest.defaultProxyHeaderWhiteList =\n  Tunnel.defaultProxyHeaderWhiteList.slice()\n\nRequest.defaultProxyHeaderExclusiveList =\n  Tunnel.defaultProxyHeaderExclusiveList.slice()\n\n// Exports\n\nRequest.prototype.toJSON = requestToJSON\nmodule.exports = Request\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9yZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixZQUFZLG1CQUFPLENBQUMsb0JBQU87QUFDM0IsVUFBVSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3ZCLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLFdBQVcsbUJBQU8sQ0FBQywwREFBVztBQUM5QixXQUFXLG1CQUFPLENBQUMsK0NBQU07QUFDekIsb0JBQW9CLG1CQUFPLENBQUMsd0VBQWdCO0FBQzVDLFdBQVcsbUJBQU8sQ0FBQyw0REFBWTtBQUMvQixlQUFlLG1CQUFPLENBQUMsd0RBQVU7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMsa0VBQWU7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLHVGQUFXO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxvREFBUTtBQUM3QixlQUFlLG1CQUFPLENBQUMsMkRBQVU7QUFDakMsbUJBQW1CLGdHQUErQjtBQUNsRCxjQUFjLG1CQUFPLENBQUMsa0VBQWU7QUFDckMsY0FBYyxtQkFBTyxDQUFDLGtFQUFlO0FBQ3JDLHNCQUFzQixtQkFBTyxDQUFDLGtGQUF1QjtBQUNyRCxrQkFBa0IsNkdBQXdDO0FBQzFELFVBQVUscUZBQXdCO0FBQ2xDLFdBQVcsd0ZBQTBCO0FBQ3JDLFlBQVksMkZBQTRCO0FBQ3hDLFdBQVcsbUJBQU8sQ0FBQyw0REFBWTtBQUMvQixnQkFBZ0IsdUdBQW9DO0FBQ3BELGVBQWUsb0dBQWtDO0FBQ2pELGFBQWEsOEZBQThCO0FBQzNDLFVBQVUsbUJBQU8sQ0FBQyxvRkFBaUI7QUFDbkMsYUFBYSw0RkFBNkI7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlDQUF5QyxxQkFBcUIsMkNBQTJDO0FBQ3pHOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7QUFDaEQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUVBQXVFLGdDQUFnQztBQUN2RztBQUNBOztBQUVBO0FBQ0EsMkVBQTJFLGdDQUFnQztBQUMzRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixvREFBb0QscUJBQXFCO0FBQ3pFLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxrQkFBa0I7QUFDMUUsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCw4Q0FBOEMsb0JBQW9COztBQUVsRTtBQUNBO0FBQ0EsTUFBTSxPQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYWdlLWZvcm0vLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9yZXF1ZXN0LmpzP2M3MDYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbnZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpXG52YXIgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJylcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJylcbnZhciB6bGliID0gcmVxdWlyZSgnemxpYicpXG52YXIgYXdzMiA9IHJlcXVpcmUoJ2F3cy1zaWduMicpXG52YXIgYXdzNCA9IHJlcXVpcmUoJ2F3czQnKVxudmFyIGh0dHBTaWduYXR1cmUgPSByZXF1aXJlKCdodHRwLXNpZ25hdHVyZScpXG52YXIgbWltZSA9IHJlcXVpcmUoJ21pbWUtdHlwZXMnKVxudmFyIGNhc2VsZXNzID0gcmVxdWlyZSgnY2FzZWxlc3MnKVxudmFyIEZvcmV2ZXJBZ2VudCA9IHJlcXVpcmUoJ2ZvcmV2ZXItYWdlbnQnKVxudmFyIEZvcm1EYXRhID0gcmVxdWlyZSgnZm9ybS1kYXRhJylcbnZhciBleHRlbmQgPSByZXF1aXJlKCdleHRlbmQnKVxudmFyIGlzc3RyZWFtID0gcmVxdWlyZSgnaXNzdHJlYW0nKVxudmFyIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJ2lzLXR5cGVkYXJyYXknKS5zdHJpY3RcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9saWIvaGVscGVycycpXG52YXIgY29va2llcyA9IHJlcXVpcmUoJy4vbGliL2Nvb2tpZXMnKVxudmFyIGdldFByb3h5RnJvbVVSSSA9IHJlcXVpcmUoJy4vbGliL2dldFByb3h5RnJvbVVSSScpXG52YXIgUXVlcnlzdHJpbmcgPSByZXF1aXJlKCcuL2xpYi9xdWVyeXN0cmluZycpLlF1ZXJ5c3RyaW5nXG52YXIgSGFyID0gcmVxdWlyZSgnLi9saWIvaGFyJykuSGFyXG52YXIgQXV0aCA9IHJlcXVpcmUoJy4vbGliL2F1dGgnKS5BdXRoXG52YXIgT0F1dGggPSByZXF1aXJlKCcuL2xpYi9vYXV0aCcpLk9BdXRoXG52YXIgaGF3ayA9IHJlcXVpcmUoJy4vbGliL2hhd2snKVxudmFyIE11bHRpcGFydCA9IHJlcXVpcmUoJy4vbGliL211bHRpcGFydCcpLk11bHRpcGFydFxudmFyIFJlZGlyZWN0ID0gcmVxdWlyZSgnLi9saWIvcmVkaXJlY3QnKS5SZWRpcmVjdFxudmFyIFR1bm5lbCA9IHJlcXVpcmUoJy4vbGliL3R1bm5lbCcpLlR1bm5lbFxudmFyIG5vdyA9IHJlcXVpcmUoJ3BlcmZvcm1hbmNlLW5vdycpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIHNhZmVTdHJpbmdpZnkgPSBoZWxwZXJzLnNhZmVTdHJpbmdpZnlcbnZhciBpc1JlYWRTdHJlYW0gPSBoZWxwZXJzLmlzUmVhZFN0cmVhbVxudmFyIHRvQmFzZTY0ID0gaGVscGVycy50b0Jhc2U2NFxudmFyIGRlZmVyID0gaGVscGVycy5kZWZlclxudmFyIGNvcHkgPSBoZWxwZXJzLmNvcHlcbnZhciB2ZXJzaW9uID0gaGVscGVycy52ZXJzaW9uXG52YXIgZ2xvYmFsQ29va2llSmFyID0gY29va2llcy5qYXIoKVxuXG52YXIgZ2xvYmFsUG9vbCA9IHt9XG5cbmZ1bmN0aW9uIGZpbHRlckZvck5vblJlc2VydmVkIChyZXNlcnZlZCwgb3B0aW9ucykge1xuICAvLyBGaWx0ZXIgb3V0IHByb3BlcnRpZXMgdGhhdCBhcmUgbm90IHJlc2VydmVkLlxuICAvLyBSZXNlcnZlZCB2YWx1ZXMgYXJlIHBhc3NlZCBpbiBhdCBjYWxsIHNpdGUuXG5cbiAgdmFyIG9iamVjdCA9IHt9XG4gIGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xuICAgIHZhciBub3RSZXNlcnZlZCA9IChyZXNlcnZlZC5pbmRleE9mKGkpID09PSAtMSlcbiAgICBpZiAobm90UmVzZXJ2ZWQpIHtcbiAgICAgIG9iamVjdFtpXSA9IG9wdGlvbnNbaV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdFxufVxuXG5mdW5jdGlvbiBmaWx0ZXJPdXRSZXNlcnZlZEZ1bmN0aW9ucyAocmVzZXJ2ZWQsIG9wdGlvbnMpIHtcbiAgLy8gRmlsdGVyIG91dCBwcm9wZXJ0aWVzIHRoYXQgYXJlIGZ1bmN0aW9ucyBhbmQgYXJlIHJlc2VydmVkLlxuICAvLyBSZXNlcnZlZCB2YWx1ZXMgYXJlIHBhc3NlZCBpbiBhdCBjYWxsIHNpdGUuXG5cbiAgdmFyIG9iamVjdCA9IHt9XG4gIGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xuICAgIHZhciBpc1Jlc2VydmVkID0gIShyZXNlcnZlZC5pbmRleE9mKGkpID09PSAtMSlcbiAgICB2YXIgaXNGdW5jdGlvbiA9ICh0eXBlb2Ygb3B0aW9uc1tpXSA9PT0gJ2Z1bmN0aW9uJylcbiAgICBpZiAoIShpc1Jlc2VydmVkICYmIGlzRnVuY3Rpb24pKSB7XG4gICAgICBvYmplY3RbaV0gPSBvcHRpb25zW2ldXG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Rcbn1cblxuLy8gUmV0dXJuIGEgc2ltcGxlciByZXF1ZXN0IG9iamVjdCB0byBhbGxvdyBzZXJpYWxpemF0aW9uXG5mdW5jdGlvbiByZXF1ZXN0VG9KU09OICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHJldHVybiB7XG4gICAgdXJpOiBzZWxmLnVyaSxcbiAgICBtZXRob2Q6IHNlbGYubWV0aG9kLFxuICAgIGhlYWRlcnM6IHNlbGYuaGVhZGVyc1xuICB9XG59XG5cbi8vIFJldHVybiBhIHNpbXBsZXIgcmVzcG9uc2Ugb2JqZWN0IHRvIGFsbG93IHNlcmlhbGl6YXRpb25cbmZ1bmN0aW9uIHJlc3BvbnNlVG9KU09OICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHJldHVybiB7XG4gICAgc3RhdHVzQ29kZTogc2VsZi5zdGF0dXNDb2RlLFxuICAgIGJvZHk6IHNlbGYuYm9keSxcbiAgICBoZWFkZXJzOiBzZWxmLmhlYWRlcnMsXG4gICAgcmVxdWVzdDogcmVxdWVzdFRvSlNPTi5jYWxsKHNlbGYucmVxdWVzdClcbiAgfVxufVxuXG5mdW5jdGlvbiBSZXF1ZXN0IChvcHRpb25zKSB7XG4gIC8vIGlmIGdpdmVuIHRoZSBtZXRob2QgcHJvcGVydHkgaW4gb3B0aW9ucywgc2V0IHByb3BlcnR5IGV4cGxpY2l0TWV0aG9kIHRvIHRydWVcblxuICAvLyBleHRlbmQgdGhlIFJlcXVlc3QgaW5zdGFuY2Ugd2l0aCBhbnkgbm9uLXJlc2VydmVkIHByb3BlcnRpZXNcbiAgLy8gcmVtb3ZlIGFueSByZXNlcnZlZCBmdW5jdGlvbnMgZnJvbSB0aGUgb3B0aW9ucyBvYmplY3RcbiAgLy8gc2V0IFJlcXVlc3QgaW5zdGFuY2UgdG8gYmUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4gIC8vIGNhbGwgaW5pdFxuXG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIC8vIHN0YXJ0IHdpdGggSEFSLCB0aGVuIG92ZXJyaWRlIHdpdGggYWRkaXRpb25hbCBvcHRpb25zXG4gIGlmIChvcHRpb25zLmhhcikge1xuICAgIHNlbGYuX2hhciA9IG5ldyBIYXIoc2VsZilcbiAgICBvcHRpb25zID0gc2VsZi5faGFyLm9wdGlvbnMob3B0aW9ucylcbiAgfVxuXG4gIHN0cmVhbS5TdHJlYW0uY2FsbChzZWxmKVxuICB2YXIgcmVzZXJ2ZWQgPSBPYmplY3Qua2V5cyhSZXF1ZXN0LnByb3RvdHlwZSlcbiAgdmFyIG5vblJlc2VydmVkID0gZmlsdGVyRm9yTm9uUmVzZXJ2ZWQocmVzZXJ2ZWQsIG9wdGlvbnMpXG5cbiAgZXh0ZW5kKHNlbGYsIG5vblJlc2VydmVkKVxuICBvcHRpb25zID0gZmlsdGVyT3V0UmVzZXJ2ZWRGdW5jdGlvbnMocmVzZXJ2ZWQsIG9wdGlvbnMpXG5cbiAgc2VsZi5yZWFkYWJsZSA9IHRydWVcbiAgc2VsZi53cml0YWJsZSA9IHRydWVcbiAgaWYgKG9wdGlvbnMubWV0aG9kKSB7XG4gICAgc2VsZi5leHBsaWNpdE1ldGhvZCA9IHRydWVcbiAgfVxuICBzZWxmLl9xcyA9IG5ldyBRdWVyeXN0cmluZyhzZWxmKVxuICBzZWxmLl9hdXRoID0gbmV3IEF1dGgoc2VsZilcbiAgc2VsZi5fb2F1dGggPSBuZXcgT0F1dGgoc2VsZilcbiAgc2VsZi5fbXVsdGlwYXJ0ID0gbmV3IE11bHRpcGFydChzZWxmKVxuICBzZWxmLl9yZWRpcmVjdCA9IG5ldyBSZWRpcmVjdChzZWxmKVxuICBzZWxmLl90dW5uZWwgPSBuZXcgVHVubmVsKHNlbGYpXG4gIHNlbGYuaW5pdChvcHRpb25zKVxufVxuXG51dGlsLmluaGVyaXRzKFJlcXVlc3QsIHN0cmVhbS5TdHJlYW0pXG5cbi8vIERlYnVnZ2luZ1xuUmVxdWVzdC5kZWJ1ZyA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgJiYgL1xcYnJlcXVlc3RcXGIvLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRylcbmZ1bmN0aW9uIGRlYnVnICgpIHtcbiAgaWYgKFJlcXVlc3QuZGVidWcpIHtcbiAgICBjb25zb2xlLmVycm9yKCdSRVFVRVNUICVzJywgdXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgYXJndW1lbnRzKSlcbiAgfVxufVxuUmVxdWVzdC5wcm90b3R5cGUuZGVidWcgPSBkZWJ1Z1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgLy8gaW5pdCgpIGNvbnRhaW5zIGFsbCB0aGUgY29kZSB0byBzZXR1cCB0aGUgcmVxdWVzdCBvYmplY3QuXG4gIC8vIHRoZSBhY3R1YWwgb3V0Z29pbmcgcmVxdWVzdCBpcyBub3Qgc3RhcnRlZCB1bnRpbCBzdGFydCgpIGlzIGNhbGxlZFxuICAvLyB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBmcm9tIGJvdGggdGhlIGNvbnN0cnVjdG9yIGFuZCBvbiByZWRpcmVjdC5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG4gIHNlbGYuaGVhZGVycyA9IHNlbGYuaGVhZGVycyA/IGNvcHkoc2VsZi5oZWFkZXJzKSA6IHt9XG5cbiAgLy8gRGVsZXRlIGhlYWRlcnMgd2l0aCB2YWx1ZSB1bmRlZmluZWQgc2luY2UgdGhleSBicmVha1xuICAvLyBDbGllbnRSZXF1ZXN0Lk91dGdvaW5nTWVzc2FnZS5zZXRIZWFkZXIgaW4gbm9kZSAwLjEyXG4gIGZvciAodmFyIGhlYWRlck5hbWUgaW4gc2VsZi5oZWFkZXJzKSB7XG4gICAgaWYgKHR5cGVvZiBzZWxmLmhlYWRlcnNbaGVhZGVyTmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkZWxldGUgc2VsZi5oZWFkZXJzW2hlYWRlck5hbWVdXG4gICAgfVxuICB9XG5cbiAgY2FzZWxlc3MuaHR0cGlmeShzZWxmLCBzZWxmLmhlYWRlcnMpXG5cbiAgaWYgKCFzZWxmLm1ldGhvZCkge1xuICAgIHNlbGYubWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgJ0dFVCdcbiAgfVxuICBpZiAoIXNlbGYubG9jYWxBZGRyZXNzKSB7XG4gICAgc2VsZi5sb2NhbEFkZHJlc3MgPSBvcHRpb25zLmxvY2FsQWRkcmVzc1xuICB9XG5cbiAgc2VsZi5fcXMuaW5pdChvcHRpb25zKVxuXG4gIGRlYnVnKG9wdGlvbnMpXG4gIGlmICghc2VsZi5wb29sICYmIHNlbGYucG9vbCAhPT0gZmFsc2UpIHtcbiAgICBzZWxmLnBvb2wgPSBnbG9iYWxQb29sXG4gIH1cbiAgc2VsZi5kZXN0cyA9IHNlbGYuZGVzdHMgfHwgW11cbiAgc2VsZi5fX2lzUmVxdWVzdFJlcXVlc3QgPSB0cnVlXG5cbiAgLy8gUHJvdGVjdCBhZ2FpbnN0IGRvdWJsZSBjYWxsYmFja1xuICBpZiAoIXNlbGYuX2NhbGxiYWNrICYmIHNlbGYuY2FsbGJhY2spIHtcbiAgICBzZWxmLl9jYWxsYmFjayA9IHNlbGYuY2FsbGJhY2tcbiAgICBzZWxmLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuX2NhbGxiYWNrQ2FsbGVkKSB7XG4gICAgICAgIHJldHVybiAvLyBQcmludCBhIHdhcm5pbmcgbWF5YmU/XG4gICAgICB9XG4gICAgICBzZWxmLl9jYWxsYmFja0NhbGxlZCA9IHRydWVcbiAgICAgIHNlbGYuX2NhbGxiYWNrLmFwcGx5KHNlbGYsIGFyZ3VtZW50cylcbiAgICB9XG4gICAgc2VsZi5vbignZXJyb3InLCBzZWxmLmNhbGxiYWNrLmJpbmQoKSlcbiAgICBzZWxmLm9uKCdjb21wbGV0ZScsIHNlbGYuY2FsbGJhY2suYmluZChzZWxmLCBudWxsKSlcbiAgfVxuXG4gIC8vIFBlb3BsZSB1c2UgdGhpcyBwcm9wZXJ0eSBpbnN0ZWFkIGFsbCB0aGUgdGltZSwgc28gc3VwcG9ydCBpdFxuICBpZiAoIXNlbGYudXJpICYmIHNlbGYudXJsKSB7XG4gICAgc2VsZi51cmkgPSBzZWxmLnVybFxuICAgIGRlbGV0ZSBzZWxmLnVybFxuICB9XG5cbiAgLy8gSWYgdGhlcmUncyBhIGJhc2VVcmwsIHRoZW4gdXNlIGl0IGFzIHRoZSBiYXNlIFVSTCAoaS5lLiB1cmkgbXVzdCBiZVxuICAvLyBzcGVjaWZpZWQgYXMgYSByZWxhdGl2ZSBwYXRoIGFuZCBpcyBhcHBlbmRlZCB0byBiYXNlVXJsKS5cbiAgaWYgKHNlbGYuYmFzZVVybCkge1xuICAgIGlmICh0eXBlb2Ygc2VsZi5iYXNlVXJsICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ29wdGlvbnMuYmFzZVVybCBtdXN0IGJlIGEgc3RyaW5nJykpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzZWxmLnVyaSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdvcHRpb25zLnVyaSBtdXN0IGJlIGEgc3RyaW5nIHdoZW4gdXNpbmcgb3B0aW9ucy5iYXNlVXJsJykpXG4gICAgfVxuXG4gICAgaWYgKHNlbGYudXJpLmluZGV4T2YoJy8vJykgPT09IDAgfHwgc2VsZi51cmkuaW5kZXhPZignOi8vJykgIT09IC0xKSB7XG4gICAgICByZXR1cm4gc2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignb3B0aW9ucy51cmkgbXVzdCBiZSBhIHBhdGggd2hlbiB1c2luZyBvcHRpb25zLmJhc2VVcmwnKSlcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgYWxsIGNhc2VzIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZXJlJ3Mgb25seSBvbmUgc2xhc2ggYmV0d2VlblxuICAgIC8vIGJhc2VVcmwgYW5kIHVyaS5cbiAgICB2YXIgYmFzZVVybEVuZHNXaXRoU2xhc2ggPSBzZWxmLmJhc2VVcmwubGFzdEluZGV4T2YoJy8nKSA9PT0gc2VsZi5iYXNlVXJsLmxlbmd0aCAtIDFcbiAgICB2YXIgdXJpU3RhcnRzV2l0aFNsYXNoID0gc2VsZi51cmkuaW5kZXhPZignLycpID09PSAwXG5cbiAgICBpZiAoYmFzZVVybEVuZHNXaXRoU2xhc2ggJiYgdXJpU3RhcnRzV2l0aFNsYXNoKSB7XG4gICAgICBzZWxmLnVyaSA9IHNlbGYuYmFzZVVybCArIHNlbGYudXJpLnNsaWNlKDEpXG4gICAgfSBlbHNlIGlmIChiYXNlVXJsRW5kc1dpdGhTbGFzaCB8fCB1cmlTdGFydHNXaXRoU2xhc2gpIHtcbiAgICAgIHNlbGYudXJpID0gc2VsZi5iYXNlVXJsICsgc2VsZi51cmlcbiAgICB9IGVsc2UgaWYgKHNlbGYudXJpID09PSAnJykge1xuICAgICAgc2VsZi51cmkgPSBzZWxmLmJhc2VVcmxcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi51cmkgPSBzZWxmLmJhc2VVcmwgKyAnLycgKyBzZWxmLnVyaVxuICAgIH1cbiAgICBkZWxldGUgc2VsZi5iYXNlVXJsXG4gIH1cblxuICAvLyBBIFVSSSBpcyBuZWVkZWQgYnkgdGhpcyBwb2ludCwgZW1pdCBlcnJvciBpZiB3ZSBoYXZlbid0IGJlZW4gYWJsZSB0byBnZXQgb25lXG4gIGlmICghc2VsZi51cmkpIHtcbiAgICByZXR1cm4gc2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignb3B0aW9ucy51cmkgaXMgYSByZXF1aXJlZCBhcmd1bWVudCcpKVxuICB9XG5cbiAgLy8gSWYgYSBzdHJpbmcgVVJJL1VSTCB3YXMgZ2l2ZW4sIHBhcnNlIGl0IGludG8gYSBVUkwgb2JqZWN0XG4gIGlmICh0eXBlb2Ygc2VsZi51cmkgPT09ICdzdHJpbmcnKSB7XG4gICAgc2VsZi51cmkgPSB1cmwucGFyc2Uoc2VsZi51cmkpXG4gIH1cblxuICAvLyBTb21lIFVSTCBvYmplY3RzIGFyZSBub3QgZnJvbSBhIFVSTCBwYXJzZWQgc3RyaW5nIGFuZCBuZWVkIGhyZWYgYWRkZWRcbiAgaWYgKCFzZWxmLnVyaS5ocmVmKSB7XG4gICAgc2VsZi51cmkuaHJlZiA9IHVybC5mb3JtYXQoc2VsZi51cmkpXG4gIH1cblxuICAvLyBERVBSRUNBVEVEOiBXYXJuaW5nIGZvciB1c2VycyBvZiB0aGUgb2xkIFVuaXggU29ja2V0cyBVUkwgU2NoZW1lXG4gIGlmIChzZWxmLnVyaS5wcm90b2NvbCA9PT0gJ3VuaXg6Jykge1xuICAgIHJldHVybiBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdgdW5peDovL2AgVVJMIHNjaGVtZSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBQbGVhc2UgdXNlIHRoZSBmb3JtYXQgYGh0dHA6Ly91bml4OlNPQ0tFVDpQQVRIYCcpKVxuICB9XG5cbiAgLy8gU3VwcG9ydCBVbml4IFNvY2tldHNcbiAgaWYgKHNlbGYudXJpLmhvc3QgPT09ICd1bml4Jykge1xuICAgIHNlbGYuZW5hYmxlVW5peFNvY2tldCgpXG4gIH1cblxuICBpZiAoc2VsZi5zdHJpY3RTU0wgPT09IGZhbHNlKSB7XG4gICAgc2VsZi5yZWplY3RVbmF1dGhvcml6ZWQgPSBmYWxzZVxuICB9XG5cbiAgaWYgKCFzZWxmLnVyaS5wYXRobmFtZSkgeyBzZWxmLnVyaS5wYXRobmFtZSA9ICcvJyB9XG5cbiAgaWYgKCEoc2VsZi51cmkuaG9zdCB8fCAoc2VsZi51cmkuaG9zdG5hbWUgJiYgc2VsZi51cmkucG9ydCkpICYmICFzZWxmLnVyaS5pc1VuaXgpIHtcbiAgICAvLyBJbnZhbGlkIFVSSTogaXQgbWF5IGdlbmVyYXRlIGxvdCBvZiBiYWQgZXJyb3JzLCBsaWtlICdUeXBlRXJyb3I6IENhbm5vdCBjYWxsIG1ldGhvZCBgaW5kZXhPZmAgb2YgdW5kZWZpbmVkJyBpbiBDb29raWVKYXJcbiAgICAvLyBEZXRlY3QgYW5kIHJlamVjdCBpdCBhcyBzb29uIGFzIHBvc3NpYmxlXG4gICAgdmFyIGZhdWx0eVVyaSA9IHVybC5mb3JtYXQoc2VsZi51cmkpXG4gICAgdmFyIG1lc3NhZ2UgPSAnSW52YWxpZCBVUkkgXCInICsgZmF1bHR5VXJpICsgJ1wiJ1xuICAgIGlmIChPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIE5vIG9wdGlvbiA/IFRoaXMgY2FuIGJlIHRoZSBzaWduIG9mIGEgcmVkaXJlY3RcbiAgICAgIC8vIEFzIHRoaXMgaXMgYSBjYXNlIHdoZXJlIHRoZSB1c2VyIGNhbm5vdCBkbyBhbnl0aGluZyAodGhleSBkaWRuJ3QgY2FsbCByZXF1ZXN0IGRpcmVjdGx5IHdpdGggdGhpcyBVUkwpXG4gICAgICAvLyB0aGV5IHNob3VsZCBiZSB3YXJuZWQgdGhhdCBpdCBjYW4gYmUgY2F1c2VkIGJ5IGEgcmVkaXJlY3Rpb24gKGNhbiBzYXZlIHNvbWUgaGFpcilcbiAgICAgIG1lc3NhZ2UgKz0gJy4gVGhpcyBjYW4gYmUgY2F1c2VkIGJ5IGEgY3JhcHB5IHJlZGlyZWN0aW9uLidcbiAgICB9XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgZmF0YWxcbiAgICBzZWxmLmFib3J0KClcbiAgICByZXR1cm4gc2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihtZXNzYWdlKSlcbiAgfVxuXG4gIGlmICghc2VsZi5oYXNPd25Qcm9wZXJ0eSgncHJveHknKSkge1xuICAgIHNlbGYucHJveHkgPSBnZXRQcm94eUZyb21VUkkoc2VsZi51cmkpXG4gIH1cblxuICBzZWxmLnR1bm5lbCA9IHNlbGYuX3R1bm5lbC5pc0VuYWJsZWQoKVxuICBpZiAoc2VsZi5wcm94eSkge1xuICAgIHNlbGYuX3R1bm5lbC5zZXR1cChvcHRpb25zKVxuICB9XG5cbiAgc2VsZi5fcmVkaXJlY3Qub25SZXF1ZXN0KG9wdGlvbnMpXG5cbiAgc2VsZi5zZXRIb3N0ID0gZmFsc2VcbiAgaWYgKCFzZWxmLmhhc0hlYWRlcignaG9zdCcpKSB7XG4gICAgdmFyIGhvc3RIZWFkZXJOYW1lID0gc2VsZi5vcmlnaW5hbEhvc3RIZWFkZXJOYW1lIHx8ICdob3N0J1xuICAgIHNlbGYuc2V0SGVhZGVyKGhvc3RIZWFkZXJOYW1lLCBzZWxmLnVyaS5ob3N0KVxuICAgIC8vIERyb3AgOnBvcnQgc3VmZml4IGZyb20gSG9zdCBoZWFkZXIgaWYga25vd24gcHJvdG9jb2wuXG4gICAgaWYgKHNlbGYudXJpLnBvcnQpIHtcbiAgICAgIGlmICgoc2VsZi51cmkucG9ydCA9PT0gJzgwJyAmJiBzZWxmLnVyaS5wcm90b2NvbCA9PT0gJ2h0dHA6JykgfHxcbiAgICAgICAgICAoc2VsZi51cmkucG9ydCA9PT0gJzQ0MycgJiYgc2VsZi51cmkucHJvdG9jb2wgPT09ICdodHRwczonKSkge1xuICAgICAgICBzZWxmLnNldEhlYWRlcihob3N0SGVhZGVyTmFtZSwgc2VsZi51cmkuaG9zdG5hbWUpXG4gICAgICB9XG4gICAgfVxuICAgIHNlbGYuc2V0SG9zdCA9IHRydWVcbiAgfVxuXG4gIHNlbGYuamFyKHNlbGYuX2phciB8fCBvcHRpb25zLmphcilcblxuICBpZiAoIXNlbGYudXJpLnBvcnQpIHtcbiAgICBpZiAoc2VsZi51cmkucHJvdG9jb2wgPT09ICdodHRwOicpIHsgc2VsZi51cmkucG9ydCA9IDgwIH0gZWxzZSBpZiAoc2VsZi51cmkucHJvdG9jb2wgPT09ICdodHRwczonKSB7IHNlbGYudXJpLnBvcnQgPSA0NDMgfVxuICB9XG5cbiAgaWYgKHNlbGYucHJveHkgJiYgIXNlbGYudHVubmVsKSB7XG4gICAgc2VsZi5wb3J0ID0gc2VsZi5wcm94eS5wb3J0XG4gICAgc2VsZi5ob3N0ID0gc2VsZi5wcm94eS5ob3N0bmFtZVxuICB9IGVsc2Uge1xuICAgIHNlbGYucG9ydCA9IHNlbGYudXJpLnBvcnRcbiAgICBzZWxmLmhvc3QgPSBzZWxmLnVyaS5ob3N0bmFtZVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuZm9ybSkge1xuICAgIHNlbGYuZm9ybShvcHRpb25zLmZvcm0pXG4gIH1cblxuICBpZiAob3B0aW9ucy5mb3JtRGF0YSkge1xuICAgIHZhciBmb3JtRGF0YSA9IG9wdGlvbnMuZm9ybURhdGFcbiAgICB2YXIgcmVxdWVzdEZvcm0gPSBzZWxmLmZvcm0oKVxuICAgIHZhciBhcHBlbmRGb3JtVmFsdWUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmhhc093blByb3BlcnR5KCd2YWx1ZScpICYmIHZhbHVlLmhhc093blByb3BlcnR5KCdvcHRpb25zJykpIHtcbiAgICAgICAgcmVxdWVzdEZvcm0uYXBwZW5kKGtleSwgdmFsdWUudmFsdWUsIHZhbHVlLm9wdGlvbnMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0Rm9ybS5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgZm9ybUtleSBpbiBmb3JtRGF0YSkge1xuICAgICAgaWYgKGZvcm1EYXRhLmhhc093blByb3BlcnR5KGZvcm1LZXkpKSB7XG4gICAgICAgIHZhciBmb3JtVmFsdWUgPSBmb3JtRGF0YVtmb3JtS2V5XVxuICAgICAgICBpZiAoZm9ybVZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZvcm1WYWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgYXBwZW5kRm9ybVZhbHVlKGZvcm1LZXksIGZvcm1WYWx1ZVtqXSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXBwZW5kRm9ybVZhbHVlKGZvcm1LZXksIGZvcm1WYWx1ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRpb25zLnFzKSB7XG4gICAgc2VsZi5xcyhvcHRpb25zLnFzKVxuICB9XG5cbiAgaWYgKHNlbGYudXJpLnBhdGgpIHtcbiAgICBzZWxmLnBhdGggPSBzZWxmLnVyaS5wYXRoXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5wYXRoID0gc2VsZi51cmkucGF0aG5hbWUgKyAoc2VsZi51cmkuc2VhcmNoIHx8ICcnKVxuICB9XG5cbiAgaWYgKHNlbGYucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICBzZWxmLnBhdGggPSAnLydcbiAgfVxuXG4gIC8vIEF1dGggbXVzdCBoYXBwZW4gbGFzdCBpbiBjYXNlIHNpZ25pbmcgaXMgZGVwZW5kZW50IG9uIG90aGVyIGhlYWRlcnNcbiAgaWYgKG9wdGlvbnMuYXdzKSB7XG4gICAgc2VsZi5hd3Mob3B0aW9ucy5hd3MpXG4gIH1cblxuICBpZiAob3B0aW9ucy5oYXdrKSB7XG4gICAgc2VsZi5oYXdrKG9wdGlvbnMuaGF3aylcbiAgfVxuXG4gIGlmIChvcHRpb25zLmh0dHBTaWduYXR1cmUpIHtcbiAgICBzZWxmLmh0dHBTaWduYXR1cmUob3B0aW9ucy5odHRwU2lnbmF0dXJlKVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuYXV0aCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucy5hdXRoLCAndXNlcm5hbWUnKSkge1xuICAgICAgb3B0aW9ucy5hdXRoLnVzZXIgPSBvcHRpb25zLmF1dGgudXNlcm5hbWVcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLmF1dGgsICdwYXNzd29yZCcpKSB7XG4gICAgICBvcHRpb25zLmF1dGgucGFzcyA9IG9wdGlvbnMuYXV0aC5wYXNzd29yZFxuICAgIH1cblxuICAgIHNlbGYuYXV0aChcbiAgICAgIG9wdGlvbnMuYXV0aC51c2VyLFxuICAgICAgb3B0aW9ucy5hdXRoLnBhc3MsXG4gICAgICBvcHRpb25zLmF1dGguc2VuZEltbWVkaWF0ZWx5LFxuICAgICAgb3B0aW9ucy5hdXRoLmJlYXJlclxuICAgIClcbiAgfVxuXG4gIGlmIChzZWxmLmd6aXAgJiYgIXNlbGYuaGFzSGVhZGVyKCdhY2NlcHQtZW5jb2RpbmcnKSkge1xuICAgIHNlbGYuc2V0SGVhZGVyKCdhY2NlcHQtZW5jb2RpbmcnLCAnZ3ppcCwgZGVmbGF0ZScpXG4gIH1cblxuICBpZiAoc2VsZi51cmkuYXV0aCAmJiAhc2VsZi5oYXNIZWFkZXIoJ2F1dGhvcml6YXRpb24nKSkge1xuICAgIHZhciB1cmlBdXRoUGllY2VzID0gc2VsZi51cmkuYXV0aC5zcGxpdCgnOicpLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gc2VsZi5fcXMudW5lc2NhcGUoaXRlbSkgfSlcbiAgICBzZWxmLmF1dGgodXJpQXV0aFBpZWNlc1swXSwgdXJpQXV0aFBpZWNlcy5zbGljZSgxKS5qb2luKCc6JyksIHRydWUpXG4gIH1cblxuICBpZiAoIXNlbGYudHVubmVsICYmIHNlbGYucHJveHkgJiYgc2VsZi5wcm94eS5hdXRoICYmICFzZWxmLmhhc0hlYWRlcigncHJveHktYXV0aG9yaXphdGlvbicpKSB7XG4gICAgdmFyIHByb3h5QXV0aFBpZWNlcyA9IHNlbGYucHJveHkuYXV0aC5zcGxpdCgnOicpLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gc2VsZi5fcXMudW5lc2NhcGUoaXRlbSkgfSlcbiAgICB2YXIgYXV0aEhlYWRlciA9ICdCYXNpYyAnICsgdG9CYXNlNjQocHJveHlBdXRoUGllY2VzLmpvaW4oJzonKSlcbiAgICBzZWxmLnNldEhlYWRlcigncHJveHktYXV0aG9yaXphdGlvbicsIGF1dGhIZWFkZXIpXG4gIH1cblxuICBpZiAoc2VsZi5wcm94eSAmJiAhc2VsZi50dW5uZWwpIHtcbiAgICBzZWxmLnBhdGggPSAoc2VsZi51cmkucHJvdG9jb2wgKyAnLy8nICsgc2VsZi51cmkuaG9zdCArIHNlbGYucGF0aClcbiAgfVxuXG4gIGlmIChvcHRpb25zLmpzb24pIHtcbiAgICBzZWxmLmpzb24ob3B0aW9ucy5qc29uKVxuICB9XG4gIGlmIChvcHRpb25zLm11bHRpcGFydCkge1xuICAgIHNlbGYubXVsdGlwYXJ0KG9wdGlvbnMubXVsdGlwYXJ0KVxuICB9XG5cbiAgaWYgKG9wdGlvbnMudGltZSkge1xuICAgIHNlbGYudGltaW5nID0gdHJ1ZVxuXG4gICAgLy8gTk9URTogZWxhcHNlZFRpbWUgaXMgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiAudGltaW5nc1xuICAgIHNlbGYuZWxhcHNlZFRpbWUgPSBzZWxmLmVsYXBzZWRUaW1lIHx8IDBcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENvbnRlbnRMZW5ndGggKCkge1xuICAgIGlmIChpc1R5cGVkQXJyYXkoc2VsZi5ib2R5KSkge1xuICAgICAgc2VsZi5ib2R5ID0gQnVmZmVyLmZyb20oc2VsZi5ib2R5KVxuICAgIH1cblxuICAgIGlmICghc2VsZi5oYXNIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJykpIHtcbiAgICAgIHZhciBsZW5ndGhcbiAgICAgIGlmICh0eXBlb2Ygc2VsZi5ib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzZWxmLmJvZHkpXG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2VsZi5ib2R5KSkge1xuICAgICAgICBsZW5ndGggPSBzZWxmLmJvZHkucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICsgYi5sZW5ndGggfSwgMClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbmd0aCA9IHNlbGYuYm9keS5sZW5ndGhcbiAgICAgIH1cblxuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICBzZWxmLnNldEhlYWRlcignY29udGVudC1sZW5ndGgnLCBsZW5ndGgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdBcmd1bWVudCBlcnJvciwgb3B0aW9ucy5ib2R5LicpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoc2VsZi5ib2R5ICYmICFpc3N0cmVhbShzZWxmLmJvZHkpKSB7XG4gICAgc2V0Q29udGVudExlbmd0aCgpXG4gIH1cblxuICBpZiAob3B0aW9ucy5vYXV0aCkge1xuICAgIHNlbGYub2F1dGgob3B0aW9ucy5vYXV0aClcbiAgfSBlbHNlIGlmIChzZWxmLl9vYXV0aC5wYXJhbXMgJiYgc2VsZi5oYXNIZWFkZXIoJ2F1dGhvcml6YXRpb24nKSkge1xuICAgIHNlbGYub2F1dGgoc2VsZi5fb2F1dGgucGFyYW1zKVxuICB9XG5cbiAgdmFyIHByb3RvY29sID0gc2VsZi5wcm94eSAmJiAhc2VsZi50dW5uZWwgPyBzZWxmLnByb3h5LnByb3RvY29sIDogc2VsZi51cmkucHJvdG9jb2xcbiAgdmFyIGRlZmF1bHRNb2R1bGVzID0geydodHRwOic6IGh0dHAsICdodHRwczonOiBodHRwc31cbiAgdmFyIGh0dHBNb2R1bGVzID0gc2VsZi5odHRwTW9kdWxlcyB8fCB7fVxuXG4gIHNlbGYuaHR0cE1vZHVsZSA9IGh0dHBNb2R1bGVzW3Byb3RvY29sXSB8fCBkZWZhdWx0TW9kdWxlc1twcm90b2NvbF1cblxuICBpZiAoIXNlbGYuaHR0cE1vZHVsZSkge1xuICAgIHJldHVybiBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHByb3RvY29sOiAnICsgcHJvdG9jb2wpKVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuY2EpIHtcbiAgICBzZWxmLmNhID0gb3B0aW9ucy5jYVxuICB9XG5cbiAgaWYgKCFzZWxmLmFnZW50KSB7XG4gICAgaWYgKG9wdGlvbnMuYWdlbnRPcHRpb25zKSB7XG4gICAgICBzZWxmLmFnZW50T3B0aW9ucyA9IG9wdGlvbnMuYWdlbnRPcHRpb25zXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYWdlbnRDbGFzcykge1xuICAgICAgc2VsZi5hZ2VudENsYXNzID0gb3B0aW9ucy5hZ2VudENsYXNzXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmZvcmV2ZXIpIHtcbiAgICAgIHZhciB2ID0gdmVyc2lvbigpXG4gICAgICAvLyB1c2UgRm9yZXZlckFnZW50IGluIG5vZGUgMC4xMC0gb25seVxuICAgICAgaWYgKHYubWFqb3IgPT09IDAgJiYgdi5taW5vciA8PSAxMCkge1xuICAgICAgICBzZWxmLmFnZW50Q2xhc3MgPSBwcm90b2NvbCA9PT0gJ2h0dHA6JyA/IEZvcmV2ZXJBZ2VudCA6IEZvcmV2ZXJBZ2VudC5TU0xcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuYWdlbnRDbGFzcyA9IHNlbGYuaHR0cE1vZHVsZS5BZ2VudFxuICAgICAgICBzZWxmLmFnZW50T3B0aW9ucyA9IHNlbGYuYWdlbnRPcHRpb25zIHx8IHt9XG4gICAgICAgIHNlbGYuYWdlbnRPcHRpb25zLmtlZXBBbGl2ZSA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5hZ2VudENsYXNzID0gc2VsZi5odHRwTW9kdWxlLkFnZW50XG4gICAgfVxuICB9XG5cbiAgaWYgKHNlbGYucG9vbCA9PT0gZmFsc2UpIHtcbiAgICBzZWxmLmFnZW50ID0gZmFsc2VcbiAgfSBlbHNlIHtcbiAgICBzZWxmLmFnZW50ID0gc2VsZi5hZ2VudCB8fCBzZWxmLmdldE5ld0FnZW50KClcbiAgfVxuXG4gIHNlbGYub24oJ3BpcGUnLCBmdW5jdGlvbiAoc3JjKSB7XG4gICAgaWYgKHNlbGYubnRpY2sgJiYgc2VsZi5fc3RhcnRlZCkge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignWW91IGNhbm5vdCBwaXBlIHRvIHRoaXMgc3RyZWFtIGFmdGVyIHRoZSBvdXRib3VuZCByZXF1ZXN0IGhhcyBzdGFydGVkLicpKVxuICAgIH1cbiAgICBzZWxmLnNyYyA9IHNyY1xuICAgIGlmIChpc1JlYWRTdHJlYW0oc3JjKSkge1xuICAgICAgaWYgKCFzZWxmLmhhc0hlYWRlcignY29udGVudC10eXBlJykpIHtcbiAgICAgICAgc2VsZi5zZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScsIG1pbWUubG9va3VwKHNyYy5wYXRoKSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNyYy5oZWFkZXJzKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gc3JjLmhlYWRlcnMpIHtcbiAgICAgICAgICBpZiAoIXNlbGYuaGFzSGVhZGVyKGkpKSB7XG4gICAgICAgICAgICBzZWxmLnNldEhlYWRlcihpLCBzcmMuaGVhZGVyc1tpXSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLl9qc29uICYmICFzZWxmLmhhc0hlYWRlcignY29udGVudC10eXBlJykpIHtcbiAgICAgICAgc2VsZi5zZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9qc29uJylcbiAgICAgIH1cbiAgICAgIGlmIChzcmMubWV0aG9kICYmICFzZWxmLmV4cGxpY2l0TWV0aG9kKSB7XG4gICAgICAgIHNlbGYubWV0aG9kID0gc3JjLm1ldGhvZFxuICAgICAgfVxuICAgIH1cblxuICAvLyBzZWxmLm9uKCdwaXBlJywgZnVuY3Rpb24gKCkge1xuICAvLyAgIGNvbnNvbGUuZXJyb3IoJ1lvdSBoYXZlIGFscmVhZHkgcGlwZWQgdG8gdGhpcyBzdHJlYW0uIFBpcGVpbmcgdHdpY2UgaXMgbGlrZWx5IHRvIGJyZWFrIHRoZSByZXF1ZXN0LicpXG4gIC8vIH0pXG4gIH0pXG5cbiAgZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxmLl9hYm9ydGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuX2Zvcm0pIHtcbiAgICAgICAgaWYgKCFzZWxmLl9hdXRoLmhhc0F1dGgpIHtcbiAgICAgICAgICBzZWxmLl9mb3JtLnBpcGUoc2VsZilcbiAgICAgICAgfSBlbHNlIGlmIChzZWxmLl9hdXRoLmhhc0F1dGggJiYgc2VsZi5fYXV0aC5zZW50QXV0aCkge1xuICAgICAgICAgIHNlbGYuX2Zvcm0ucGlwZShzZWxmKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5fbXVsdGlwYXJ0ICYmIHNlbGYuX211bHRpcGFydC5jaHVua2VkKSB7XG4gICAgICAgIHNlbGYuX211bHRpcGFydC5ib2R5LnBpcGUoc2VsZilcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLmJvZHkpIHtcbiAgICAgICAgaWYgKGlzc3RyZWFtKHNlbGYuYm9keSkpIHtcbiAgICAgICAgICBzZWxmLmJvZHkucGlwZShzZWxmKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldENvbnRlbnRMZW5ndGgoKVxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGYuYm9keSkpIHtcbiAgICAgICAgICAgIHNlbGYuYm9keS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgICAgICAgIHNlbGYud3JpdGUocGFydClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYud3JpdGUoc2VsZi5ib2R5KVxuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLmVuZCgpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2VsZi5yZXF1ZXN0Qm9keVN0cmVhbSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ29wdGlvbnMucmVxdWVzdEJvZHlTdHJlYW0gaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHBhc3MgdGhlIHJlcXVlc3Qgb2JqZWN0IHRvIHN0cmVhbS5waXBlLicpXG4gICAgICAgIHNlbGYucmVxdWVzdEJvZHlTdHJlYW0ucGlwZShzZWxmKVxuICAgICAgfSBlbHNlIGlmICghc2VsZi5zcmMpIHtcbiAgICAgICAgaWYgKHNlbGYuX2F1dGguaGFzQXV0aCAmJiAhc2VsZi5fYXV0aC5zZW50QXV0aCkge1xuICAgICAgICAgIHNlbGYuZW5kKClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5tZXRob2QgIT09ICdHRVQnICYmIHR5cGVvZiBzZWxmLm1ldGhvZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBzZWxmLnNldEhlYWRlcignY29udGVudC1sZW5ndGgnLCAwKVxuICAgICAgICB9XG4gICAgICAgIHNlbGYuZW5kKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fZm9ybSAmJiAhc2VsZi5oYXNIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJykpIHtcbiAgICAgIC8vIEJlZm9yZSBlbmRpbmcgdGhlIHJlcXVlc3QsIHdlIGhhZCB0byBjb21wdXRlIHRoZSBsZW5ndGggb2YgdGhlIHdob2xlIGZvcm0sIGFzeW5jbHlcbiAgICAgIHNlbGYuc2V0SGVhZGVyKHNlbGYuX2Zvcm0uZ2V0SGVhZGVycygpLCB0cnVlKVxuICAgICAgc2VsZi5fZm9ybS5nZXRMZW5ndGgoZnVuY3Rpb24gKGVyciwgbGVuZ3RoKSB7XG4gICAgICAgIGlmICghZXJyICYmICFpc05hTihsZW5ndGgpKSB7XG4gICAgICAgICAgc2VsZi5zZXRIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJywgbGVuZ3RoKVxuICAgICAgICB9XG4gICAgICAgIGVuZCgpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBlbmQoKVxuICAgIH1cblxuICAgIHNlbGYubnRpY2sgPSB0cnVlXG4gIH0pXG59XG5cblJlcXVlc3QucHJvdG90eXBlLmdldE5ld0FnZW50ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIEFnZW50ID0gc2VsZi5hZ2VudENsYXNzXG4gIHZhciBvcHRpb25zID0ge31cbiAgaWYgKHNlbGYuYWdlbnRPcHRpb25zKSB7XG4gICAgZm9yICh2YXIgaSBpbiBzZWxmLmFnZW50T3B0aW9ucykge1xuICAgICAgb3B0aW9uc1tpXSA9IHNlbGYuYWdlbnRPcHRpb25zW2ldXG4gICAgfVxuICB9XG4gIGlmIChzZWxmLmNhKSB7XG4gICAgb3B0aW9ucy5jYSA9IHNlbGYuY2FcbiAgfVxuICBpZiAoc2VsZi5jaXBoZXJzKSB7XG4gICAgb3B0aW9ucy5jaXBoZXJzID0gc2VsZi5jaXBoZXJzXG4gIH1cbiAgaWYgKHNlbGYuc2VjdXJlUHJvdG9jb2wpIHtcbiAgICBvcHRpb25zLnNlY3VyZVByb3RvY29sID0gc2VsZi5zZWN1cmVQcm90b2NvbFxuICB9XG4gIGlmIChzZWxmLnNlY3VyZU9wdGlvbnMpIHtcbiAgICBvcHRpb25zLnNlY3VyZU9wdGlvbnMgPSBzZWxmLnNlY3VyZU9wdGlvbnNcbiAgfVxuICBpZiAodHlwZW9mIHNlbGYucmVqZWN0VW5hdXRob3JpemVkICE9PSAndW5kZWZpbmVkJykge1xuICAgIG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkID0gc2VsZi5yZWplY3RVbmF1dGhvcml6ZWRcbiAgfVxuXG4gIGlmIChzZWxmLmNlcnQgJiYgc2VsZi5rZXkpIHtcbiAgICBvcHRpb25zLmtleSA9IHNlbGYua2V5XG4gICAgb3B0aW9ucy5jZXJ0ID0gc2VsZi5jZXJ0XG4gIH1cblxuICBpZiAoc2VsZi5wZngpIHtcbiAgICBvcHRpb25zLnBmeCA9IHNlbGYucGZ4XG4gIH1cblxuICBpZiAoc2VsZi5wYXNzcGhyYXNlKSB7XG4gICAgb3B0aW9ucy5wYXNzcGhyYXNlID0gc2VsZi5wYXNzcGhyYXNlXG4gIH1cblxuICB2YXIgcG9vbEtleSA9ICcnXG5cbiAgLy8gZGlmZmVyZW50IHR5cGVzIG9mIGFnZW50cyBhcmUgaW4gZGlmZmVyZW50IHBvb2xzXG4gIGlmIChBZ2VudCAhPT0gc2VsZi5odHRwTW9kdWxlLkFnZW50KSB7XG4gICAgcG9vbEtleSArPSBBZ2VudC5uYW1lXG4gIH1cblxuICAvLyBjYSBvcHRpb24gaXMgb25seSByZWxldmFudCBpZiBwcm94eSBvciBkZXN0aW5hdGlvbiBhcmUgaHR0cHNcbiAgdmFyIHByb3h5ID0gc2VsZi5wcm94eVxuICBpZiAodHlwZW9mIHByb3h5ID09PSAnc3RyaW5nJykge1xuICAgIHByb3h5ID0gdXJsLnBhcnNlKHByb3h5KVxuICB9XG4gIHZhciBpc0h0dHBzID0gKHByb3h5ICYmIHByb3h5LnByb3RvY29sID09PSAnaHR0cHM6JykgfHwgdGhpcy51cmkucHJvdG9jb2wgPT09ICdodHRwczonXG5cbiAgaWYgKGlzSHR0cHMpIHtcbiAgICBpZiAob3B0aW9ucy5jYSkge1xuICAgICAgaWYgKHBvb2xLZXkpIHtcbiAgICAgICAgcG9vbEtleSArPSAnOidcbiAgICAgIH1cbiAgICAgIHBvb2xLZXkgKz0gb3B0aW9ucy5jYVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAocG9vbEtleSkge1xuICAgICAgICBwb29sS2V5ICs9ICc6J1xuICAgICAgfVxuICAgICAgcG9vbEtleSArPSBvcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZFxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNlcnQpIHtcbiAgICAgIGlmIChwb29sS2V5KSB7XG4gICAgICAgIHBvb2xLZXkgKz0gJzonXG4gICAgICB9XG4gICAgICBwb29sS2V5ICs9IG9wdGlvbnMuY2VydC50b1N0cmluZygnYXNjaWknKSArIG9wdGlvbnMua2V5LnRvU3RyaW5nKCdhc2NpaScpXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucGZ4KSB7XG4gICAgICBpZiAocG9vbEtleSkge1xuICAgICAgICBwb29sS2V5ICs9ICc6J1xuICAgICAgfVxuICAgICAgcG9vbEtleSArPSBvcHRpb25zLnBmeC50b1N0cmluZygnYXNjaWknKVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNpcGhlcnMpIHtcbiAgICAgIGlmIChwb29sS2V5KSB7XG4gICAgICAgIHBvb2xLZXkgKz0gJzonXG4gICAgICB9XG4gICAgICBwb29sS2V5ICs9IG9wdGlvbnMuY2lwaGVyc1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnNlY3VyZVByb3RvY29sKSB7XG4gICAgICBpZiAocG9vbEtleSkge1xuICAgICAgICBwb29sS2V5ICs9ICc6J1xuICAgICAgfVxuICAgICAgcG9vbEtleSArPSBvcHRpb25zLnNlY3VyZVByb3RvY29sXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc2VjdXJlT3B0aW9ucykge1xuICAgICAgaWYgKHBvb2xLZXkpIHtcbiAgICAgICAgcG9vbEtleSArPSAnOidcbiAgICAgIH1cbiAgICAgIHBvb2xLZXkgKz0gb3B0aW9ucy5zZWN1cmVPcHRpb25zXG4gICAgfVxuICB9XG5cbiAgaWYgKHNlbGYucG9vbCA9PT0gZ2xvYmFsUG9vbCAmJiAhcG9vbEtleSAmJiBPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGggPT09IDAgJiYgc2VsZi5odHRwTW9kdWxlLmdsb2JhbEFnZW50KSB7XG4gICAgLy8gbm90IGRvaW5nIGFueXRoaW5nIHNwZWNpYWwuICBVc2UgdGhlIGdsb2JhbEFnZW50XG4gICAgcmV0dXJuIHNlbGYuaHR0cE1vZHVsZS5nbG9iYWxBZ2VudFxuICB9XG5cbiAgLy8gd2UncmUgdXNpbmcgYSBzdG9yZWQgYWdlbnQuICBNYWtlIHN1cmUgaXQncyBwcm90b2NvbC1zcGVjaWZpY1xuICBwb29sS2V5ID0gc2VsZi51cmkucHJvdG9jb2wgKyBwb29sS2V5XG5cbiAgLy8gZ2VuZXJhdGUgYSBuZXcgYWdlbnQgZm9yIHRoaXMgc2V0dGluZyBpZiBub25lIHlldCBleGlzdHNcbiAgaWYgKCFzZWxmLnBvb2xbcG9vbEtleV0pIHtcbiAgICBzZWxmLnBvb2xbcG9vbEtleV0gPSBuZXcgQWdlbnQob3B0aW9ucylcbiAgICAvLyBwcm9wZXJseSBzZXQgbWF4U29ja2V0cyBvbiBuZXcgYWdlbnRzXG4gICAgaWYgKHNlbGYucG9vbC5tYXhTb2NrZXRzKSB7XG4gICAgICBzZWxmLnBvb2xbcG9vbEtleV0ubWF4U29ja2V0cyA9IHNlbGYucG9vbC5tYXhTb2NrZXRzXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlbGYucG9vbFtwb29sS2V5XVxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gc3RhcnQoKSBpcyBjYWxsZWQgb25jZSB3ZSBhcmUgcmVhZHkgdG8gc2VuZCB0aGUgb3V0Z29pbmcgSFRUUCByZXF1ZXN0LlxuICAvLyB0aGlzIGlzIHVzdWFsbHkgY2FsbGVkIG9uIHRoZSBmaXJzdCB3cml0ZSgpLCBlbmQoKSBvciBvbiBuZXh0VGljaygpXG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGlmIChzZWxmLnRpbWluZykge1xuICAgIC8vIEFsbCB0aW1pbmdzIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcyByZXF1ZXN0J3Mgc3RhcnRUaW1lLiAgSW4gb3JkZXIgdG8gZG8gdGhpcyxcbiAgICAvLyB3ZSBuZWVkIHRvIGNhcHR1cmUgdGhlIHdhbGwtY2xvY2sgc3RhcnQgdGltZSAodmlhIERhdGUpLCBpbW1lZGlhdGVseSBmb2xsb3dlZFxuICAgIC8vIGJ5IHRoZSBoaWdoLXJlc29sdXRpb24gdGltZXIgKHZpYSBub3coKSkuICBXaGlsZSB0aGVzZSB0d28gd29uJ3QgYmUgc2V0XG4gICAgLy8gYXQgdGhlIF9leGFjdF8gc2FtZSB0aW1lLCB0aGV5IHNob3VsZCBiZSBjbG9zZSBlbm91Z2ggdG8gYmUgYWJsZSB0byBjYWxjdWxhdGVcbiAgICAvLyBoaWdoLXJlc29sdXRpb24sIG1vbm90b25pY2FsbHkgbm9uLWRlY3JlYXNpbmcgdGltZXN0YW1wcyByZWxhdGl2ZSB0byBzdGFydFRpbWUuXG4gICAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgdmFyIHN0YXJ0VGltZU5vdyA9IG5vdygpXG4gIH1cblxuICBpZiAoc2VsZi5fYWJvcnRlZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgc2VsZi5fc3RhcnRlZCA9IHRydWVcbiAgc2VsZi5tZXRob2QgPSBzZWxmLm1ldGhvZCB8fCAnR0VUJ1xuICBzZWxmLmhyZWYgPSBzZWxmLnVyaS5ocmVmXG5cbiAgaWYgKHNlbGYuc3JjICYmIHNlbGYuc3JjLnN0YXQgJiYgc2VsZi5zcmMuc3RhdC5zaXplICYmICFzZWxmLmhhc0hlYWRlcignY29udGVudC1sZW5ndGgnKSkge1xuICAgIHNlbGYuc2V0SGVhZGVyKCdjb250ZW50LWxlbmd0aCcsIHNlbGYuc3JjLnN0YXQuc2l6ZSlcbiAgfVxuICBpZiAoc2VsZi5fYXdzKSB7XG4gICAgc2VsZi5hd3Moc2VsZi5fYXdzLCB0cnVlKVxuICB9XG5cbiAgLy8gV2UgaGF2ZSBhIG1ldGhvZCBuYW1lZCBhdXRoLCB3aGljaCBpcyBjb21wbGV0ZWx5IGRpZmZlcmVudCBmcm9tIHRoZSBodHRwLnJlcXVlc3RcbiAgLy8gYXV0aCBvcHRpb24uICBJZiB3ZSBkb24ndCByZW1vdmUgaXQsIHdlJ3JlIGdvbm5hIGhhdmUgYSBiYWQgdGltZS5cbiAgdmFyIHJlcU9wdGlvbnMgPSBjb3B5KHNlbGYpXG4gIGRlbGV0ZSByZXFPcHRpb25zLmF1dGhcblxuICBkZWJ1ZygnbWFrZSByZXF1ZXN0Jywgc2VsZi51cmkuaHJlZilcblxuICAvLyBub2RlIHY2LjguMCBub3cgc3VwcG9ydHMgYSBgdGltZW91dGAgdmFsdWUgaW4gYGh0dHAucmVxdWVzdCgpYCwgYnV0IHdlXG4gIC8vIHNob3VsZCBkZWxldGUgaXQgZm9yIG5vdyBzaW5jZSB3ZSBoYW5kbGUgdGltZW91dHMgbWFudWFsbHkgZm9yIGJldHRlclxuICAvLyBjb25zaXN0ZW5jeSB3aXRoIG5vZGUgdmVyc2lvbnMgYmVmb3JlIHY2LjguMFxuICBkZWxldGUgcmVxT3B0aW9ucy50aW1lb3V0XG5cbiAgdHJ5IHtcbiAgICBzZWxmLnJlcSA9IHNlbGYuaHR0cE1vZHVsZS5yZXF1ZXN0KHJlcU9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoc2VsZi50aW1pbmcpIHtcbiAgICBzZWxmLnN0YXJ0VGltZSA9IHN0YXJ0VGltZVxuICAgIHNlbGYuc3RhcnRUaW1lTm93ID0gc3RhcnRUaW1lTm93XG5cbiAgICAvLyBUaW1pbmcgdmFsdWVzIHdpbGwgYWxsIGJlIHJlbGF0aXZlIHRvIHN0YXJ0VGltZSAoYnkgY29tcGFyaW5nIHRvIHN0YXJ0VGltZU5vd1xuICAgIC8vIHNvIHdlIGhhdmUgYW4gYWNjdXJhdGUgY2xvY2spXG4gICAgc2VsZi50aW1pbmdzID0ge31cbiAgfVxuXG4gIHZhciB0aW1lb3V0XG4gIGlmIChzZWxmLnRpbWVvdXQgJiYgIXNlbGYudGltZW91dFRpbWVyKSB7XG4gICAgaWYgKHNlbGYudGltZW91dCA8IDApIHtcbiAgICAgIHRpbWVvdXQgPSAwXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZi50aW1lb3V0ID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZShzZWxmLnRpbWVvdXQpKSB7XG4gICAgICB0aW1lb3V0ID0gc2VsZi50aW1lb3V0XG4gICAgfVxuICB9XG5cbiAgc2VsZi5yZXEub24oJ3Jlc3BvbnNlJywgc2VsZi5vblJlcXVlc3RSZXNwb25zZS5iaW5kKHNlbGYpKVxuICBzZWxmLnJlcS5vbignZXJyb3InLCBzZWxmLm9uUmVxdWVzdEVycm9yLmJpbmQoc2VsZikpXG4gIHNlbGYucmVxLm9uKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmVtaXQoJ2RyYWluJylcbiAgfSlcblxuICBzZWxmLnJlcS5vbignc29ja2V0JywgZnVuY3Rpb24gKHNvY2tldCkge1xuICAgIC8vIGAuX2Nvbm5lY3RpbmdgIHdhcyB0aGUgb2xkIHByb3BlcnR5IHdoaWNoIHdhcyBtYWRlIHB1YmxpYyBpbiBub2RlIHY2LjEuMFxuICAgIHZhciBpc0Nvbm5lY3RpbmcgPSBzb2NrZXQuX2Nvbm5lY3RpbmcgfHwgc29ja2V0LmNvbm5lY3RpbmdcbiAgICBpZiAoc2VsZi50aW1pbmcpIHtcbiAgICAgIHNlbGYudGltaW5ncy5zb2NrZXQgPSBub3coKSAtIHNlbGYuc3RhcnRUaW1lTm93XG5cbiAgICAgIGlmIChpc0Nvbm5lY3RpbmcpIHtcbiAgICAgICAgdmFyIG9uTG9va3VwVGltaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYudGltaW5ncy5sb29rdXAgPSBub3coKSAtIHNlbGYuc3RhcnRUaW1lTm93XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb25Db25uZWN0VGltaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYudGltaW5ncy5jb25uZWN0ID0gbm93KCkgLSBzZWxmLnN0YXJ0VGltZU5vd1xuICAgICAgICB9XG5cbiAgICAgICAgc29ja2V0Lm9uY2UoJ2xvb2t1cCcsIG9uTG9va3VwVGltaW5nKVxuICAgICAgICBzb2NrZXQub25jZSgnY29ubmVjdCcsIG9uQ29ubmVjdFRpbWluZylcblxuICAgICAgICAvLyBjbGVhbiB1cCB0aW1pbmcgZXZlbnQgbGlzdGVuZXJzIGlmIG5lZWRlZCBvbiBlcnJvclxuICAgICAgICBzZWxmLnJlcS5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2xvb2t1cCcsIG9uTG9va3VwVGltaW5nKVxuICAgICAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignY29ubmVjdCcsIG9uQ29ubmVjdFRpbWluZylcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2V0UmVxVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFRoaXMgdGltZW91dCBzZXRzIHRoZSBhbW91bnQgb2YgdGltZSB0byB3YWl0ICpiZXR3ZWVuKiBieXRlcyBzZW50XG4gICAgICAvLyBmcm9tIHRoZSBzZXJ2ZXIgb25jZSBjb25uZWN0ZWQuXG4gICAgICAvL1xuICAgICAgLy8gSW4gcGFydGljdWxhciwgaXQncyB1c2VmdWwgZm9yIGVycm9yaW5nIGlmIHRoZSBzZXJ2ZXIgZmFpbHMgdG8gc2VuZFxuICAgICAgLy8gZGF0YSBoYWxmd2F5IHRocm91Z2ggc3RyZWFtaW5nIGEgcmVzcG9uc2UuXG4gICAgICBzZWxmLnJlcS5zZXRUaW1lb3V0KHRpbWVvdXQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNlbGYucmVxKSB7XG4gICAgICAgICAgc2VsZi5hYm9ydCgpXG4gICAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ0VTT0NLRVRUSU1FRE9VVCcpXG4gICAgICAgICAgZS5jb2RlID0gJ0VTT0NLRVRUSU1FRE9VVCdcbiAgICAgICAgICBlLmNvbm5lY3QgPSBmYWxzZVxuICAgICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICBpZiAodGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBPbmx5IHN0YXJ0IHRoZSBjb25uZWN0aW9uIHRpbWVyIGlmIHdlJ3JlIGFjdHVhbGx5IGNvbm5lY3RpbmcgYSBuZXdcbiAgICAgIC8vIHNvY2tldCwgb3RoZXJ3aXNlIGlmIHdlJ3JlIGFscmVhZHkgY29ubmVjdGVkIChiZWNhdXNlIHRoaXMgaXMgYVxuICAgICAgLy8ga2VlcC1hbGl2ZSBjb25uZWN0aW9uKSBkbyBub3QgYm90aGVyLiBUaGlzIGlzIGltcG9ydGFudCBzaW5jZSB3ZSB3b24ndFxuICAgICAgLy8gZ2V0IGEgJ2Nvbm5lY3QnIGV2ZW50IGZvciBhbiBhbHJlYWR5IGNvbm5lY3RlZCBzb2NrZXQuXG4gICAgICBpZiAoaXNDb25uZWN0aW5nKSB7XG4gICAgICAgIHZhciBvblJlcVNvY2tDb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignY29ubmVjdCcsIG9uUmVxU29ja0Nvbm5lY3QpXG4gICAgICAgICAgc2VsZi5jbGVhclRpbWVvdXQoKVxuICAgICAgICAgIHNldFJlcVRpbWVvdXQoKVxuICAgICAgICB9XG5cbiAgICAgICAgc29ja2V0Lm9uKCdjb25uZWN0Jywgb25SZXFTb2NrQ29ubmVjdClcblxuICAgICAgICBzZWxmLnJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaGFuZGxlLWNhbGxiYWNrLWVyclxuICAgICAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignY29ubmVjdCcsIG9uUmVxU29ja0Nvbm5lY3QpXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gU2V0IGEgdGltZW91dCBpbiBtZW1vcnkgLSB0aGlzIGJsb2NrIHdpbGwgdGhyb3cgaWYgdGhlIHNlcnZlciB0YWtlcyBtb3JlXG4gICAgICAgIC8vIHRoYW4gYHRpbWVvdXRgIHRvIHdyaXRlIHRoZSBIVFRQIHN0YXR1cyBhbmQgaGVhZGVycyAoY29ycmVzcG9uZGluZyB0b1xuICAgICAgICAvLyB0aGUgb24oJ3Jlc3BvbnNlJykgZXZlbnQgb24gdGhlIGNsaWVudCkuIE5COiB0aGlzIG1lYXN1cmVzIHdhbGwtY2xvY2tcbiAgICAgICAgLy8gdGltZSwgbm90IHRoZSB0aW1lIGJldHdlZW4gYnl0ZXMgc2VudCBieSB0aGUgc2VydmVyLlxuICAgICAgICBzZWxmLnRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignY29ubmVjdCcsIG9uUmVxU29ja0Nvbm5lY3QpXG4gICAgICAgICAgc2VsZi5hYm9ydCgpXG4gICAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ0VUSU1FRE9VVCcpXG4gICAgICAgICAgZS5jb2RlID0gJ0VUSU1FRE9VVCdcbiAgICAgICAgICBlLmNvbm5lY3QgPSB0cnVlXG4gICAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGUpXG4gICAgICAgIH0sIHRpbWVvdXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSdyZSBhbHJlYWR5IGNvbm5lY3RlZFxuICAgICAgICBzZXRSZXFUaW1lb3V0KClcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZi5lbWl0KCdzb2NrZXQnLCBzb2NrZXQpXG4gIH0pXG5cbiAgc2VsZi5lbWl0KCdyZXF1ZXN0Jywgc2VsZi5yZXEpXG59XG5cblJlcXVlc3QucHJvdG90eXBlLm9uUmVxdWVzdEVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5fYWJvcnRlZCkge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChzZWxmLnJlcSAmJiBzZWxmLnJlcS5fcmV1c2VkU29ja2V0ICYmIGVycm9yLmNvZGUgPT09ICdFQ09OTlJFU0VUJyAmJlxuICAgIHNlbGYuYWdlbnQuYWRkUmVxdWVzdE5vcmV1c2UpIHtcbiAgICBzZWxmLmFnZW50ID0geyBhZGRSZXF1ZXN0OiBzZWxmLmFnZW50LmFkZFJlcXVlc3ROb3JldXNlLmJpbmQoc2VsZi5hZ2VudCkgfVxuICAgIHNlbGYuc3RhcnQoKVxuICAgIHNlbGYucmVxLmVuZCgpXG4gICAgcmV0dXJuXG4gIH1cbiAgc2VsZi5jbGVhclRpbWVvdXQoKVxuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyb3IpXG59XG5cblJlcXVlc3QucHJvdG90eXBlLm9uUmVxdWVzdFJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGlmIChzZWxmLnRpbWluZykge1xuICAgIHNlbGYudGltaW5ncy5yZXNwb25zZSA9IG5vdygpIC0gc2VsZi5zdGFydFRpbWVOb3dcbiAgfVxuXG4gIGRlYnVnKCdvblJlcXVlc3RSZXNwb25zZScsIHNlbGYudXJpLmhyZWYsIHJlc3BvbnNlLnN0YXR1c0NvZGUsIHJlc3BvbnNlLmhlYWRlcnMpXG4gIHJlc3BvbnNlLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGYudGltaW5nKSB7XG4gICAgICBzZWxmLnRpbWluZ3MuZW5kID0gbm93KCkgLSBzZWxmLnN0YXJ0VGltZU5vd1xuICAgICAgcmVzcG9uc2UudGltaW5nU3RhcnQgPSBzZWxmLnN0YXJ0VGltZVxuXG4gICAgICAvLyBmaWxsIGluIHRoZSBibGFua3MgZm9yIGFueSBwZXJpb2RzIHRoYXQgZGlkbid0IHRyaWdnZXIsIHN1Y2ggYXNcbiAgICAgIC8vIG5vIGxvb2t1cCBvciBjb25uZWN0IGR1ZSB0byBrZWVwIGFsaXZlXG4gICAgICBpZiAoIXNlbGYudGltaW5ncy5zb2NrZXQpIHtcbiAgICAgICAgc2VsZi50aW1pbmdzLnNvY2tldCA9IDBcbiAgICAgIH1cbiAgICAgIGlmICghc2VsZi50aW1pbmdzLmxvb2t1cCkge1xuICAgICAgICBzZWxmLnRpbWluZ3MubG9va3VwID0gc2VsZi50aW1pbmdzLnNvY2tldFxuICAgICAgfVxuICAgICAgaWYgKCFzZWxmLnRpbWluZ3MuY29ubmVjdCkge1xuICAgICAgICBzZWxmLnRpbWluZ3MuY29ubmVjdCA9IHNlbGYudGltaW5ncy5sb29rdXBcbiAgICAgIH1cbiAgICAgIGlmICghc2VsZi50aW1pbmdzLnJlc3BvbnNlKSB7XG4gICAgICAgIHNlbGYudGltaW5ncy5yZXNwb25zZSA9IHNlbGYudGltaW5ncy5jb25uZWN0XG4gICAgICB9XG5cbiAgICAgIGRlYnVnKCdlbGFwc2VkIHRpbWUnLCBzZWxmLnRpbWluZ3MuZW5kKVxuXG4gICAgICAvLyBlbGFwc2VkVGltZSBpbmNsdWRlcyBhbGwgcmVkaXJlY3RzXG4gICAgICBzZWxmLmVsYXBzZWRUaW1lICs9IE1hdGgucm91bmQoc2VsZi50aW1pbmdzLmVuZClcblxuICAgICAgLy8gTk9URTogZWxhcHNlZFRpbWUgaXMgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiAudGltaW5nc1xuICAgICAgcmVzcG9uc2UuZWxhcHNlZFRpbWUgPSBzZWxmLmVsYXBzZWRUaW1lXG5cbiAgICAgIC8vIHRpbWluZ3MgaXMganVzdCBmb3IgdGhlIGZpbmFsIGZldGNoXG4gICAgICByZXNwb25zZS50aW1pbmdzID0gc2VsZi50aW1pbmdzXG5cbiAgICAgIC8vIHByZS1jYWxjdWxhdGUgcGhhc2UgdGltaW5ncyBhcyB3ZWxsXG4gICAgICByZXNwb25zZS50aW1pbmdQaGFzZXMgPSB7XG4gICAgICAgIHdhaXQ6IHNlbGYudGltaW5ncy5zb2NrZXQsXG4gICAgICAgIGRuczogc2VsZi50aW1pbmdzLmxvb2t1cCAtIHNlbGYudGltaW5ncy5zb2NrZXQsXG4gICAgICAgIHRjcDogc2VsZi50aW1pbmdzLmNvbm5lY3QgLSBzZWxmLnRpbWluZ3MubG9va3VwLFxuICAgICAgICBmaXJzdEJ5dGU6IHNlbGYudGltaW5ncy5yZXNwb25zZSAtIHNlbGYudGltaW5ncy5jb25uZWN0LFxuICAgICAgICBkb3dubG9hZDogc2VsZi50aW1pbmdzLmVuZCAtIHNlbGYudGltaW5ncy5yZXNwb25zZSxcbiAgICAgICAgdG90YWw6IHNlbGYudGltaW5ncy5lbmRcbiAgICAgIH1cbiAgICB9XG4gICAgZGVidWcoJ3Jlc3BvbnNlIGVuZCcsIHNlbGYudXJpLmhyZWYsIHJlc3BvbnNlLnN0YXR1c0NvZGUsIHJlc3BvbnNlLmhlYWRlcnMpXG4gIH0pXG5cbiAgaWYgKHNlbGYuX2Fib3J0ZWQpIHtcbiAgICBkZWJ1ZygnYWJvcnRlZCcsIHNlbGYudXJpLmhyZWYpXG4gICAgcmVzcG9uc2UucmVzdW1lKClcbiAgICByZXR1cm5cbiAgfVxuXG4gIHNlbGYucmVzcG9uc2UgPSByZXNwb25zZVxuICByZXNwb25zZS5yZXF1ZXN0ID0gc2VsZlxuICByZXNwb25zZS50b0pTT04gPSByZXNwb25zZVRvSlNPTlxuXG4gIC8vIFhYWCBUaGlzIGlzIGRpZmZlcmVudCBvbiAwLjEwLCBiZWNhdXNlIFNTTCBpcyBzdHJpY3QgYnkgZGVmYXVsdFxuICBpZiAoc2VsZi5odHRwTW9kdWxlID09PSBodHRwcyAmJlxuICAgIHNlbGYuc3RyaWN0U1NMICYmICghcmVzcG9uc2UuaGFzT3duUHJvcGVydHkoJ3NvY2tldCcpIHx8XG4gICAgIXJlc3BvbnNlLnNvY2tldC5hdXRob3JpemVkKSkge1xuICAgIGRlYnVnKCdzdHJpY3Qgc3NsIGVycm9yJywgc2VsZi51cmkuaHJlZilcbiAgICB2YXIgc3NsRXJyID0gcmVzcG9uc2UuaGFzT3duUHJvcGVydHkoJ3NvY2tldCcpID8gcmVzcG9uc2Uuc29ja2V0LmF1dGhvcml6YXRpb25FcnJvciA6IHNlbGYudXJpLmhyZWYgKyAnIGRvZXMgbm90IHN1cHBvcnQgU1NMJ1xuICAgIHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1NTTCBFcnJvcjogJyArIHNzbEVycikpXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBTYXZlIHRoZSBvcmlnaW5hbCBob3N0IGJlZm9yZSBhbnkgcmVkaXJlY3QgKGlmIGl0IGNoYW5nZXMsIHdlIG5lZWQgdG9cbiAgLy8gcmVtb3ZlIGFueSBhdXRob3JpemF0aW9uIGhlYWRlcnMpLiAgQWxzbyByZW1lbWJlciB0aGUgY2FzZSBvZiB0aGUgaGVhZGVyXG4gIC8vIG5hbWUgYmVjYXVzZSBsb3RzIG9mIGJyb2tlbiBzZXJ2ZXJzIGV4cGVjdCBIb3N0IGluc3RlYWQgb2YgaG9zdCBhbmQgd2VcbiAgLy8gd2FudCB0aGUgY2FsbGVyIHRvIGJlIGFibGUgdG8gc3BlY2lmeSB0aGlzLlxuICBzZWxmLm9yaWdpbmFsSG9zdCA9IHNlbGYuZ2V0SGVhZGVyKCdob3N0JylcbiAgaWYgKCFzZWxmLm9yaWdpbmFsSG9zdEhlYWRlck5hbWUpIHtcbiAgICBzZWxmLm9yaWdpbmFsSG9zdEhlYWRlck5hbWUgPSBzZWxmLmhhc0hlYWRlcignaG9zdCcpXG4gIH1cbiAgaWYgKHNlbGYuc2V0SG9zdCkge1xuICAgIHNlbGYucmVtb3ZlSGVhZGVyKCdob3N0JylcbiAgfVxuICBzZWxmLmNsZWFyVGltZW91dCgpXG5cbiAgdmFyIHRhcmdldENvb2tpZUphciA9IChzZWxmLl9qYXIgJiYgc2VsZi5famFyLnNldENvb2tpZSkgPyBzZWxmLl9qYXIgOiBnbG9iYWxDb29raWVKYXJcbiAgdmFyIGFkZENvb2tpZSA9IGZ1bmN0aW9uIChjb29raWUpIHtcbiAgICAvLyBzZXQgdGhlIGNvb2tpZSBpZiBpdCdzIGRvbWFpbiBpbiB0aGUgaHJlZidzIGRvbWFpbi5cbiAgICB0cnkge1xuICAgICAgdGFyZ2V0Q29va2llSmFyLnNldENvb2tpZShjb29raWUsIHNlbGYudXJpLmhyZWYsIHtpZ25vcmVFcnJvcjogdHJ1ZX0pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGUpXG4gICAgfVxuICB9XG5cbiAgcmVzcG9uc2UuY2FzZWxlc3MgPSBjYXNlbGVzcyhyZXNwb25zZS5oZWFkZXJzKVxuXG4gIGlmIChyZXNwb25zZS5jYXNlbGVzcy5oYXMoJ3NldC1jb29raWUnKSAmJiAoIXNlbGYuX2Rpc2FibGVDb29raWVzKSkge1xuICAgIHZhciBoZWFkZXJOYW1lID0gcmVzcG9uc2UuY2FzZWxlc3MuaGFzKCdzZXQtY29va2llJylcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXNwb25zZS5oZWFkZXJzW2hlYWRlck5hbWVdKSkge1xuICAgICAgcmVzcG9uc2UuaGVhZGVyc1toZWFkZXJOYW1lXS5mb3JFYWNoKGFkZENvb2tpZSlcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkQ29va2llKHJlc3BvbnNlLmhlYWRlcnNbaGVhZGVyTmFtZV0pXG4gICAgfVxuICB9XG5cbiAgaWYgKHNlbGYuX3JlZGlyZWN0Lm9uUmVzcG9uc2UocmVzcG9uc2UpKSB7XG4gICAgcmV0dXJuIC8vIElnbm9yZSB0aGUgcmVzdCBvZiB0aGUgcmVzcG9uc2VcbiAgfSBlbHNlIHtcbiAgICAvLyBCZSBhIGdvb2Qgc3RyZWFtIGFuZCBlbWl0IGVuZCB3aGVuIHRoZSByZXNwb25zZSBpcyBmaW5pc2hlZC5cbiAgICAvLyBIYWNrIHRvIGVtaXQgZW5kIG9uIGNsb3NlIGJlY2F1c2Ugb2YgYSBjb3JlIGJ1ZyB0aGF0IG5ldmVyIGZpcmVzIGVuZFxuICAgIHJlc3BvbnNlLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc2VsZi5fZW5kZWQpIHtcbiAgICAgICAgc2VsZi5yZXNwb25zZS5lbWl0KCdlbmQnKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXNwb25zZS5vbmNlKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLl9lbmRlZCA9IHRydWVcbiAgICB9KVxuXG4gICAgdmFyIG5vQm9keSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBzZWxmLm1ldGhvZCA9PT0gJ0hFQUQnIHx8XG4gICAgICAgIC8vIEluZm9ybWF0aW9uYWxcbiAgICAgICAgKGNvZGUgPj0gMTAwICYmIGNvZGUgPCAyMDApIHx8XG4gICAgICAgIC8vIE5vIENvbnRlbnRcbiAgICAgICAgY29kZSA9PT0gMjA0IHx8XG4gICAgICAgIC8vIE5vdCBNb2RpZmllZFxuICAgICAgICBjb2RlID09PSAzMDRcbiAgICAgIClcbiAgICB9XG5cbiAgICB2YXIgcmVzcG9uc2VDb250ZW50XG4gICAgaWYgKHNlbGYuZ3ppcCAmJiAhbm9Cb2R5KHJlc3BvbnNlLnN0YXR1c0NvZGUpKSB7XG4gICAgICB2YXIgY29udGVudEVuY29kaW5nID0gcmVzcG9uc2UuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddIHx8ICdpZGVudGl0eSdcbiAgICAgIGNvbnRlbnRFbmNvZGluZyA9IGNvbnRlbnRFbmNvZGluZy50cmltKCkudG9Mb3dlckNhc2UoKVxuXG4gICAgICAvLyBCZSBtb3JlIGxlbmllbnQgd2l0aCBkZWNvZGluZyBjb21wcmVzc2VkIHJlc3BvbnNlcywgc2luY2UgKHZlcnkgcmFyZWx5KVxuICAgICAgLy8gc2VydmVycyBzZW5kIHNsaWdodGx5IGludmFsaWQgZ3ppcCByZXNwb25zZXMgdGhhdCBhcmUgc3RpbGwgYWNjZXB0ZWRcbiAgICAgIC8vIGJ5IGNvbW1vbiBicm93c2Vycy5cbiAgICAgIC8vIEFsd2F5cyB1c2luZyBaX1NZTkNfRkxVU0ggaXMgd2hhdCBjVVJMIGRvZXMuXG4gICAgICB2YXIgemxpYk9wdGlvbnMgPSB7XG4gICAgICAgIGZsdXNoOiB6bGliLlpfU1lOQ19GTFVTSCxcbiAgICAgICAgZmluaXNoRmx1c2g6IHpsaWIuWl9TWU5DX0ZMVVNIXG4gICAgICB9XG5cbiAgICAgIGlmIChjb250ZW50RW5jb2RpbmcgPT09ICdnemlwJykge1xuICAgICAgICByZXNwb25zZUNvbnRlbnQgPSB6bGliLmNyZWF0ZUd1bnppcCh6bGliT3B0aW9ucylcbiAgICAgICAgcmVzcG9uc2UucGlwZShyZXNwb25zZUNvbnRlbnQpXG4gICAgICB9IGVsc2UgaWYgKGNvbnRlbnRFbmNvZGluZyA9PT0gJ2RlZmxhdGUnKSB7XG4gICAgICAgIHJlc3BvbnNlQ29udGVudCA9IHpsaWIuY3JlYXRlSW5mbGF0ZSh6bGliT3B0aW9ucylcbiAgICAgICAgcmVzcG9uc2UucGlwZShyZXNwb25zZUNvbnRlbnQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTaW5jZSBwcmV2aW91cyB2ZXJzaW9ucyBkaWRuJ3QgY2hlY2sgZm9yIENvbnRlbnQtRW5jb2RpbmcgaGVhZGVyLFxuICAgICAgICAvLyBpZ25vcmUgYW55IGludmFsaWQgdmFsdWVzIHRvIHByZXNlcnZlIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5XG4gICAgICAgIGlmIChjb250ZW50RW5jb2RpbmcgIT09ICdpZGVudGl0eScpIHtcbiAgICAgICAgICBkZWJ1ZygnaWdub3JpbmcgdW5yZWNvZ25pemVkIENvbnRlbnQtRW5jb2RpbmcgJyArIGNvbnRlbnRFbmNvZGluZylcbiAgICAgICAgfVxuICAgICAgICByZXNwb25zZUNvbnRlbnQgPSByZXNwb25zZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXNwb25zZUNvbnRlbnQgPSByZXNwb25zZVxuICAgIH1cblxuICAgIGlmIChzZWxmLmVuY29kaW5nKSB7XG4gICAgICBpZiAoc2VsZi5kZXN0cy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignSWdub3JpbmcgZW5jb2RpbmcgcGFyYW1ldGVyIGFzIHRoaXMgc3RyZWFtIGlzIGJlaW5nIHBpcGVkIHRvIGFub3RoZXIgc3RyZWFtIHdoaWNoIG1ha2VzIHRoZSBlbmNvZGluZyBvcHRpb24gaW52YWxpZC4nKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzcG9uc2VDb250ZW50LnNldEVuY29kaW5nKHNlbGYuZW5jb2RpbmcpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuX3BhdXNlZCkge1xuICAgICAgcmVzcG9uc2VDb250ZW50LnBhdXNlKClcbiAgICB9XG5cbiAgICBzZWxmLnJlc3BvbnNlQ29udGVudCA9IHJlc3BvbnNlQ29udGVudFxuXG4gICAgc2VsZi5lbWl0KCdyZXNwb25zZScsIHJlc3BvbnNlKVxuXG4gICAgc2VsZi5kZXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChkZXN0KSB7XG4gICAgICBzZWxmLnBpcGVEZXN0KGRlc3QpXG4gICAgfSlcblxuICAgIHJlc3BvbnNlQ29udGVudC5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgaWYgKHNlbGYudGltaW5nICYmICFzZWxmLnJlc3BvbnNlU3RhcnRlZCkge1xuICAgICAgICBzZWxmLnJlc3BvbnNlU3RhcnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKVxuXG4gICAgICAgIC8vIE5PVEU6IHJlc3BvbnNlU3RhcnRUaW1lIGlzIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgLnRpbWluZ3NcbiAgICAgICAgcmVzcG9uc2UucmVzcG9uc2VTdGFydFRpbWUgPSBzZWxmLnJlc3BvbnNlU3RhcnRUaW1lXG4gICAgICB9XG4gICAgICBzZWxmLl9kZXN0ZGF0YSA9IHRydWVcbiAgICAgIHNlbGYuZW1pdCgnZGF0YScsIGNodW5rKVxuICAgIH0pXG4gICAgcmVzcG9uc2VDb250ZW50Lm9uY2UoJ2VuZCcsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgc2VsZi5lbWl0KCdlbmQnLCBjaHVuaylcbiAgICB9KVxuICAgIHJlc3BvbnNlQ29udGVudC5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnJvcilcbiAgICB9KVxuICAgIHJlc3BvbnNlQ29udGVudC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7IHNlbGYuZW1pdCgnY2xvc2UnKSB9KVxuXG4gICAgaWYgKHNlbGYuY2FsbGJhY2spIHtcbiAgICAgIHNlbGYucmVhZFJlc3BvbnNlQm9keShyZXNwb25zZSlcbiAgICB9IGVsc2UgeyAvLyBpZiBubyBjYWxsYmFja1xuICAgICAgc2VsZi5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc2VsZi5fYWJvcnRlZCkge1xuICAgICAgICAgIGRlYnVnKCdhYm9ydGVkJywgc2VsZi51cmkuaHJlZilcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBzZWxmLmVtaXQoJ2NvbXBsZXRlJywgcmVzcG9uc2UpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuICBkZWJ1ZygnZmluaXNoIGluaXQgZnVuY3Rpb24nLCBzZWxmLnVyaS5ocmVmKVxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5yZWFkUmVzcG9uc2VCb2R5ID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBkZWJ1ZyhcInJlYWRpbmcgcmVzcG9uc2UncyBib2R5XCIpXG4gIHZhciBidWZmZXJzID0gW11cbiAgdmFyIGJ1ZmZlckxlbmd0aCA9IDBcbiAgdmFyIHN0cmluZ3MgPSBbXVxuXG4gIHNlbGYub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICAgIHN0cmluZ3MucHVzaChjaHVuaylcbiAgICB9IGVsc2UgaWYgKGNodW5rLmxlbmd0aCkge1xuICAgICAgYnVmZmVyTGVuZ3RoICs9IGNodW5rLmxlbmd0aFxuICAgICAgYnVmZmVycy5wdXNoKGNodW5rKVxuICAgIH1cbiAgfSlcbiAgc2VsZi5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCdlbmQgZXZlbnQnLCBzZWxmLnVyaS5ocmVmKVxuICAgIGlmIChzZWxmLl9hYm9ydGVkKSB7XG4gICAgICBkZWJ1ZygnYWJvcnRlZCcsIHNlbGYudXJpLmhyZWYpXG4gICAgICAvLyBgYnVmZmVyYCBpcyBkZWZpbmVkIGluIHRoZSBwYXJlbnQgc2NvcGUgYW5kIHVzZWQgaW4gYSBjbG9zdXJlIGl0IGV4aXN0cyBmb3IgdGhlIGxpZmUgb2YgdGhlIHJlcXVlc3QuXG4gICAgICAvLyBUaGlzIGNhbiBsZWFkIHRvIGxlYWt5IGJlaGF2aW9yIGlmIHRoZSB1c2VyIHJldGFpbnMgYSByZWZlcmVuY2UgdG8gdGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgICAgYnVmZmVycyA9IFtdXG4gICAgICBidWZmZXJMZW5ndGggPSAwXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoYnVmZmVyTGVuZ3RoKSB7XG4gICAgICBkZWJ1ZygnaGFzIGJvZHknLCBzZWxmLnVyaS5ocmVmLCBidWZmZXJMZW5ndGgpXG4gICAgICByZXNwb25zZS5ib2R5ID0gQnVmZmVyLmNvbmNhdChidWZmZXJzLCBidWZmZXJMZW5ndGgpXG4gICAgICBpZiAoc2VsZi5lbmNvZGluZyAhPT0gbnVsbCkge1xuICAgICAgICByZXNwb25zZS5ib2R5ID0gcmVzcG9uc2UuYm9keS50b1N0cmluZyhzZWxmLmVuY29kaW5nKVxuICAgICAgfVxuICAgICAgLy8gYGJ1ZmZlcmAgaXMgZGVmaW5lZCBpbiB0aGUgcGFyZW50IHNjb3BlIGFuZCB1c2VkIGluIGEgY2xvc3VyZSBpdCBleGlzdHMgZm9yIHRoZSBsaWZlIG9mIHRoZSBSZXF1ZXN0LlxuICAgICAgLy8gVGhpcyBjYW4gbGVhZCB0byBsZWFreSBiZWhhdmlvciBpZiB0aGUgdXNlciByZXRhaW5zIGEgcmVmZXJlbmNlIHRvIHRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICAgIGJ1ZmZlcnMgPSBbXVxuICAgICAgYnVmZmVyTGVuZ3RoID0gMFxuICAgIH0gZWxzZSBpZiAoc3RyaW5ncy5sZW5ndGgpIHtcbiAgICAgIC8vIFRoZSBVVEY4IEJPTSBbMHhFRiwweEJCLDB4QkZdIGlzIGNvbnZlcnRlZCB0byBbMHhGRSwweEZGXSBpbiB0aGUgSlMgVVRDMTYvVUNTMiByZXByZXNlbnRhdGlvbi5cbiAgICAgIC8vIFN0cmlwIHRoaXMgdmFsdWUgb3V0IHdoZW4gdGhlIGVuY29kaW5nIGlzIHNldCB0byAndXRmOCcsIGFzIHVwc3RyZWFtIGNvbnN1bWVycyB3b24ndCBleHBlY3QgaXQgYW5kIGl0IGJyZWFrcyBKU09OLnBhcnNlKCkuXG4gICAgICBpZiAoc2VsZi5lbmNvZGluZyA9PT0gJ3V0ZjgnICYmIHN0cmluZ3NbMF0ubGVuZ3RoID4gMCAmJiBzdHJpbmdzWzBdWzBdID09PSAnXFx1RkVGRicpIHtcbiAgICAgICAgc3RyaW5nc1swXSA9IHN0cmluZ3NbMF0uc3Vic3RyaW5nKDEpXG4gICAgICB9XG4gICAgICByZXNwb25zZS5ib2R5ID0gc3RyaW5ncy5qb2luKCcnKVxuICAgIH1cblxuICAgIGlmIChzZWxmLl9qc29uKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXNwb25zZS5ib2R5ID0gSlNPTi5wYXJzZShyZXNwb25zZS5ib2R5LCBzZWxmLl9qc29uUmV2aXZlcilcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVidWcoJ2ludmFsaWQgSlNPTiByZWNlaXZlZCcsIHNlbGYudXJpLmhyZWYpXG4gICAgICB9XG4gICAgfVxuICAgIGRlYnVnKCdlbWl0dGluZyBjb21wbGV0ZScsIHNlbGYudXJpLmhyZWYpXG4gICAgaWYgKHR5cGVvZiByZXNwb25zZS5ib2R5ID09PSAndW5kZWZpbmVkJyAmJiAhc2VsZi5fanNvbikge1xuICAgICAgcmVzcG9uc2UuYm9keSA9IHNlbGYuZW5jb2RpbmcgPT09IG51bGwgPyBCdWZmZXIuYWxsb2MoMCkgOiAnJ1xuICAgIH1cbiAgICBzZWxmLmVtaXQoJ2NvbXBsZXRlJywgcmVzcG9uc2UsIHJlc3BvbnNlLmJvZHkpXG4gIH0pXG59XG5cblJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5fYWJvcnRlZCA9IHRydWVcblxuICBpZiAoc2VsZi5yZXEpIHtcbiAgICBzZWxmLnJlcS5hYm9ydCgpXG4gIH0gZWxzZSBpZiAoc2VsZi5yZXNwb25zZSkge1xuICAgIHNlbGYucmVzcG9uc2UuZGVzdHJveSgpXG4gIH1cblxuICBzZWxmLmNsZWFyVGltZW91dCgpXG4gIHNlbGYuZW1pdCgnYWJvcnQnKVxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5waXBlRGVzdCA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgcmVzcG9uc2UgPSBzZWxmLnJlc3BvbnNlXG4gIC8vIENhbGxlZCBhZnRlciB0aGUgcmVzcG9uc2UgaXMgcmVjZWl2ZWRcbiAgaWYgKGRlc3QuaGVhZGVycyAmJiAhZGVzdC5oZWFkZXJzU2VudCkge1xuICAgIGlmIChyZXNwb25zZS5jYXNlbGVzcy5oYXMoJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICB2YXIgY3RuYW1lID0gcmVzcG9uc2UuY2FzZWxlc3MuaGFzKCdjb250ZW50LXR5cGUnKVxuICAgICAgaWYgKGRlc3Quc2V0SGVhZGVyKSB7XG4gICAgICAgIGRlc3Quc2V0SGVhZGVyKGN0bmFtZSwgcmVzcG9uc2UuaGVhZGVyc1tjdG5hbWVdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVzdC5oZWFkZXJzW2N0bmFtZV0gPSByZXNwb25zZS5oZWFkZXJzW2N0bmFtZV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVzcG9uc2UuY2FzZWxlc3MuaGFzKCdjb250ZW50LWxlbmd0aCcpKSB7XG4gICAgICB2YXIgY2xuYW1lID0gcmVzcG9uc2UuY2FzZWxlc3MuaGFzKCdjb250ZW50LWxlbmd0aCcpXG4gICAgICBpZiAoZGVzdC5zZXRIZWFkZXIpIHtcbiAgICAgICAgZGVzdC5zZXRIZWFkZXIoY2xuYW1lLCByZXNwb25zZS5oZWFkZXJzW2NsbmFtZV0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXN0LmhlYWRlcnNbY2xuYW1lXSA9IHJlc3BvbnNlLmhlYWRlcnNbY2xuYW1lXVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoZGVzdC5zZXRIZWFkZXIgJiYgIWRlc3QuaGVhZGVyc1NlbnQpIHtcbiAgICBmb3IgKHZhciBpIGluIHJlc3BvbnNlLmhlYWRlcnMpIHtcbiAgICAgIC8vIElmIHRoZSByZXNwb25zZSBjb250ZW50IGlzIGJlaW5nIGRlY29kZWQsIHRoZSBDb250ZW50LUVuY29kaW5nIGhlYWRlclxuICAgICAgLy8gb2YgdGhlIHJlc3BvbnNlIGRvZXNuJ3QgcmVwcmVzZW50IHRoZSBwaXBlZCBjb250ZW50LCBzbyBkb24ndCBwYXNzIGl0LlxuICAgICAgaWYgKCFzZWxmLmd6aXAgfHwgaSAhPT0gJ2NvbnRlbnQtZW5jb2RpbmcnKSB7XG4gICAgICAgIGRlc3Quc2V0SGVhZGVyKGksIHJlc3BvbnNlLmhlYWRlcnNbaV0pXG4gICAgICB9XG4gICAgfVxuICAgIGRlc3Quc3RhdHVzQ29kZSA9IHJlc3BvbnNlLnN0YXR1c0NvZGVcbiAgfVxuICBpZiAoc2VsZi5waXBlZmlsdGVyKSB7XG4gICAgc2VsZi5waXBlZmlsdGVyKHJlc3BvbnNlLCBkZXN0KVxuICB9XG59XG5cblJlcXVlc3QucHJvdG90eXBlLnFzID0gZnVuY3Rpb24gKHEsIGNsb2JiZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBiYXNlXG4gIGlmICghY2xvYmJlciAmJiBzZWxmLnVyaS5xdWVyeSkge1xuICAgIGJhc2UgPSBzZWxmLl9xcy5wYXJzZShzZWxmLnVyaS5xdWVyeSlcbiAgfSBlbHNlIHtcbiAgICBiYXNlID0ge31cbiAgfVxuXG4gIGZvciAodmFyIGkgaW4gcSkge1xuICAgIGJhc2VbaV0gPSBxW2ldXG4gIH1cblxuICB2YXIgcXMgPSBzZWxmLl9xcy5zdHJpbmdpZnkoYmFzZSlcblxuICBpZiAocXMgPT09ICcnKSB7XG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuXG4gIHNlbGYudXJpID0gdXJsLnBhcnNlKHNlbGYudXJpLmhyZWYuc3BsaXQoJz8nKVswXSArICc/JyArIHFzKVxuICBzZWxmLnVybCA9IHNlbGYudXJpXG4gIHNlbGYucGF0aCA9IHNlbGYudXJpLnBhdGhcblxuICBpZiAoc2VsZi51cmkuaG9zdCA9PT0gJ3VuaXgnKSB7XG4gICAgc2VsZi5lbmFibGVVbml4U29ja2V0KClcbiAgfVxuXG4gIHJldHVybiBzZWxmXG59XG5SZXF1ZXN0LnByb3RvdHlwZS5mb3JtID0gZnVuY3Rpb24gKGZvcm0pIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChmb3JtKSB7XG4gICAgaWYgKCEvXmFwcGxpY2F0aW9uXFwveC13d3ctZm9ybS11cmxlbmNvZGVkXFxiLy50ZXN0KHNlbGYuZ2V0SGVhZGVyKCdjb250ZW50LXR5cGUnKSkpIHtcbiAgICAgIHNlbGYuc2V0SGVhZGVyKCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJylcbiAgICB9XG4gICAgc2VsZi5ib2R5ID0gKHR5cGVvZiBmb3JtID09PSAnc3RyaW5nJylcbiAgICAgID8gc2VsZi5fcXMucmZjMzk4Nihmb3JtLnRvU3RyaW5nKCd1dGY4JykpXG4gICAgICA6IHNlbGYuX3FzLnN0cmluZ2lmeShmb3JtKS50b1N0cmluZygndXRmOCcpXG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuICAvLyBjcmVhdGUgZm9ybS1kYXRhIG9iamVjdFxuICBzZWxmLl9mb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgc2VsZi5fZm9ybS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgZXJyLm1lc3NhZ2UgPSAnZm9ybS1kYXRhOiAnICsgZXJyLm1lc3NhZ2VcbiAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgIHNlbGYuYWJvcnQoKVxuICB9KVxuICByZXR1cm4gc2VsZi5fZm9ybVxufVxuUmVxdWVzdC5wcm90b3R5cGUubXVsdGlwYXJ0ID0gZnVuY3Rpb24gKG11bHRpcGFydCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBzZWxmLl9tdWx0aXBhcnQub25SZXF1ZXN0KG11bHRpcGFydClcblxuICBpZiAoIXNlbGYuX211bHRpcGFydC5jaHVua2VkKSB7XG4gICAgc2VsZi5ib2R5ID0gc2VsZi5fbXVsdGlwYXJ0LmJvZHlcbiAgfVxuXG4gIHJldHVybiBzZWxmXG59XG5SZXF1ZXN0LnByb3RvdHlwZS5qc29uID0gZnVuY3Rpb24gKHZhbCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBpZiAoIXNlbGYuaGFzSGVhZGVyKCdhY2NlcHQnKSkge1xuICAgIHNlbGYuc2V0SGVhZGVyKCdhY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpXG4gIH1cblxuICBpZiAodHlwZW9mIHNlbGYuanNvblJlcGxhY2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2VsZi5fanNvblJlcGxhY2VyID0gc2VsZi5qc29uUmVwbGFjZXJcbiAgfVxuXG4gIHNlbGYuX2pzb24gPSB0cnVlXG4gIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICBpZiAoc2VsZi5ib2R5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghL15hcHBsaWNhdGlvblxcL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFxcYi8udGVzdChzZWxmLmdldEhlYWRlcignY29udGVudC10eXBlJykpKSB7XG4gICAgICAgIHNlbGYuYm9keSA9IHNhZmVTdHJpbmdpZnkoc2VsZi5ib2R5LCBzZWxmLl9qc29uUmVwbGFjZXIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmJvZHkgPSBzZWxmLl9xcy5yZmMzOTg2KHNlbGYuYm9keSlcbiAgICAgIH1cbiAgICAgIGlmICghc2VsZi5oYXNIZWFkZXIoJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICAgIHNlbGYuc2V0SGVhZGVyKCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNlbGYuYm9keSA9IHNhZmVTdHJpbmdpZnkodmFsLCBzZWxmLl9qc29uUmVwbGFjZXIpXG4gICAgaWYgKCFzZWxmLmhhc0hlYWRlcignY29udGVudC10eXBlJykpIHtcbiAgICAgIHNlbGYuc2V0SGVhZGVyKCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpXG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBzZWxmLmpzb25SZXZpdmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2VsZi5fanNvblJldml2ZXIgPSBzZWxmLmpzb25SZXZpdmVyXG4gIH1cblxuICByZXR1cm4gc2VsZlxufVxuUmVxdWVzdC5wcm90b3R5cGUuZ2V0SGVhZGVyID0gZnVuY3Rpb24gKG5hbWUsIGhlYWRlcnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciByZXN1bHQsIHJlLCBtYXRjaFxuICBpZiAoIWhlYWRlcnMpIHtcbiAgICBoZWFkZXJzID0gc2VsZi5oZWFkZXJzXG4gIH1cbiAgT2JqZWN0LmtleXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGtleS5sZW5ndGggIT09IG5hbWUubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgcmUgPSBuZXcgUmVnRXhwKG5hbWUsICdpJylcbiAgICBtYXRjaCA9IGtleS5tYXRjaChyZSlcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHJlc3VsdCA9IGhlYWRlcnNba2V5XVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIHJlc3VsdFxufVxuUmVxdWVzdC5wcm90b3R5cGUuZW5hYmxlVW5peFNvY2tldCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gR2V0IHRoZSBzb2NrZXQgJiByZXF1ZXN0IHBhdGhzIGZyb20gdGhlIFVSTFxuICB2YXIgdW5peFBhcnRzID0gdGhpcy51cmkucGF0aC5zcGxpdCgnOicpXG4gIHZhciBob3N0ID0gdW5peFBhcnRzWzBdXG4gIHZhciBwYXRoID0gdW5peFBhcnRzWzFdXG4gIC8vIEFwcGx5IHVuaXggcHJvcGVydGllcyB0byByZXF1ZXN0XG4gIHRoaXMuc29ja2V0UGF0aCA9IGhvc3RcbiAgdGhpcy51cmkucGF0aG5hbWUgPSBwYXRoXG4gIHRoaXMudXJpLnBhdGggPSBwYXRoXG4gIHRoaXMudXJpLmhvc3QgPSBob3N0XG4gIHRoaXMudXJpLmhvc3RuYW1lID0gaG9zdFxuICB0aGlzLnVyaS5pc1VuaXggPSB0cnVlXG59XG5cblJlcXVlc3QucHJvdG90eXBlLmF1dGggPSBmdW5jdGlvbiAodXNlciwgcGFzcywgc2VuZEltbWVkaWF0ZWx5LCBiZWFyZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgc2VsZi5fYXV0aC5vblJlcXVlc3QodXNlciwgcGFzcywgc2VuZEltbWVkaWF0ZWx5LCBiZWFyZXIpXG5cbiAgcmV0dXJuIHNlbGZcbn1cblJlcXVlc3QucHJvdG90eXBlLmF3cyA9IGZ1bmN0aW9uIChvcHRzLCBub3cpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgaWYgKCFub3cpIHtcbiAgICBzZWxmLl9hd3MgPSBvcHRzXG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuXG4gIGlmIChvcHRzLnNpZ25fdmVyc2lvbiA9PT0gNCB8fCBvcHRzLnNpZ25fdmVyc2lvbiA9PT0gJzQnKSB7XG4gICAgLy8gdXNlIGF3czRcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIGhvc3Q6IHNlbGYudXJpLmhvc3QsXG4gICAgICBwYXRoOiBzZWxmLnVyaS5wYXRoLFxuICAgICAgbWV0aG9kOiBzZWxmLm1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IHNlbGYuaGVhZGVycyxcbiAgICAgIGJvZHk6IHNlbGYuYm9keVxuICAgIH1cbiAgICBpZiAob3B0cy5zZXJ2aWNlKSB7XG4gICAgICBvcHRpb25zLnNlcnZpY2UgPSBvcHRzLnNlcnZpY2VcbiAgICB9XG4gICAgdmFyIHNpZ25SZXMgPSBhd3M0LnNpZ24ob3B0aW9ucywge1xuICAgICAgYWNjZXNzS2V5SWQ6IG9wdHMua2V5LFxuICAgICAgc2VjcmV0QWNjZXNzS2V5OiBvcHRzLnNlY3JldCxcbiAgICAgIHNlc3Npb25Ub2tlbjogb3B0cy5zZXNzaW9uXG4gICAgfSlcbiAgICBzZWxmLnNldEhlYWRlcignYXV0aG9yaXphdGlvbicsIHNpZ25SZXMuaGVhZGVycy5BdXRob3JpemF0aW9uKVxuICAgIHNlbGYuc2V0SGVhZGVyKCd4LWFtei1kYXRlJywgc2lnblJlcy5oZWFkZXJzWydYLUFtei1EYXRlJ10pXG4gICAgaWYgKHNpZ25SZXMuaGVhZGVyc1snWC1BbXotU2VjdXJpdHktVG9rZW4nXSkge1xuICAgICAgc2VsZi5zZXRIZWFkZXIoJ3gtYW16LXNlY3VyaXR5LXRva2VuJywgc2lnblJlcy5oZWFkZXJzWydYLUFtei1TZWN1cml0eS1Ub2tlbiddKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkZWZhdWx0OiB1c2UgYXdzLXNpZ24yXG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpXG4gICAgc2VsZi5zZXRIZWFkZXIoJ2RhdGUnLCBkYXRlLnRvVVRDU3RyaW5nKCkpXG4gICAgdmFyIGF1dGggPSB7XG4gICAgICBrZXk6IG9wdHMua2V5LFxuICAgICAgc2VjcmV0OiBvcHRzLnNlY3JldCxcbiAgICAgIHZlcmI6IHNlbGYubWV0aG9kLnRvVXBwZXJDYXNlKCksXG4gICAgICBkYXRlOiBkYXRlLFxuICAgICAgY29udGVudFR5cGU6IHNlbGYuZ2V0SGVhZGVyKCdjb250ZW50LXR5cGUnKSB8fCAnJyxcbiAgICAgIG1kNTogc2VsZi5nZXRIZWFkZXIoJ2NvbnRlbnQtbWQ1JykgfHwgJycsXG4gICAgICBhbWF6b25IZWFkZXJzOiBhd3MyLmNhbm9uaWNhbGl6ZUhlYWRlcnMoc2VsZi5oZWFkZXJzKVxuICAgIH1cbiAgICB2YXIgcGF0aCA9IHNlbGYudXJpLnBhdGhcbiAgICBpZiAob3B0cy5idWNrZXQgJiYgcGF0aCkge1xuICAgICAgYXV0aC5yZXNvdXJjZSA9ICcvJyArIG9wdHMuYnVja2V0ICsgcGF0aFxuICAgIH0gZWxzZSBpZiAob3B0cy5idWNrZXQgJiYgIXBhdGgpIHtcbiAgICAgIGF1dGgucmVzb3VyY2UgPSAnLycgKyBvcHRzLmJ1Y2tldFxuICAgIH0gZWxzZSBpZiAoIW9wdHMuYnVja2V0ICYmIHBhdGgpIHtcbiAgICAgIGF1dGgucmVzb3VyY2UgPSBwYXRoXG4gICAgfSBlbHNlIGlmICghb3B0cy5idWNrZXQgJiYgIXBhdGgpIHtcbiAgICAgIGF1dGgucmVzb3VyY2UgPSAnLydcbiAgICB9XG4gICAgYXV0aC5yZXNvdXJjZSA9IGF3czIuY2Fub25pY2FsaXplUmVzb3VyY2UoYXV0aC5yZXNvdXJjZSlcbiAgICBzZWxmLnNldEhlYWRlcignYXV0aG9yaXphdGlvbicsIGF3czIuYXV0aG9yaXphdGlvbihhdXRoKSlcbiAgfVxuXG4gIHJldHVybiBzZWxmXG59XG5SZXF1ZXN0LnByb3RvdHlwZS5odHRwU2lnbmF0dXJlID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGh0dHBTaWduYXR1cmUuc2lnblJlcXVlc3Qoe1xuICAgIGdldEhlYWRlcjogZnVuY3Rpb24gKGhlYWRlcikge1xuICAgICAgcmV0dXJuIHNlbGYuZ2V0SGVhZGVyKGhlYWRlciwgc2VsZi5oZWFkZXJzKVxuICAgIH0sXG4gICAgc2V0SGVhZGVyOiBmdW5jdGlvbiAoaGVhZGVyLCB2YWx1ZSkge1xuICAgICAgc2VsZi5zZXRIZWFkZXIoaGVhZGVyLCB2YWx1ZSlcbiAgICB9LFxuICAgIG1ldGhvZDogc2VsZi5tZXRob2QsXG4gICAgcGF0aDogc2VsZi5wYXRoXG4gIH0sIG9wdHMpXG4gIGRlYnVnKCdodHRwU2lnbmF0dXJlIGF1dGhvcml6YXRpb24nLCBzZWxmLmdldEhlYWRlcignYXV0aG9yaXphdGlvbicpKVxuXG4gIHJldHVybiBzZWxmXG59XG5SZXF1ZXN0LnByb3RvdHlwZS5oYXdrID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuc2V0SGVhZGVyKCdBdXRob3JpemF0aW9uJywgaGF3ay5oZWFkZXIoc2VsZi51cmksIHNlbGYubWV0aG9kLCBvcHRzKSlcbn1cblJlcXVlc3QucHJvdG90eXBlLm9hdXRoID0gZnVuY3Rpb24gKF9vYXV0aCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBzZWxmLl9vYXV0aC5vblJlcXVlc3QoX29hdXRoKVxuXG4gIHJldHVybiBzZWxmXG59XG5cblJlcXVlc3QucHJvdG90eXBlLmphciA9IGZ1bmN0aW9uIChqYXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBjb29raWVzXG5cbiAgaWYgKHNlbGYuX3JlZGlyZWN0LnJlZGlyZWN0c0ZvbGxvd2VkID09PSAwKSB7XG4gICAgc2VsZi5vcmlnaW5hbENvb2tpZUhlYWRlciA9IHNlbGYuZ2V0SGVhZGVyKCdjb29raWUnKVxuICB9XG5cbiAgaWYgKCFqYXIpIHtcbiAgICAvLyBkaXNhYmxlIGNvb2tpZXNcbiAgICBjb29raWVzID0gZmFsc2VcbiAgICBzZWxmLl9kaXNhYmxlQ29va2llcyA9IHRydWVcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFyZ2V0Q29va2llSmFyID0gamFyLmdldENvb2tpZVN0cmluZyA/IGphciA6IGdsb2JhbENvb2tpZUphclxuICAgIHZhciB1cmlocmVmID0gc2VsZi51cmkuaHJlZlxuICAgIC8vIGZldGNoIGNvb2tpZSBpbiB0aGUgU3BlY2lmaWVkIGhvc3RcbiAgICBpZiAodGFyZ2V0Q29va2llSmFyKSB7XG4gICAgICBjb29raWVzID0gdGFyZ2V0Q29va2llSmFyLmdldENvb2tpZVN0cmluZyh1cmlocmVmKVxuICAgIH1cbiAgfVxuXG4gIC8vIGlmIG5lZWQgY29va2llIGFuZCBjb29raWUgaXMgbm90IGVtcHR5XG4gIGlmIChjb29raWVzICYmIGNvb2tpZXMubGVuZ3RoKSB7XG4gICAgaWYgKHNlbGYub3JpZ2luYWxDb29raWVIZWFkZXIpIHtcbiAgICAgIC8vIERvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBDb29raWUgaGVhZGVyXG4gICAgICBzZWxmLnNldEhlYWRlcignY29va2llJywgc2VsZi5vcmlnaW5hbENvb2tpZUhlYWRlciArICc7ICcgKyBjb29raWVzKVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLnNldEhlYWRlcignY29va2llJywgY29va2llcylcbiAgICB9XG4gIH1cbiAgc2VsZi5famFyID0gamFyXG4gIHJldHVybiBzZWxmXG59XG5cbi8vIFN0cmVhbSBBUElcblJlcXVlc3QucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgb3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBpZiAoc2VsZi5yZXNwb25zZSkge1xuICAgIGlmIChzZWxmLl9kZXN0ZGF0YSkge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignWW91IGNhbm5vdCBwaXBlIGFmdGVyIGRhdGEgaGFzIGJlZW4gZW1pdHRlZCBmcm9tIHRoZSByZXNwb25zZS4nKSlcbiAgICB9IGVsc2UgaWYgKHNlbGYuX2VuZGVkKSB7XG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdZb3UgY2Fubm90IHBpcGUgYWZ0ZXIgdGhlIHJlc3BvbnNlIGhhcyBiZWVuIGVuZGVkLicpKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0uU3RyZWFtLnByb3RvdHlwZS5waXBlLmNhbGwoc2VsZiwgZGVzdCwgb3B0cylcbiAgICAgIHNlbGYucGlwZURlc3QoZGVzdClcbiAgICAgIHJldHVybiBkZXN0XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNlbGYuZGVzdHMucHVzaChkZXN0KVxuICAgIHN0cmVhbS5TdHJlYW0ucHJvdG90eXBlLnBpcGUuY2FsbChzZWxmLCBkZXN0LCBvcHRzKVxuICAgIHJldHVybiBkZXN0XG4gIH1cbn1cblJlcXVlc3QucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuX2Fib3J0ZWQpIHsgcmV0dXJuIH1cblxuICBpZiAoIXNlbGYuX3N0YXJ0ZWQpIHtcbiAgICBzZWxmLnN0YXJ0KClcbiAgfVxuICBpZiAoc2VsZi5yZXEpIHtcbiAgICByZXR1cm4gc2VsZi5yZXEud3JpdGUuYXBwbHkoc2VsZi5yZXEsIGFyZ3VtZW50cylcbiAgfVxufVxuUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5fYWJvcnRlZCkgeyByZXR1cm4gfVxuXG4gIGlmIChjaHVuaykge1xuICAgIHNlbGYud3JpdGUoY2h1bmspXG4gIH1cbiAgaWYgKCFzZWxmLl9zdGFydGVkKSB7XG4gICAgc2VsZi5zdGFydCgpXG4gIH1cbiAgaWYgKHNlbGYucmVxKSB7XG4gICAgc2VsZi5yZXEuZW5kKClcbiAgfVxufVxuUmVxdWVzdC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIXNlbGYucmVzcG9uc2VDb250ZW50KSB7XG4gICAgc2VsZi5fcGF1c2VkID0gdHJ1ZVxuICB9IGVsc2Uge1xuICAgIHNlbGYucmVzcG9uc2VDb250ZW50LnBhdXNlLmFwcGx5KHNlbGYucmVzcG9uc2VDb250ZW50LCBhcmd1bWVudHMpXG4gIH1cbn1cblJlcXVlc3QucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghc2VsZi5yZXNwb25zZUNvbnRlbnQpIHtcbiAgICBzZWxmLl9wYXVzZWQgPSBmYWxzZVxuICB9IGVsc2Uge1xuICAgIHNlbGYucmVzcG9uc2VDb250ZW50LnJlc3VtZS5hcHBseShzZWxmLnJlc3BvbnNlQ29udGVudCwgYXJndW1lbnRzKVxuICB9XG59XG5SZXF1ZXN0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpcy5jbGVhclRpbWVvdXQoKVxuICBpZiAoIXNlbGYuX2VuZGVkKSB7XG4gICAgc2VsZi5lbmQoKVxuICB9IGVsc2UgaWYgKHNlbGYucmVzcG9uc2UpIHtcbiAgICBzZWxmLnJlc3BvbnNlLmRlc3Ryb3koKVxuICB9XG59XG5cblJlcXVlc3QucHJvdG90eXBlLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMudGltZW91dFRpbWVyKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dFRpbWVyKVxuICAgIHRoaXMudGltZW91dFRpbWVyID0gbnVsbFxuICB9XG59XG5cblJlcXVlc3QuZGVmYXVsdFByb3h5SGVhZGVyV2hpdGVMaXN0ID1cbiAgVHVubmVsLmRlZmF1bHRQcm94eUhlYWRlcldoaXRlTGlzdC5zbGljZSgpXG5cblJlcXVlc3QuZGVmYXVsdFByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdCA9XG4gIFR1bm5lbC5kZWZhdWx0UHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0LnNsaWNlKClcblxuLy8gRXhwb3J0c1xuXG5SZXF1ZXN0LnByb3RvdHlwZS50b0pTT04gPSByZXF1ZXN0VG9KU09OXG5tb2R1bGUuZXhwb3J0cyA9IFJlcXVlc3RcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/request/request.js\n");

/***/ })

};
;